{"/getting-started":{"title":"Getting Started","data":{"":"Learn the most important framework concepts in just few minutes by coding a complete end-to-end example."}},"/getting-started/browser-integration":{"title":"Browser Integration","data":{"":"Now that we have our server running, we need front-end UI to interact with it.For all of the operations, the approach (as previously mentioned) is same which is to first get the unsigned transaction from server, use browser wallet's signTx method to get spending key witness for this transaction, and then use server's endpoint to add witness to this transaction & submit it.\nThe entire code pertaining to browser operations is available here.\nAn outline of this whole process is given below, illustrated via add-ref-script endpoint:\n// Obtain access to browser wallet api\nconst api: WalletApi = await window.cardano[selectedWallet].enable(); // Creating a type such as `WalletApi` was entirely optional.\n// Obtaining UTxOs to be used collaterals as given by browser wallet.\nconst colls = await api.experimental.getCollateral();\n// Create request body for calling our endpoint\nconst body = {\n  arsUsedAddrs: await api.getUsedAddresses(),\n  arsChangeAddr: await api.getChangeAddress(),\n  ...(0 in colls && { arsCollateral: colls[0] }),\n  arsPutAddress: convertAddrToRaw(values.putAddress), // implementation detail\n  arsBetParams: processBrpParams(brpParams), // implementation detail\n};\nconsole.log(body);\n// Call endpoint\nconst { data } = await axios.post(\"http://localhost:8081/betref/add-ref-script\", body);\nconsole.log(data);\n// Sign & submit\nconst { data: submitData } = await axios.post(\n  \"http://localhost:8081/tx/add-wit-and-submit\",\n  {\n    awasTxUnsigned: data.urspTxBodyHex,\n    awasTxWit: await api.signTx(data.urspTxBodyHex, true), // Note that this second argument (corresponding to \"partial signing\") needs to be `true` as for inputs such as those belonging to script already have their witness and we need to give witness only for inputs belonging to us.\n  },\n  {\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  }\n);\nWhat follows is the demo for all of the operations we defined.\nDue to security reasons, you would need to run this page locally (instructions here) to check out the following demo.\nAnd with this, we come to an end of our Getting Started guide ðŸ¥³! Hope you enjoyed it ðŸ’™\nHave questions? Ask them at Cardano StackExchange."}},"/getting-started/endpoints":{"title":"Creating Endpoints","data":{"":"Now that we are confident with our smart contract, it's time that we make it accessible to end user.The approach here would be\nFront-end asks to construct transaction body for the concerned operation.\nIt then receives this transaction body, which is complete besides missing for signature for spending inputs belonging to browser wallet. It calls wallet api's signTx method upon this body to get this signature (key witness).\nFrontend now passes this unsigned transaction body along with the witness it received to our backend endpoint which will add this witness to the transaction body, making it complete and would then submit it.\nWe'll use Servant to create our endpoints and one may understand it by following their easy to understand tutorial here.\nDo note that we can also sign the transactions in server using the signTx function defined in TxBody.hs","providing-data-provider#Providing Data Provider":"","defining-provider-configuration#Defining Provider Configuration":"As noted earlier, building transaction bodies require gathering suitable information from the blockchain. For this purpose, we'll require a provider. Atlas is unopinionated and allows user to plug in provider of their choice, including a locally hosted one.Currently Atlas supports the following providers (& it would be highly appreciated if community enriches this by contributing to Atlas):\nMaestro.\nLocally ran node.\nCardano DB Sync (but only for private network tests).\nTo provide information about the provider, we will create a config.json file whose contents could be as follows:\nWe have given a sample config.json file here.\n{\n  \"coreProvider\": { \"maestroToken\": \"<Your-API-Key>\" },\n  \"networkId\": \"testnet-preprod\",\n  \"logging\": [{ \"type\": { \"tag\": \"stderr\" }, \"severity\": \"Debug\", \"verbosity\": \"V2\" }],\n  \"utxoCacheEnable\": false\n}\n{\n  \"coreProvider\": { \"socketPath\": \"<Path-To-node.socket-File>\", \"maestroToken\": \"<Your-API-Key>\" },\n  \"networkId\": \"testnet-preprod\",\n  \"logging\": [{ \"type\": { \"tag\": \"stderr\" }, \"severity\": \"Debug\", \"verbosity\": \"V2\" }],\n  \"utxoCacheEnable\": false\n}\nHere is the explaination for each of the JSON keys above:\ncoreProvider: This field is the differentiating factor between different providers. Above we have given how it would look like for locally ran node & Maestro. Note that local node option still requires Maestro key for lookupDatum query.\nnetworkId: Specifies your network and must be one of mainnet, testnet-preprod, testnet-preview, testnet (for legacy testnet) & privnet (for local private network).\nlogging: It's a list of scribes to register. Its parameters (like severity, verbosity) and its general usage can be understood by going over their official haddock documentation here. Katip is also explained in this book on web development in Haskell.\nutxoCacheEnable: Enabling this boolean will enable cache (using Data.Cache) whereby queries related to fetching UTxOs won't generate call to provider if the entry exists in cache (& has not yet expired).","parsing-given-configuration#Parsing Given Configuration":"The file server-main.hs fires up our server. It reads & parses the configuration file and using it makes our endpoints (which we will define shortly) available. Here is its entire code.\n-- | Getting path for our core configuration.\nparseArgs :: IO FilePath\nparseArgs = do\n  args <- getArgs\n  case args of\n    coreCfg: _ -> return coreCfg\n    _invalidArgument -> fail \"Error: wrong arguments, needed a path to the CoreConfig JSON configuration file\\n\"\nmain :: IO ()\nmain = do\n  putStrLn \"Writing Swagger file ...\"\n  BL8.writeFile \"swagger-api.json\" (encodePretty apiSwagger)\n  putStrLn \"parsing Config ...\"\n  coreCfgPath <- parseArgs\n  coreCfg <- coreConfigIO coreCfgPath  -- Parsing our core configuration.\n  putStrLn \"Loading Providers ...\"\n  withCfgProviders coreCfg \"api-server\"  $ \\providers -> do\n    let port = 8081\n        ctx = Ctx coreCfg providers\n    putStrLn $ \"Starting server at \\n \" <> \"http://localhost:\" <> show port\n    run port $ app ctx\napp :: Ctx -> Application\napp ctx = cors (const $ Just simpleCorsResourcePolicy { corsRequestHeaders = [HttpTypes.hContentType] }) $ serve appApi $ hoistServer appApi (Handler . ExceptT . try)  $ apiServer ctx\nFocussing on the highlighted lines, you can see that it first reads the path to the configuration file (you would for instance run this file like so cabal run betref-server -- config.json) in line coreCfgPath <- parseArgs{:haskell}, then it parses this file coreCfg <- coreConfigIO coreCfgPath{:haskell}.We then see the use of an interesting function withCfgProviders. It's type is withCfgProviders :: GYCoreConfig  -> GYLogNamespace -> (GYProviders -> IO a) -> IO a{:haskell}, thus, this function first takes our parsed configuration file, then a namespace, finally followed by a continuation GYProviders -> IO a. Idea here is that this function will setup a GYProviders from the parsed configuration file and send it to this continuation to obtain its result.","defining-endpoints#Defining Endpoints":"","shared-context#Shared Context":"Entire code for it is available here\nOur endpoints would need an information for our provider, thus we have created the type for it, called Ctx. It's usage is made clear by function defined next, runQuery which in essence correspond to ctxRunC we saw in section on Integration Tests. Reasoning for runTxI & runTxF follows similarly.Note about our handling of collateral: Browser wallets usually have the option to set for collateral, in such a case wallets would create an UTxO specifically to be used as collateral and such an UTxO will be reserved, i.e., wallet won't be spending it. CIP 40 changed the properties related to collateral and therefore we can safely take even that UTxO as collateral which has large amounts of ada and it could also contain multiple assets. Therefore if there is no collateral set by browser wallet, framework is capable of choosing suitable UTxO as collateral (and also sets for return collateral & total collateral fields appropriately) and in that case it is also free to spend it, if required by transaction builder. But if however there is a 5-ada collateral set by wallet, then framework would use it as collateral and would also reserve it, i.e., it won't pick to spend it unless explicitly mentioned by transaction skeleton. Also note that, we'll use browser wallet's getCollateral() method to get for collateral. This method usually returns a list of ada-only UTxOs in wallet within a specific range (like in case of Nami, it is those with ada less than or equal to 50). We would send first element of this list (if exists) to backend and framework would check if the value contained in this UTxO is exactly 5 ada or not (like Nami's getCollateral method returns only a singleton list if collateral is set in wallet), if not, framework would ignore this (i.e., would not reserve for it) and would itself pick suitable UTxO as collateral. If however you want this to be reserved (& of course used as collateral) regardless of it's value, see the comment in call to runGYTxMonadNodeF in runTxF function.\n-- | Our Context.\ndata Ctx = Ctx\n  { ctxCoreCfg   :: !GYCoreConfig\n  , ctxProviders :: !GYProviders\n  }\n-- | To run for simple queries, the one which don't requiring building for transaction skeleton.\nrunQuery :: Ctx -> GYTxQueryMonadNode a -> IO a\nrunQuery ctx q = do\n  let nid       = cfgNetworkId $ ctxCoreCfg ctx\n      providers = ctxProviders ctx\n  runGYTxQueryMonadNode nid providers q\n-- | Wraps our skeleton under `Identity` and calls `runTxF`.\nrunTxI :: Ctx\n       -> [GYAddress]           -- ^ User's used addresses.\n       -> GYAddress             -- ^ User's change address.\n       -> Maybe GYTxOutRefCbor  -- ^ Browser wallet's reserved collateral (if set).\n       -> GYTxMonadNode (GYTxSkeleton v)\n       -> IO GYTxBody\nrunTxI = coerce (runTxF @Identity)\n-- | Tries to build for given skeletons wrapped under traversable structure.\nrunTxF :: Traversable t\n       => Ctx\n       -> [GYAddress]           -- ^ User's used addresses.\n       -> GYAddress             -- ^ User's change address.\n       -> Maybe GYTxOutRefCbor  -- ^ Browser wallet's reserved collateral (if set).\n       -> GYTxMonadNode (t (GYTxSkeleton v))\n       -> IO (t GYTxBody)\nrunTxF ctx addrs addr collateral skeleton  = do\n  let nid       = cfgNetworkId $ ctxCoreCfg ctx\n      providers = ctxProviders ctx\n  runGYTxMonadNodeF GYRandomImproveMultiAsset nid providers addrs addr\n    (collateral >>=\n      (\\c -> Just (getTxOutRefHex c,\n                   True  -- Make this as `False` to not do 5-ada-only check for value in this given UTxO to be used as collateral.\n                  )\n      )\n    ) skeleton","submit-endpoint#Submit Endpoint":"Entire code for it is available here\nWe'll soon see endpoints which will return for unsigned transaction to the browser but assuming that we already have a unsigned transaction CBOR & the missing signature, let's see how we can define an endpoint which will add this missing key witness to the transaction body and would then submit it using our provider.Input to this endpoint is a type AddWitAndSubmitParams encapsulating our unsigned transaction body & missing key witness.Then we have our function handleAddWitAndSubmitTx which adds the witness to the transaction making it complete and then it submits it. The response generated here is of type SubmitTxResponse and you can modify the same to include other fields if required.\n-- | Return type of API when submitting a transaction.\ndata SubmitTxResponse = SubmitTxResponse\n                          { submitTxFee :: !Integer\n                          , submitTxId  :: !GYTxId\n                          } deriving (Show, Generic, ToJSON, Swagger.ToSchema)\n-- | Input parameters to add for reference script.\ndata AddWitAndSubmitParams = AddWitAndSubmitParams\n  { awasTxUnsigned :: !GYTx\n  , awasTxWit      :: !GYTxWitness\n  } deriving (Generic, FromJSON, Swagger.ToSchema)\n-- | Construct `SubmitTxResponse` return type from the given signed transaction body.\ntxBodySubmitTxResponse :: GYTxBody -> SubmitTxResponse\ntxBodySubmitTxResponse txBody = SubmitTxResponse\n                                  { submitTxFee = txBodyFee txBody\n                                  , submitTxId  = txBodyTxId txBody\n                                  }\n-- | Type for our Servant API.\ntype TxAPI =\n      \"add-wit-and-submit\"\n    :> ReqBody '[JSON] AddWitAndSubmitParams\n    :> Post '[JSON] SubmitTxResponse\n-- | Serving our API.\nhandleTx :: Ctx -> ServerT TxAPI IO\nhandleTx = handleAddWitAndSubmitTx\n-- | Handle for adding key witness to the unsigned transaction & then submit it.\nhandleAddWitAndSubmitTx :: Ctx -> AddWitAndSubmitParams -> IO SubmitTxResponse\nhandleAddWitAndSubmitTx ctx AddWitAndSubmitParams{..} = do\n  let txBody = getTxBody awasTxUnsigned\n  void $ gySubmitTx (ctxProviders ctx) $ makeSignedTransaction awasTxWit txBody\n  return $ txBodySubmitTxResponse txBody","transaction-building-endpoints#Transaction Building Endpoints":"Entire code for it is available here\nAt this point, it should be easy to follow the code here. We first define the input type for our endpoint, we also derive its FromJSON instance so that we can parse it from JSON that our front-end will send for it and we also derive its Swagger.ToSchema instance so as to document our endpoint. Then our endpoint calls the relevant operation which we defined before to get transactoin skeleton, using which we obtain the transaction body with the help of functions such as runTxI and return the result (wrapped in our UnsignedTxResponse type).\nYou can see that all of our endpoints here ask for a list of used addresses, this makes them compatible with wallets that are not in single address mode (by default) such as Eternl.\n-- | Input wrapper around corresponding Plutus type.\ndata BetRefParams = BetRefParams\n  { brpOracleAddress :: !GYAddress\n  , brpBetUntil      :: !GYTime\n  , brpBetReveal     :: !GYTime\n  , brpBetStep       :: !GYValue\n  } deriving (Show, Generic, FromJSON, Swagger.ToSchema)\n-- | Convert the above `BetRefParams` with corresponding representation defined in our Plutus validator script.\nbetParamsToScript :: BetRefParams -> Script.BetRefParams\nbetParamsToScript brp = Script.BetRefParams\n  { Script.brpOraclePkh = pubKeyHashToPlutus $ fromJust $ addressToPubKeyHash $ brpOracleAddress brp\n  , Script.brpBetUntil = timeToPlutus $  brpBetUntil brp\n  , Script.brpBetReveal = timeToPlutus $ brpBetReveal brp\n  , Script.brpBetStep = valueToPlutus $  brpBetStep brp\n  }\n-- | Input parameters for place bet operation.\ndata PlaceBetRefParams = PlaceBetRefParams\n  { pbrUsedAddrs  :: ![GYAddress]\n  , pbrChangeAddr :: !GYAddress\n  , pbrCollateral :: !(Maybe GYTxOutRefCbor)\n  , pbrBetParams  :: !BetRefParams\n  , pbrBetGuess   :: !Integer\n  , pbrBetAmt     :: !GYValue\n  , pbrRefScript  :: !GYTxOutRef\n  , pbrPrevBetRef :: !(Maybe GYTxOutRef)\n  } deriving (Show, Generic, FromJSON, Swagger.ToSchema)\n-- | Input parameters for take bets operation.\ndata TakeBetRefParams = TakeBetRefParams\n  { tbrUsedAddrs         :: ![GYAddress]\n  , tbrChangeAddr        :: !GYAddress\n  , tbrCollateral        :: !(Maybe GYTxOutRefCbor)\n  , tbrBetParams         :: !BetRefParams\n  , tbrRefScript         :: !GYTxOutRef\n  , tbrPrevBetRef        :: !GYTxOutRef\n  , tbrOracleRefInputRef :: !GYTxOutRef\n  } deriving (Show, Generic, FromJSON, Swagger.ToSchema)\n-- | Input parameters to add for reference script.\ndata AddRefScriptParams = AddRefScriptParams\n  { arsUsedAddrs  :: ![GYAddress]\n  , arsChangeAddr :: !GYAddress\n  , arsCollateral :: !(Maybe GYTxOutRefCbor)\n  , arsPutAddress :: !GYAddress\n  , arsBetParams  :: !BetRefParams\n  } deriving (Show, Generic, FromJSON, Swagger.ToSchema)\n-- | Input parameters to add for reference input.\ndata AddRefInputParams = AddRefInputParams\n  { ariUsedAddrs  :: ![GYAddress]\n  , ariChangeAddr :: !GYAddress\n  , ariCollateral :: !(Maybe GYTxOutRefCbor)\n  , ariPutAddress :: !GYAddress\n  , ariBetAnswer  :: !Integer\n  } deriving (Show, Generic, FromJSON, Swagger.ToSchema)\n-- | Return type for our API endpoints defined here.\ndata UnsignedTxResponse = UnsignedTxResponse\n  { urspTxBodyHex :: !T.Text              -- ^ Unsigned transaction cbor.\n  , urspTxFee     :: !(Maybe Integer)     -- ^ Tx fees.\n  , urspUtxoRef   :: !(Maybe GYTxOutRef)  -- ^ Some operations might need to show for relevant UTxO generated.\n  } deriving (Show, Generic, FromJSON, ToJSON, Swagger.ToSchema)\n-- | Construct `UnsignedTxResponse` return type for our endpoint given the transaction body & relevant index for UTxO (if such exists).\nunSignedTxWithFee :: GYTxBody -> Maybe GYTxOutRef -> UnsignedTxResponse\nunSignedTxWithFee txBody mUtxoRef = UnsignedTxResponse\n  { urspTxBodyHex  = T.pack $ txToHex $ unsignedTx txBody\n  , urspTxFee      = Just $ txBodyFee txBody\n  , urspUtxoRef    = mUtxoRef\n  }\n-- | Type for our Servant API.\ntype BetRefApi =\n       \"place\"\n    :> ReqBody '[JSON] PlaceBetRefParams\n    :> Post    '[JSON] UnsignedTxResponse\n  :<|> \"take\"\n    :> ReqBody '[JSON] TakeBetRefParams\n    :> Post    '[JSON] UnsignedTxResponse\n  :<|> \"add-ref-script\"\n    :> ReqBody  '[JSON] AddRefScriptParams\n    :> Post     '[JSON] UnsignedTxResponse\n  :<|> \"add-ref-input\"\n    :> ReqBody  '[JSON] AddRefInputParams\n    :> Post     '[JSON] UnsignedTxResponse\n-- | Serving our API.\nhandleBetRefApi :: Ctx -> ServerT BetRefApi IO\nhandleBetRefApi ctx =   handlePlaceBet ctx\n                   :<|> handleTakeBet ctx\n                   :<|> handleAddRefScript ctx\n                   :<|> handleOracleRefInput ctx\n-- | Handle for place bet operation.\nhandlePlaceBet :: Ctx -> PlaceBetRefParams -> IO UnsignedTxResponse\nhandlePlaceBet ctx PlaceBetRefParams{..} = do\n  let brp = betParamsToScript pbrBetParams\n  validatorAddress <- runQuery ctx (betRefAddress brp)\n  txBody <- runTxI ctx pbrUsedAddrs pbrChangeAddr pbrCollateral\n              $ placeBet pbrRefScript (betParamsToScript pbrBetParams) (Script.OracleAnswerDatum pbrBetGuess) pbrBetAmt (head pbrUsedAddrs) pbrPrevBetRef\n  placeUtxoRef <- case find (\\utxo -> utxoAddress utxo == validatorAddress) $ utxosToList $ txBodyUTxOs txBody of\n        Nothing -> fail \"Shouldn't happen: No reference for placed bet in body\"\n        Just utxo -> pure $ utxoRef utxo\n  pure $ unSignedTxWithFee txBody $ Just placeUtxoRef\n-- | Handle for take bets operation.\nhandleTakeBet :: Ctx -> TakeBetRefParams -> IO UnsignedTxResponse\nhandleTakeBet ctx TakeBetRefParams{..} = do\n  txBody <- runTxI ctx tbrUsedAddrs tbrChangeAddr tbrCollateral\n              $ takeBets tbrRefScript (betParamsToScript tbrBetParams) tbrPrevBetRef (head tbrUsedAddrs) tbrOracleRefInputRef\n  pure $ unSignedTxWithFee txBody Nothing\n-- | Handle for adding reference script.\nhandleAddRefScript :: Ctx -> AddRefScriptParams  -> IO UnsignedTxResponse\nhandleAddRefScript  ctx AddRefScriptParams{..} = do\n  let validator = betRefValidator' (betParamsToScript arsBetParams)\n  txBody <- runTxI ctx arsUsedAddrs arsChangeAddr arsCollateral\n              $ pure $ addRefScript' arsPutAddress validator\n  let refs   = Limbo.findRefScriptsInBody txBody\n  outRef <- case Map.lookup (Some (validatorToScript validator)) refs of\n                 Nothing  -> fail \"Shouldn't happen: No reference for added Script in body\"\n                 Just ref -> return ref\n  pure $ unSignedTxWithFee txBody $ Just outRef\n-- | Handle for adding reference input.\nhandleOracleRefInput :: Ctx -> AddRefInputParams  -> IO UnsignedTxResponse\nhandleOracleRefInput  ctx AddRefInputParams{..} = do\n  let ourDatumPlutus = Script.OracleAnswerDatum ariBetAnswer\n      ourDatumGY = datumFromPlutusData ourDatumPlutus\n  txBody <- runTxI ctx ariUsedAddrs ariChangeAddr ariCollateral\n              $ pure $ addRefInput' ariPutAddress ourDatumPlutus\n  let utxos = utxosToList $ txBodyUTxOs txBody\n      ourDatumHash = hashDatum ourDatumGY\n      mRefInputUtxo = find (\\utxo ->\n        case utxoOutDatum utxo of\n          GYOutDatumHash dh  -> ourDatumHash == dh\n          GYOutDatumInline d -> ourDatumGY == d\n          GYOutDatumNone     -> False\n        ) utxos\n  case mRefInputUtxo of\n    Nothing               -> fail \"Shouldn't happen: Couldn't find the desired UTxO in Tx outputs\"\n    Just GYUTxO {utxoRef} -> pure $ unSignedTxWithFee txBody $ Just utxoRef","wrap-up#Wrap-Up":"Our both the endpoints file (transaction submition & transaction building) our wrapped up in our Api.hs following the usual servant boilerplate.\n-- | Type for our Servant API.\ntype Api =\n        \"tx\"  :> TxAPI\n  :<|>  \"betref\" :>  BetRefApi\nappApi :: Proxy Api\nappApi = Proxy\napiSwagger  :: Swagger\napiSwagger  = toSwagger appApi\napiServer :: Ctx -> ServerT Api IO\napiServer ctx =\n       handleTx ctx\n  :<|> handleBetRefApi ctx\nNow coming back to our server-main.hs file, we can now understand the highlighted code sections which relates to obtaining the Swagger file (generated from apiSwagger function above) and running up our servant server.\nWe follow simpleCorsResourcePolicy (also allowing Content-Type request header) so that calls by our front-end (which runs on different origin) don't get blocked.\n-- | Getting path for our core configuration.\nparseArgs :: IO FilePath\nparseArgs = do\n  args <- getArgs\n  case args of\n    coreCfg: _ -> return coreCfg\n    _invalidArgument -> fail \"Error: wrong arguments, needed a path to the CoreConfig JSON configuration file\\n\"\nmain :: IO ()\nmain = do\n  putStrLn \"Writing Swagger file ...\"\n  BL8.writeFile \"swagger-api.json\" (encodePretty apiSwagger)\n  putStrLn \"parsing Config ...\"\n  coreCfgPath <- parseArgs\n  coreCfg <- coreConfigIO coreCfgPath  -- Parsing our core configuration.\n  putStrLn \"Loading Providers ...\"\n  withCfgProviders coreCfg \"api-server\"  $ \\providers -> do\n    let port = 8081\n        ctx = Ctx coreCfg providers\n    putStrLn $ \"Starting server at \\n \" <> \"http://localhost:\" <> show port\n    run port $ app ctx\napp :: Ctx -> Application\napp ctx = cors (const $ Just simpleCorsResourcePolicy { corsRequestHeaders = [HttpTypes.hContentType] }) $ serve appApi $ hoistServer appApi (Handler . ExceptT . try)  $ apiServer ctx\nNext we'll see how to call these endpoints in our front-end!"}},"/getting-started/how-to-build":{"title":"How to build Atlas?","data":{"":"We currently support GHC version 9.2.8 and compilation is tested with cabal version 3.10.2.0.Besides basic Haskell tooling (GHC and cabal), since we depend upon libraries used in cardano-node, one would need to have additional dependencies as described in this guide related to building node from source. When referring to that guide, for our purposes, section on \"Installing the Haskell environment\" and sections following (& including) \"Downloading the source code for cardano-node\" are irrelevant.Additionally one would need libpq-dev or postgresql installed in their environment otherwise an error suggesting missing pg_config can occur.We build Atlas in our Github CI using environment described here which one can also refer if they encounter a build failure.To verify if environment is configured properly, one can clone Atlas repository from here and run cabal build all to see if build is successful.","building-with-nix#Building with Nix":"Alternatively, we provide a nix shell with all dependencies baked in. Please refer to this guide on how to configure nix and later one can enter development shell via nix develop."}},"/getting-started/integration-tests":{"title":"Integration Tests","data":{"":"We already saw how we can conveniently write tests for our smart contract using our wrapper upon Plutus simple model. But these tests were running against a mock ledger, i.e., we really were just simulating it by having some mock data-structures (say set of UTxOs) which were getting updated on submission of successful transaction. We could however write tests to test against the real node and have it slightly more convenient to program against by spinning up our own private network (privnet for short). Here is the table which outlines the differences between the two approaches:\nTests using PSM Wrapper\tTests using Private Network\tRuns against mock ledger\tRuns against real node\tEach unit test gets fresh set of wallets (having original balance)\tEach subsequent unit test continues upon the effects caused by previous ones\tFast, purer (no IO) & convenient\tSlow as each slot is 0.1 second\t\nThus these tests are suitable for integration testing.","spinning-up-private-network#Spinning up private network":"Our private network is adapted from WoofPool's cardano-private-testnet-setup repository.To spin up it up:\nClone this repository. Make sure to not clone it in some deep nested path as then the path length towards the generated socket file (node.sock) may exceed 108 characters.\nEnter it & checkout geniusyield branch.\nEnter the following in terminal: ./scripts/automate.sh (you would need to have cardano-node & cardano-cli available in your PATH).\nOnce it says, \"Congrats! Your network is ready for use!\" you can attempt to run the tests (in another terminal).First, let's say the path to private-testnet-simple is X, then being inside your example project folder, you can execute the tests by running GENIUSYIELD_PRIVNET_DIR=$X/private-testnet cabal run betref-privnet-tests -- -j1The -j1 is needed so that the tests run sequentially.\nRemember to stop (CTRL-C, and killall cardano-node) the private testnet, or it will eventually eat all of your disk space.\nThe way we have it setup for our test boilerplate is that we have nine users where users second to nine start with the following balances:\n5 UTxOs each containing thousand ada\n1 million each of gold & iron tokens\nFirst user is called \"funder\" as it has far more ada (couple of 100 thousands) and the number of gold & iron tokens is 2 millions.We'll also see how to create a new user soon, if required.\nUnless you kill & restart the private network, running your privnet tests again, would have them run in the modified network state. So in general, if you wish to reexecute the command mentioned before, viz. ATLAS_PRIVNET_DIR=$(pwd)/private-testnet-simple/private-testnet cabal run privnet-tests -- -j1, you should first restart the privnet.","understanding-our-first-test#Understanding our first test":"The tests are written in this file and are being called here.\nHere is the code (& explaination follows after it):\n  testCaseSteps \"Balance checks & taking pot by closest guesser should pass\" $ \\info -> withSetup setup info $ \\ctx -> do\n    -- First step: Construct the parameters and obtain validator from it.\n    --\n    -- Let's define a new User to represent Oracle (not necessary though)\n    oracleUser <- newTempUserCtx ctx (ctxUserF ctx) (valueFromLovelace 20_000_000) False\n    (currentSlot, slotConfig) <- getSlotAndConfig ctx\n    let betUntilSlotDelta = 100\n        betRevealSlotDelta = 200\n        betUntilTime = slotToBeginTimePure slotConfig (unsafeAdvanceSlot currentSlot betUntilSlotDelta)\n        betRevealTime = slotToBeginTimePure slotConfig (unsafeAdvanceSlot currentSlot betRevealSlotDelta)\n        brp = BetRefParams (pubKeyHashToPlutus $ userPkh oracleUser) (timeToPlutus betUntilTime) (timeToPlutus betRevealTime) (valueToPlutus $ valueFromLovelace 10_000_000)\n        validator = betRefValidator' brp\n    validatorAddress <- ctxRunC ctx (ctxUserF ctx) $ betRefAddress brp\n    -- Second step: Putting reference script for validator.\n    refScript <- addRefScriptCtx ctx (ctxUserF ctx) (validatorToScript validator)\n    -- Third step: Put some bets.\n    --\n    -- 1st bet.\n    txBodyLock <- ctxRunI ctx (ctxUser3 ctx) $ placeBet refScript brp (OracleAnswerDatum 1) (valueFromLovelace 10_000_000) (userAddr (ctxUser3 ctx)) Nothing\n    lockedORef <- findOutput validatorAddress txBodyLock\n    void $ submitTx ctx (ctxUser3 ctx) txBodyLock\n    -- Balance of `(ctxUser2 ctx)` before placing the bet\n    balance <- ctxQueryBalance ctx (ctxUser2 ctx)\n    --\n    -- 2nd bet.\n    txBodyLockUser2 <- ctxRunI ctx (ctxUser2 ctx) $ placeBet refScript brp (OracleAnswerDatum 2) (valueFromLovelace 20_000_000) (userAddr (ctxUser2 ctx)) (Just lockedORef)\n    lockedORef <- findOutput validatorAddress txBodyLockUser2\n    void $ submitTx ctx (ctxUser2 ctx) txBodyLockUser2\n    --\n    -- 3rd bet.\n    txBodyLock <- ctxRunI ctx (ctxUser3 ctx) $ placeBet refScript brp (OracleAnswerDatum 3) (valueFromLovelace 35_000_000) (userAddr (ctxUser3 ctx)) (Just lockedORef)\n    lockedORef <- findOutput validatorAddress txBodyLock\n    void $ submitTx ctx (ctxUser3 ctx) txBodyLock\n    -- Fourth step, get the bets pot.\n    --\n    -- Let's first wait for the required amount\n    ctxWaitUntilSlot ctx (unsafeAdvanceSlot currentSlot betRevealSlotDelta)  -- here this `currentSlot` is what we obtained sometime ago, the actual current slot has certainly increased a lot by now.\n    --\n    -- Let's then add for the reference input\n    refInputORef <- addRefInputCtx ctx (ctxUserF ctx) True (userAddr oracleUser) (datumFromPlutusData (OracleAnswerDatum 2))\n    --\n    -- Unlock operation\n    txBodyUnlock <- ctxRunI ctx (ctxUser2 ctx) $ takeBets refScript brp lockedORef (userAddr (ctxUser2 ctx)) refInputORef\n    void $ submitTx ctx (ctxUser2 ctx) txBodyUnlock\n    --\n    -- Balance of `(ctxUser2 ctx)` after unlocking\n    let adaExpectedIncrease = valueFromLovelace 45_000_000\n    assertUserFunds (txBodyFee txBodyUnlock + txBodyFee txBodyLockUser2) ctx (ctxUser2 ctx) $ balance <> adaExpectedIncrease\nThe first line testCaseSteps \"test description\" $ \\info -> withSetup setup info $ \\ctx -> do can be seen as a boilerplate for all of your tests.ctx denotes the so called context (of type Ctx) and contains information about our users, additional tokens, etc. It is defined in Ctx.hs file and it is essential to go over that file if you intend to write these tests.Variable info is used to log messages and you can use it in your test's do block like info $ printf \"Hello from %s\" \"Atlas\"We next see the use of newTempUserCtx utility function. As mentioned before, we already have nine users in our context, where they have the type User:\ndata User = User\n    { userSKey :: !GYPaymentSigningKey\n    , userAddr :: !GYAddress\n    }\nBut at rare times, we might need to create a new user. Such a user would not be part of the context and thus would be local to the test creating it.We can do that with the help of newTempUserCtx function. It accepts the context parameter, the user which will fund this new user, the value to be given to this new user and a boolean denoting whether we want to create a 5-ada-only UTxO too for this new user.Next we see the use of getSlotAndConfig function. Earlier when we wrote for PSM tests, we could work in absolute slots as we were always running each test from the beginning of ledger but this is not the case here. Thus, we would need to work with relative slots, i.e., we find the current slot and then add offset with respect to it. Function getSlotAndConfig has the folowing definition:\ngetSlotAndConfig :: Ctx -> IO (GYSlot, GYSlotConfig)\ngetSlotAndConfig ctx = do\n  slot <- ctxCurrentSlot ctx\n  sc   <- ctxSlotConfig ctx\n  return (slot, sc)\nNext we compute for our contract parameters and since we already obtained the slot config, we can use slotToBeginTimePure instead of slotToBeginTime.We next see the use of ctxRunC. To understand it, we need to first look at signature of ctxRunF.\nctxRunF :: forall t v. Traversable t => Ctx -> User -> GYTxMonadNode (t (GYTxSkeleton v)) -> IO (t GYTxBody)\nWe see that it has a type variable t which should have an instance of Traversable. The other two functions, namely ctxRunC & ctxRunI call this ctxRunF function with suitable instantiation of type variable t.Here is the table which explains about these three (ctxRunF, ctxRunC & ctxRunI) related functions:\nFunction\tWhen to use?\tWhat does it do?\tctxRunI\tWhen you want to build for single GYTxSkeleton\tIt wraps our skeleton under Identity, that is what suffix I stands for\tctxRunF\tWhen you have say multiple skeletons, like [GYTxSkeleton], or Maybe GYTxSkeleton\t-\tctxRunC\tWhen you don't want to build skeletons. This is in particular useful for operations like utxosAtAddress\tThe type constructor Const is defined as newtype Const a b = Const { getConst :: a } and therefore type parameter b is phantom and thus this function helps us ignore for GYTxSkeleton\t\nWe next add for reference script using helper utility function addRefScriptCtx.We then start placing our bets, once we have the transaction body, we use findOutput function which gives us the reference to the UTxO (the first one it finds) that is being locked at the script address.After placing our bets, we use ctxWaitUntilSlot to wait till the unlock slot.Note that we queried the balance of unlocker so that we can compare with it later.We next add for our reference input using addRefInputCtx helper utility function.Next we perform the unlock operation (calling our takeBets operation).Lastly, we verify that the unlocker was able to take all the bets by comparing the balance using assertUserFunds method. Here is it's definition:\n-- | Asserts if the user funds change as expected. This function subtracts fees from the given expected value.\nassertUserFunds :: Integer -> Ctx -> User -> GYValue -> IO ()\nassertUserFunds fees ctx u expectedValue = do\n    currentValue <- ctxQueryBalance ctx u\n    let expectedValue' = expectedValue `valueMinus` valueFromLovelace fees\n    assertBool (unwords [\"The value didn't change as expected\",\n                         \"\\nExpected: \", show expectedValue',\n                         \"\\nCurrent: \", show currentValue])\n               (currentValue == expectedValue')","writing-a-failing-test#Writing a failing test":"Now let's see another test where we slightly modify the last step (all the rest is same) and this time we instead try to take funds by not the closest guesser.\n  -- Fourth step, get the bets pot.\n  --\n  -- Let's first wait for the required amount\n  ctxWaitUntilSlot ctx (unsafeAdvanceSlot currentSlot betRevealSlotDelta)  -- here this `currentSlot` is what we obtained sometime ago, the actual current slot has certainly increased a lot by now.\n  --\n  -- Let's then add for the reference input\n  refInputORef <- addRefInputCtx ctx (ctxUserF ctx) True (userAddr oracleUser) (datumFromPlutusData (OracleAnswerDatum 2))\n  --\n  -- Unlock operation\n  -- But this time by wrong guesser\n  assertThrown isTxBodyErrorAutoBalance $ ctxRunI ctx (ctxUser3 ctx) $ takeBets refScript brp lockedORef (userAddr (ctxUser3 ctx)) refInputORef\nNotice that we try catching the error using assertThrown function. Here isTxBodyErrorAutoBalance is defined as (both this & assertThrown have their definitions in Asserts.hs file):\nisTxBodyErrorAutoBalance :: BuildTxException -> Bool\nisTxBodyErrorAutoBalance (BuildTxBodyErrorAutoBalance _) = True\nisTxBodyErrorAutoBalance _                               = False\nThus our assertThrown function checks for two things:\nWhether our action indeed raises an exception.\nIf an exception is raised, does it saitsfy our predicate? For instance, here our predicate was isTxBodyErrorAutoBalance.\nYou can also catch for IO error like:\n  errored <- catchIOError (submitTx ctx (ctxUserF ctx) txBody >> pure False) (\\_ -> pure True)\n  unless errored $ assertFailure \"Expecting an IOError exception\"\nWith this we conclude upon writing integration tests.For convenience, you can write a bash script which combines setup, running tests & closing the privnet all into one simple script.Even though this user is local to the test which created it, it would still persist in our private network.Technically, it's not wrapper that is happening place here but rather we coerce with Identity newtype.Therefore this function is intended to be used when we create only a single output for an external address.https://unix.stackexchange.com/q/367008"}},"/getting-started/operations":{"title":"Operations over Contract","data":{"":"Having understood the contract. Now is the time we actually start using our framework to build the transactions for it.The main principle to understand here is that - we only need to give the essentials, i.e. we only specify what we want and it is the job of the framework to do the rest.For instance, we may tell that we want to consume a specific input belonging to the script's address and generate a specific output. Given that, it becomes framework's job to do the rest, say:\nSelect available UTxO's in user's wallet and generate suitable change output to balance the transaction, considering fees.\nMake sure all generated UTxO's satisfy minimum ada requirement.\nHandle collateral.\netc, etc.\nThus, we only specify at high-level what we want. This would become clear as we actually start writing operations for our contract.Entire code for these operations is available here.","operation-1-generating-address-for-our-smart-contract#Operation 1: Generating address for our Smart Contract":"","generating-validator-for-our-smart-contract#Generating Validator for our Smart Contract":"Following the usual drill, we generate the Validator given contract parameters (following is written in file Compiled.hs):\n-- | Generates validator given params.\nbetRefValidator :: BetRefParams -> Validator\nbetRefValidator betRefParams = mkValidatorScript $\n    $$(PlutusTx.compile [|| mkBetRefValidator||]) `PlutusTx.applyCode` PlutusTx.liftCode betRefParams\nWhat we have obtained is of type Validator, defined in plutus-ledger-api, which is nothing but a wrapper around Script type defined in same.Likewise, we have our own types, GYValidator (similarly GYMintingPolicy for minting policy scripts) & GYScript (defined in Script.hs) to represent these in our framework.The file mentioned Script.hs contains a lot of helper utilities such as validatorFromPlutus which takes in Plutus's Validator type to give out GYValidator. Though there has been slight abuse in mentioning type here as what is actually given out is GYValidator v where type variable v is of kind PlutusVersion which is defined in file PlutusVersion.hs which you can understand as being here to denote plutus version for our validator script.If we look at the type signature of validatorFromPlutus, we see: validatorFromPlutus :: forall v. SingPlutusVersionI v => Plutus.Validator -> GYValidator v where for the time being we can ignore the description of the typeclass SingPlutusVersionI besides noting the fact that only types (currently 'PlutusV1 & 'PlutusV2) of kind PlutusVersion have an instance for it. So here, our function validatorFromPlutus works for all type variable v which have an instance of SingPlutusVersionI but there is no way to learn what this v is based solely on the input Plutus.Validator and therefore, caller must specify it, either by providing type signature (of callee or caller due to type inference) or by using visible type application. Our first operation does make use of it but before looking at it, we need to understand about GYTxQueryMonad.","interlude---gytxquerymonad#Interlude - GYTxQueryMonad":"When we want to obtain the address of the script from its hash, besides the hash, we also need to know the network we are currently operating at. Is it some testnet or mainnet?Similarly, transaction building involves querying the ledger for various information like say querying UTxO's present at one's address, similarly it might need help of some chain indexer to query datum in case output contains only the datum's hash.All of this is captured by typeclass GYTxQueryMonad defined here and also shown below (kindly see all these functions defined for this typeclass).\n-- | Class of monads for querying chain data.\nclass MonadError GYTxMonadException m => GYTxQueryMonad m where\n    {-# MINIMAL networkId, lookupDatum, (utxoAtTxOutRef | utxosAtTxOutRefs), (utxosAtAddress | utxosAtAddresses), slotConfig, currentSlot, logMsg #-}\n    -- | Get the network id\n    networkId :: m GYNetworkId\n    -- | Lookup datum by its hash.\n    lookupDatum :: GYDatumHash -> m (Maybe GYDatum)\n    -- | Lookup 'GYUTxO' at 'GYTxOutRef'.\n    --\n    utxoAtTxOutRef :: GYTxOutRef -> m (Maybe GYUTxO)\n    utxoAtTxOutRef ref = do\n        utxos <- utxosAtTxOutRefs [ref]\n        return $ case utxosToList utxos of\n            []       -> Nothing\n            utxo : _ -> Just utxo\n    -- | Lookup 'GYUTxOs' at multiple 'GYTxOutRef's at once\n    utxosAtTxOutRefs :: [GYTxOutRef] -> m GYUTxOs\n    utxosAtTxOutRefs orefs = utxosFromList <$> wither utxoAtTxOutRef orefs\n    -- | Lookup 'GYUTxOs' at 'GYAddress'.\n    utxosAtAddress :: GYAddress -> m GYUTxOs\n    utxosAtAddress = utxosAtAddresses . return\n    -- | Lookup 'GYUTxOs' at zero or more 'GYAddress'.\n    utxosAtAddresses :: [GYAddress] -> m GYUTxOs\n    utxosAtAddresses = foldM f mempty\n      where\n        f :: GYUTxOs -> GYAddress -> m GYUTxOs\n        f utxos addr = (<> utxos) <$> utxosAtAddress addr\n    -- | Lookup the `[GYTxOutRef]`s at a `GYAddress`\n    utxoRefsAtAddress :: GYAddress -> m [GYTxOutRef]\n    utxoRefsAtAddress = fmap (Map.keys . mapUTxOs id) . utxosAtAddress\n    {- | Obtain the slot config for the network.\n    Implementations using era history to create slot config may raise 'GYEraSummariesToSlotConfigError'.\n    -}\n    slotConfig :: m GYSlotConfig\n    -- | Lookup the current 'GYSlot'.\n    currentSlot :: m GYSlot\n    -- | Log a message with specified namespace and severity.\n    logMsg :: HasCallStack => GYLogNamespace -> GYLogSeverity -> String -> m ()\nSo, if we are working inside a monad which happens to also provide an instance for it, we would happily be able to query such an information.","generating-address#Generating address":"In this operation, we only need to obtain network details with the help of this monad. Here is the code to obtain address (notice that we have provided multiple versions of the same code here):\nType of scriptAddress used below (& defined in Class.hs) is scriptAddress :: forall (m :: * -> *) (v :: PlutusVersion). GYTxQueryMonad m => GYValidator v -> m GYAddress. Thus with respect to type application, the first parameter is for monad and second one is PlutusVersion kinded.Internally this function queries for network details.\n-- A. Type is given by `scriptAddress`.\n-- | Validator in question, obtained after giving required parameters.\nbetRefValidator' ::  SingPlutusVersionI v => BetRefParams -> GYValidator v\nbetRefValidator' brp = validatorFromPlutus $ betRefValidator brp\n-- | Address of the validator, given params.\nbetRefAddress :: (HasCallStack, GYTxQueryMonad m) => BetRefParams -> m GYAddress\nbetRefAddress brp = scriptAddress @_ @'PlutusV2 $ betRefValidator' brp\n-- B. Type is given by `validatorFromPlutus` using type application.\n-- | Validator in question, obtained after giving required parameters.\nbetRefValidator' brp = validatorFromPlutus @'PlutusV2 $ betRefValidator brp\n-- | Address of the validator, given params.\nbetRefAddress :: (HasCallStack, GYTxQueryMonad m) => BetRefParams -> m GYAddress\nbetRefAddress brp = scriptAddress $ betRefValidator' brp\n-- C. Type is specified using signature.\n-- | Validator in question, obtained after giving required parameters.\nbetRefValidator' :: BetRefParams -> GYValidator 'PlutusV2\nbetRefValidator' brp = validatorFromPlutus $ betRefValidator brp\n-- | Address of the validator, given params.\nbetRefAddress :: (HasCallStack, GYTxQueryMonad m) => BetRefParams -> m GYAddress\nbetRefAddress brp = scriptAddress $ betRefValidator' brp\nWell what is this monad m being used here? Well any! As long as it has an instance for GYTxQueryMonad. When we will start writing tests, then we'll use all of these operations and most likely how to use them would become clear then.","operation-2-adding-input-to-refer-later-reference-input#Operation 2: Adding Input to refer later (Reference Input)":"","interlude---gytxskeleton#Interlude - GYTxSkeleton":"As mentioned before, we just mention at high level what we want in a transaction. This is captured by GYTxSkeleton defined here and its description is mentioned below.\nFields\tRepresented by\tAdditional details\tInputs\tgytxIns\tIt is a list of inputs where for each input, we have its UTxO reference (the \"TxIn\" as the cardano ledger specification calls it) and a witness. In case this UTxO doesn't belong to a script, we just need spending key witness, otherwise we need the associated script, its datum and input redeemer where the associated script could be provided as part of this transaction body or could be obtained from reference input. See TxIn.hs.\tOutputs\tgytxOuts\tList of outputs produced by this transaction where for each output we can mention whether the datum is to be inlined or not and whether this output stores any script. See TxOut.hs.\tReference Inputs\tgytxRefIns\tSet of reference to UTxOs corresponding to reference inputs. Defined in same file, viz. Class.hs.\tMints\tgytxMint\tMap of minting policy to pair of redeemer and another map for token name to mint amount for that token.\tSignatories\tgytxSigs\tSet of Public Key Hash of Signatories.\tValid after\tgytxInvalidBefore\tJust the corresponding node slot.\tValid before\tgytxInvalidAfter\tSame as above.\t\nCorresponding snippet of haskell code:\ndata GYTxSkeleton (v :: PlutusVersion) = GYTxSkeleton\n    { gytxIns           :: ![GYTxIn v]\n    , gytxOuts          :: ![GYTxOut v]\n    , gytxRefIns        :: !(GYTxSkeletonRefIns v)\n    , gytxMint          :: !(Map (Some GYMintingPolicy) (Map GYTokenName Integer, GYRedeemer))\n    , gytxSigs          :: !(Set GYPubKeyHash)\n    , gytxInvalidBefore :: !(Maybe GYSlot)\n    , gytxInvalidAfter  :: !(Maybe GYSlot)\n    } deriving Show\nWhen constructing the transaction, we just need to specify what we want in this skeleton.This skeleton naturally has a monoid instance where two skeletons are combined by running mappend over each of their fields. We have utility functions defined in the same file Class.hs like (note that there are other helpful functions defined in the same file and it would in general be useful to go over them):\nmustHaveOutput :: GYTxOut v -> GYTxSkeleton v\nmustHaveOutput o = emptyGYTxSkeleton {gytxOuts = [o]}\nmustHaveInput :: GYTxIn v -> GYTxSkeleton v\nmustHaveInput i = emptyGYTxSkeleton {gytxIns = [i]}\nmustHaveRefInput :: VersionIsGreaterOrEqual v PlutusV2 => GYTxOutRef -> GYTxSkeleton v\nmustHaveRefInput i = emptyGYTxSkeleton { gytxRefIns = GYTxSkeletonRefIns (Set.singleton i) }\nmustMint :: GYMintingPolicy u -> GYRedeemer -> GYTokenName -> Integer -> GYTxSkeleton v\nmustMint p r tn n = emptyGYTxSkeleton {gytxMint = Map.singleton (Some p) (Map.singleton tn n, r)}\nmustBeSignedBy :: GYPubKeyHash -> GYTxSkeleton v\nmustBeSignedBy pkh = emptyGYTxSkeleton {gytxSigs = Set.singleton pkh}\nisInvalidBefore :: GYSlot -> GYTxSkeleton v\nisInvalidBefore s = emptyGYTxSkeleton {gytxInvalidBefore = Just s}\nisInvalidAfter :: GYSlot -> GYTxSkeleton v\nisInvalidAfter s = emptyGYTxSkeleton {gytxInvalidAfter = Just s}\nThus we can specify that our transaction must have this output (using mustHaveOutput) and that output and must have this input (using mustHaveInput) and so on... and combine them all into a single skeleton using mappend.","skeleton-for-adding-reference-input#Skeleton for adding reference input":"Here we want to create an output at a given address (Oracle's address) with the given datum. This UTxO is to be later used as a reference input by script where the script would refer to its datum. Here we have decided to keep this datum inline as currently framework is not supporting reading datum for a reference input whose output contains only datum hash.\n-- | Add UTxO to be used as reference input at a given address with given datum.\naddRefInput :: GYAddress -> OracleAnswerDatum -> GYTxSkeleton 'PlutusV2\naddRefInput addr dat =\n  mustHaveOutput $ GYTxOut addr mempty (Just (datumFromPlutusData dat, GYTxOutUseInlineDatum)) Nothing\n  -- Note that the value can be empty as tx building logic would add the needed minimum UTxO ada.\nNote that we have mentioned the value as empty for this UTxO and this is one of the beauties of our framework that it will itself manage adding lovelaces to satisfy minimum ada requirement.","q-can-you-create-a-skeleton-for-adding-reference-script#Q: Can you create a skeleton for adding reference script?":"Toggle Answer \nGiven the output address addr :: GYAddress{:haskell} and the Plutus V2 validator script :: GYValidator 'PlutusV2{:haskell}, we can write mustHaveOutput $ GYTxOut addr mempty (Just (datumFromPlutusData (), GYTxOutDontUseInlineDatum)) (Just $ validatorToScript script){:haskell}","operation-3-placing-a-bet#Operation 3: Placing a bet":"","placing-the-first-bet#Placing the first bet":"In case this is a first bet (a program handling the bets can decide whether the bet being placed by the user is first or not by querying the UTxOs at the script address), then we just need to produce an output at the script address with the bet value and our guess.\n-- | Operation to place bet.\nplaceBet :: (HasCallStack, GYTxMonad m)\n              => GYTxOutRef         -- ^ Reference Script.\n              -> BetRefParams       -- ^ Validator Params.\n              -> OracleAnswerDatum  -- ^ Guess.\n              -> GYValue            -- ^ Bet amount to place.\n              -> GYAddress          -- ^ Own address.\n              -> Maybe GYTxOutRef   -- ^ Reference to previous bets UTxO (if any).\n              -> m (GYTxSkeleton PlutusV2)\nplaceBet refScript brp guess bet ownAddr mPreviousBetsUtxoRef = do\n  pkh <- addressToPubKeyHash' ownAddr\n  betAddr <- betRefAddress brp\n  case mPreviousBetsUtxoRef of\n    -- This is the first bet.\n    Nothing -> do\n      return $ mustHaveOutput $ GYTxOut\n        { gyTxOutAddress = betAddr\n        , gyTxOutValue = bet\n        , gyTxOutDatum = Just (datumFromPlutusData $ BetRefDatum [(pubKeyHashToPlutus pkh, guess)] (valueToPlutus bet), GYTxOutDontUseInlineDatum)\n        , gyTxOutRefS    = Nothing\n        }\nAt this point, it should be clear what is happening in the above code block. This function is somewhat overloaded and is handling both the cases whether the bet is first or not and it determines this using the presence of reference to a UTxO (representing previous bets) at validator script. In case there isn't one, i.e., Nothing for our Maybe value, we are placing the first bet. Notice that we mention that our datum shouldn't be inlined to output using GYTxOutDontUseInlineDatum.","placing-subsequent-bets#Placing subsequent bets":"Here we would be exercising script's logic for the first time. We would be consuming the UTxO present at script address. We have defined a function, viz. input which would take in the following parameters:\nBetRefParams: to generate the validator script or else we can read the script from the UTxO pertaining to reference script.\nReference to reference script UTxO.\nReference of script input to consume.\nThe datum present at this input. Recall that our datum was not inlined for this particular output, we therefore would need lookup the datum using lookupDatum to pass the actual datum to this function.\nRedeemer action.\nThus, we have its definition as:\n-- | Utility function to consume script UTxO.\ninput :: BetRefParams -> GYTxOutRef -> GYTxOutRef -> BetRefDatum -> BetRefAction -> GYTxSkeleton 'PlutusV2\ninput brp refScript inputRef dat red =\n  mustHaveInput GYTxIn\n    { gyTxInTxOutRef = inputRef\n    , gyTxInWitness  = GYTxInWitnessScript\n        (GYInReference refScript $ validatorToScript $ betRefValidator' brp)\n        (datumFromPlutusData dat)\n        (redeemerFromPlutusData red)\n    }\nIn case we didn't want to use reference script, we would write gyTxInWitness as:\ngyTxInWitness  = GYTxInWitnessScript\n        (GYInScript (validatorToScript $ betRefValidator' brp))\n        (datumFromPlutusData dat)\n        (redeemerFromPlutusData red)\nFollowing is the complete code for handling this case. Few comments to facilitate its understanding:\nWe first query the UTxO corresponding to previous bets at script address and we then query for its datum using utxoDatum' which tries its best to retrieve the datum and raises an exception in case it fails. This is its signature: utxoDatum' :: (GYTxQueryMonad m, Plutus.FromData a) => GYUTxO -> m (GYAddress, GYValue, a).\nNote: utxoAtTxOutRef' (defined again in Class.hs) is a wrapper around utxoAtTxOutRef which raises an exception in case the result was Nothing.\nWe then see the use of gyLogDebug' which as you would expect is for logging purposes. The first argument that it takes correspond to namespace as used by Katip. This is where integration of off-chain and on-chain code really begins to shine âœ¨, having the Show instance defined for some of our on-chain types allows us to log them.\ntimeFromPlutus is as you'll expect - gives us the framework's representation of time from that of plutus. And enclosingSlotFromTime' uses ledger's information to determine the corresponding slot for the given time. We need this as cardano's node work in slots. We mention that our transaction is to be invalid after this slot using isInvalidAfter.\nWe mention that our transaction must have our public key hash as signatories when plutus smart contract asks for it using mustBeSignedBy.\nLastly, this transaction must generate an output to the script's address with the updated datum and added value.\nvalueToPlutus gives the corresponding value type used by plutus from what we have in our framework (viz., GYValue).\nAll these skeletons are combined together using mappend defined for GYTxSkeleton.\n    -- Need to append to previous.\n    Just previousBetsUtxoRef -> do\n      previousUtxo <- utxoAtTxOutRef' previousBetsUtxoRef\n      (_addr, previousValue, dat@(BetRefDatum previousGuesses _previousBet)) <- utxoDatum' previousUtxo\n      gyLogDebug' \"\" $ printf \"previous guesses %s\" (show previousGuesses)\n      betUntilSlot <- enclosingSlotFromTime' (timeFromPlutus $ brpBetUntil brp)\n      gyLogDebug' \"\" $ printf \"bet until slot %s\" (show betUntilSlot)\n      return $\n           input brp refScript previousBetsUtxoRef dat (Bet guess)\n        <> mustHaveOutput GYTxOut\n              { gyTxOutAddress = betAddr\n              , gyTxOutValue = bet <> previousValue\n              , gyTxOutDatum = Just (datumFromPlutusData $ BetRefDatum ((pubKeyHashToPlutus pkh, guess) : previousGuesses) (valueToPlutus bet), GYTxOutDontUseInlineDatum)\n              , gyTxOutRefS    = Nothing\n              }\n        <> isInvalidAfter betUntilSlot\n        <> mustBeSignedBy pkh","operation-4-taking-the-bet-pot#Operation 4: Taking the bet pot":"At this point, reading following code snippet should make sense as it is similar to what we have done before. Here note that we are using mustHaveRefInput to tell that the transaction must have the following UTxO reference as a reference input.\nObserve that we don't need to specify that the value we successfully consume from the script's UTxO must reach us because transaction balancer would add the change output to us.\n-- | Operation to take UTxO corresponding to previous bets.\ntakeBets :: (HasCallStack, GYTxMonad m)\n              => GYTxOutRef    -- ^ Reference Script.\n              -> BetRefParams  -- ^ Validator params.\n              -> GYTxOutRef    -- ^ Script UTxO to consume.\n              -> GYAddress     -- ^ Own address.\n              -> GYTxOutRef    -- ^ Oracle reference input.\n              -> m (GYTxSkeleton PlutusV2)\ntakeBets refScript brp previousBetsUtxoRef ownAddr oracleRefInput = do\n  pkh <- addressToPubKeyHash' ownAddr\n  previousUtxo <- utxoAtTxOutRef' previousBetsUtxoRef\n  (_addr, _previousValue, dat) <- utxoDatum' previousUtxo\n  betRevealSlot <- enclosingSlotFromTime' (timeFromPlutus $ brpBetReveal brp)\n  return $\n       input brp refScript previousBetsUtxoRef dat Take\n    <> isInvalidBefore betRevealSlot\n    <> mustHaveRefInput oracleRefInput\n    <> mustBeSignedBy pkh","additional-useful-functions#Additional Useful Functions":"","utxosdatums#utxosDatums":"Sometimes we want to see all valid UTxOs at our script address. In Cardano, anyone can form UTxO at any address and such a UTxO need not have valid datum as required by our script. utxosDatums can be used wither out invalid ones. See it's usage in Vesting example.","mustmint#mustMint":"We weren't minting any tokens in our example here and thus didn't make use of mustMint skeleton function. It's sample usage is given in this example. Which also illustrates how one can mint NFT and shows usage of someUTxO function which essentially gives some random UTxO belonging to wallet.This is related to singletons and one can read about it from the \"Dependent Types\" chapter (the last one) in Thinking with Types book.This however is not true for normal inputs where you can specify the datum as we'll see in other operations."}},"/getting-started/smart-contract-intro":{"title":"Smart Contract","data":{"":"Let's now start by writing a smart contract that we will use to convey framework's important features.\nThis contract is for illustrative purposes only. We do not recommend using it in a production environment.\nHere we'll be writing our smart contract in Haskell but do note that we are not limited to it. You for instance could write your smart contract in any language of your choice and read the compiled CBOR using scriptFromCBOR function defined here (Operations over Contract chapter explains about types such as GYScript, PlutusVersion which are used in this function). Similarly, there is readScript defined in the same file to read from the compiled text envelope file.","contract-description#Contract Description":"Setting here is that we have a sport match happening and a group of friends want to bet on the number of goals scored by their favorite team in it.Winner is the one whose guess is closest (and in case of tie - the one who takes it fastest!).The smart contract code is available here. This example was inspired by MLabs.","contract-parameters#Contract Parameters":"brpOraclePkh :: PubKeyHash: We'll be using a reference input, and its datum will give us the actual result (the number of goals). Since the reference input UTxO must belong to Oracle, we check it using Oracle's payment public key hash.\nbrpBetUntil :: POSIXTime: Time until which bets can be placed.\nbrpBetReveal :: POSIXTime: Time that the Oracle will reveal the match results.\nbrpBetStep :: Value: Minimum value that bets must increase by.\nThus, the parameters of our contract are given by:\n-- | Our contract is parameterized with this.\ndata BetRefParams = BetRefParams\n  { brpOraclePkh :: PubKeyHash  -- ^ Oracle's payment public key hash. This is needed to assert that UTxO being looked at indeed belongs to the Oracle.\n  , brpBetUntil  :: POSIXTime   -- ^ Time until which bets can be placed.\n  , brpBetReveal :: POSIXTime   -- ^ Time at which Oracle will reveal the correct match result.\n  , brpBetStep   :: Value       -- ^ Each newly placed bet must be more than previous bet by `brpBetStep` amount.\n  }\nPlutusTx.makeLift ''BetRefParams","reference-input-datum#Reference Input Datum":"The Oracle tells us the number of goals scored by the concerned team:\n-- | Goals made my the concerned team.\ntype TeamGoals = Integer\n-- | Match result given by the Oracle.\nnewtype OracleAnswerDatum = OracleAnswerDatum TeamGoals deriving newtype (Eq, Show)\nPlutusTx.unstableMakeIsData ''OracleAnswerDatum","contract-datum#Contract Datum":"It consists of two fields:\nList containing each person's guess along with their payment public key hash. Key hash is used to tie guess with the guesser. Every time a new guess is made, we prepend it to this list.\nThis key hash is obtained from transaction signatories - we insist on key hash being present in signatories as otherwise anyone may override bet of someone else.\nAmount denoting the previously placed bet. Note that the total value in the UTxO belonging to contract is the culmination of all the previously placed bets and thus it isn't in general equal to last placed bet. We use this to assert that the newly placed bet is more than the previous one by brpBetStep amount.\n-- | List of guesses by users along with the maximum bet placed yet. A new guess gets /prepended/ to this list. Note that since we are always meant to increment previously placed bet with `brpBetStep`, the newly placed bet would necessarily be maximum (it would be foolish to initialize `brpBetStep` with some negative amounts).\ndata BetRefDatum = BetRefDatum\n  { brdBets        :: [(PubKeyHash, OracleAnswerDatum)]\n  , brdPreviousBet :: Value\n  }\nPlutusTx.unstableMakeIsData ''BetRefDatum","contract-redeemer#Contract Redeemer":"There are two actions available to user:\nTo place a bet - in which case they give their guess.\nTo take the bets in the pot after the result is out.\nThis is therefore codified as:\n-- | Redeemer representing choices available to the user.\ndata BetRefAction = Bet !OracleAnswerDatum  -- ^ User makes a guess.\n                  | Take                    -- ^ User takes the pot.\nPlutusTx.unstableMakeIsData ''BetRefAction","contract-logic#Contract Logic":"","placing-a-bet#Placing a bet":"Initial bet gets placed as it is (in Cardano, validator script is executed only when spending an UTxO belonging to it but not for creating at it).For subsequent bets, we require three conditions:\nThe bet must be before (inclusive) the brpBetUntil time.\nThere must be exactly one continuing output at the script address whose datum shall have the current guess prepended to it along with the current bet amount.\nThe current bet must be more than the previous bet by at least brpBetStep amount.\nThis is coded as:\n{-# INLINABLE mkBetRefValidator' #-}\n-- | Core smart contract logic. Read its description from Atlas guide.\nmkBetRefValidator' :: BetRefParams -> BetRefDatum -> BetRefAction -> ScriptContext -> Bool\nmkBetRefValidator' (BetRefParams oraclePkh betUntil betReveal betStep) (BetRefDatum previousGuesses previousBet) brAction ctx =\n  case brAction of\n    Bet guess  ->\n      let\n        sOut = case getContinuingOutputs ctx of\n          [sOut']        -> sOut'\n          _anyOtherMatch -> traceError \"Expected only one continuing output.\"\n        outValue = txOutValue sOut\n        sIn = maybe (traceError \"Could not find own input\") txInInfoResolved (findOwnInput ctx)\n        inValue = txOutValue sIn\n        (guessesOut, betOut) = case outputToDatum sOut of\n          Nothing                                -> traceError \"Could not resolve for script output datum\"\n          Just (BetRefDatum guessesOut' betOut') -> (guessesOut', betOut')\n      in\n        traceIfFalse\n          \"Must be before `BetUntil` time\"\n            (to betUntil `contains` validRange) &&\n        traceIfFalse\n          \"Guesses update is wrong\"\n            ((signerPkh, guess) : previousGuesses == guessesOut) &&\n        traceIfFalse\n          \"The current bet must be more than the previous bet by atleast `brpBetStep` amount\"\n            (outValue `geq` (inValue <> previousBet <> betStep)) &&\n        traceIfFalse\n          \"Out bet is wrong\"\n            (betOut == outValue - inValue)\nWhere we have the following common helpers for both the redemeer actions:\n  where\n    info :: TxInfo\n    info = scriptContextTxInfo ctx\n    validRange :: POSIXTimeRange\n    validRange = txInfoValidRange info\n    signerPkh :: PubKeyHash\n    signerPkh = case txInfoSignatories info of\n      [signerPkh']   -> signerPkh'\n      []             -> traceError \"No signatory\"\n      _anyOtherMatch -> traceError \"Expected only one signatory\"\n    outputToDatum :: FromData b => TxOut -> Maybe b\n    outputToDatum o = case txOutDatum o of\n      NoOutputDatum      -> Nothing\n      OutputDatum d      -> processDatum d\n      OutputDatumHash dh -> processDatum =<< findDatum dh info\n      where processDatum = fromBuiltinData . getDatum","taking-the-bet-pot#Taking the bet pot":"In this case we require the following four conditions:\nThis operation must occur after (inclusive) brpBetReveal time.\nThe script must get fully spend, i.e., there shouldn't be any continuing outputs to this script address.\nThe reference input whose datum is used to see actual answer should belong to concerned Oracle.\nGuess should be closest among all.\nThis is therefore coded as:\n    Take ->\n      let\n        Just guess = find ((== signerPkh) . fst) previousGuesses  -- Note that `find` returns the first match. Since we were always prepending, this is valid.\n        oracleIn = case filter (isNothing . txOutReferenceScript) (txInInfoResolved <$> txInfoReferenceInputs info) of\n          [oracleIn']    -> oracleIn'\n          []             -> traceError \"No reference input provided\"\n          _anyOtherMatch -> traceError \"Expected only one reference input\"\n        oracleAnswer = case outputToDatum oracleIn of\n          Nothing                                  -> traceError \"Could not resolve for datum\"\n          (Just (OracleAnswerDatum oracleAnswer')) -> oracleAnswer'\n        guessDiff = getGuessDiff $ snd guess\n        getGuessDiff (OracleAnswerDatum g) = abs (oracleAnswer - g)\n        oracleInPkh = case toPubKeyHash (txOutAddress oracleIn) of\n          Nothing  -> traceError \"Not PKH for oracle address\"\n          Just pkh -> pkh\n      in\n        traceIfFalse\n          \"Must be after `RevealTime`\"\n            (from betReveal `contains` validRange) &&\n        traceIfFalse\n          \"Must fully spend Script\"\n            (null (getContinuingOutputs ctx)) &&\n        traceIfFalse\n          \"Reference input must be from Oracle address (wrt Payment part)\"\n            (oracleInPkh == oraclePkh) &&\n        traceIfFalse\n          \"Guess is not closest\"\n            (all (\\pg -> getGuessDiff (snd pg) >= guessDiff) previousGuesses)\nAnd lo behold! This is our contract.For instance, here we assert that UTxO being used as reference input must belong to Oracle's address but do note that anyone can create an UTxO at Oracle's address."}},"/":{"title":"Index","data":{}},"/getting-started/unit-tests":{"title":"Unit Tests","data":{"":"Writing smart contracts & writing tests go hand in hand. Tests are also an excellent way to conveniently check working of our smart contract instead of using cardano-cli and local node.Now that we have written our smart contract and defined the required operations over it, let's see whether its working as expected.Our test suite is a wrapper around Plutus simple model which is created by MLabs.","why-not-just-use-plutus-simple-model-instead-of-the-wrapper#Why not just use \"Plutus simple model\" instead of the wrapper?":"Reusability: Well firstly to maintain compatibility with our toolchain. For instance, our operations were making use of GYTxQueryMonad monad and thus to be able to reuse those same operations we would need to define an instance for it.\nAdditional checks: But secondly and more importantly, plutus simple model lacks some basic checks, for instance:\nWhether a UTxO satisfies minimum ada requirement.\nTransaction fees requirement.\nTransaction signatures requirement, etc.\nWe already handle these cases using our transaction building machinery and thus tests written here reflect the actual environment more.\nFor this guide there should be no need to go over the plutus simple model documentation but this doesn't mean that one shouldn't. It's very lucid and takes few minutes to cover and can be accessed by cloning their repository, entering the docs folder and running mdbook serve --open.","unit-tests-for-placing-a-bet-operation#Unit tests for placing a bet operation":"Entire code file for tests pertaining to this operation is available here. Note that we are using tasty to write our tests and a file calling these individual unit tests is here.\nOur objective here would be to write tests for each of our operation, hence the name \"unit tests\". Though one may write other sort of tests as well, including property based ones.","defining-run-for-placing-a-bet-operation#Defining Run for placing a bet operation":"Before any jibber-jabber, let's see the code so that we know it isn't as complex as it might seem:\nplaceBetRun :: GYTxOutRef -> BetRefParams -> OracleAnswerDatum -> GYValue -> Maybe GYTxOutRef -> GYTxMonadRun GYTxId\nplaceBetRun refScript brp guess bet mPreviousBetsUtxoRef = do\n  addr <- ownAddress\n  skeleton <- placeBet refScript brp guess bet addr mPreviousBetsUtxoRef\n  sendSkeleton skeleton\nWhy do we call it \"run\"? Well if you have gone over the documentation of plutus simple model, you'll know that they have this \"Run\" monad where actually most of the test code gets executed and we have wrapper around this type, which we call GYTxMonadRun (defined in Run.hs). But as an end developer, there is no need to understand about it.Also our GYTxMonadRun has an instance of GYTxQueryMonad.\nThe idea here is that any tests we do related to performing the bet operation would need to call the placeBet function which we have defined before. Therefore we have defined a run to call this function. Our placeBetRun function takes all those parameters which are required by placeBet function, except the address as that we are able to get using ownAddress function. ownAddress function is defined in file Run.hs where actually most of the code related to our wrapper lives and it gives the address of the wallet running this run as we'll shortly see.Lastly sendSkeleton can be understood as submitting the transaction. It will update the mock ledger state and return the transaction id for the submitted transaction. Note that it does raise an exception in case it fails to submit the transaction.","understanding-testrun#Understanding testRun":"Before we see a trace calling the run we just defined, notice that in our testGroup, we have the first test written as:\ntestRun \"Balance checks after placing first bet\" $ firstBetTrace (OracleAnswerDatum 3) (valueFromLovelace 20_000_000) 0_182_793\nNow what is this testRun?This function (defined in Utils.hs) takes a string to represent the name of the test and a continuation function (of type Wallets -> Run a) and then internally generates wallets to give to our continuation function.The type Wallets is defined as:\ndata Wallets = Wallets\n    { w1 :: !Wallet\n    , w2 :: !Wallet\n    , w3 :: !Wallet\n    , w4 :: !Wallet\n    , w5 :: !Wallet\n    , w6 :: !Wallet\n    , w7 :: !Wallet\n    , w8 :: !Wallet\n    , w9 :: !Wallet\n    } deriving (Show, Eq, Ord)\nwhere Wallet is:\ndata Wallet = Wallet\n    { walletPaymentSigningKey :: !GYPaymentSigningKey\n    , walletNetworkId         :: !GYNetworkId\n    , walletName              :: !String\n    }\n    deriving (Show, Eq, Ord)\nThus our testRun function, generates these 9 wallets where each wallet is having the following three assets:\nMillion ada.\nMillion fakeGold.\nMillion fakeIron.\nwhere fakeGold and fakeIron are our two non-native assets.Each call to testRun (as you can see - we have multiple tests, all beginning with testRun) runs the given test with a fresh (new) blockchain ledger state having given the above balances to those 9 wallets.In our case, \"Balance checks after placing first bet\" is the name of the test and firstBetTrace (OracleAnswerDatum 3) (valueFromLovelace 20_000_000) 0_182_793 is our continuation function.","defining-a-trace-to-call-placebetrun#Defining a trace to call placeBetRun":"Now let's see the definition firstBetTrace we briefly encountered above:\n-- | Trace for placing the first bet.\nfirstBetTrace :: OracleAnswerDatum  -- ^ Guess\n              -> GYValue            -- ^ Bet\n              -> Integer            -- ^ Expected fees\n              -> Wallets -> Run ()  -- Our continuation function\nfirstBetTrace dat bet expectedFees ws@Wallets{..} = do\n  -- First step: Get the required parameters for initializing our parameterized script and add the corresponding reference script\n  (brp, refScript) <- computeParamsAndAddRefScript 40 100 (valueFromLovelace 200_000_000) ws\n  void $ runWallet w1 $ do  -- following operations are ran by first wallet, `w1`\n  -- Second step: Perform the actual run.\n    withWalletBalancesCheck [w1 := valueNegate (valueFromLovelace expectedFees <> bet)] $ do\n      placeBetRun refScript brp dat bet Nothing\nHere the last argument is of type Wallets as we noted.Note that this function starts by calling computeParamsAndAddRefScript, therefore let's see about it:\n-- | Function to compute the parameters for the contract and add the corresponding refernce script.\ncomputeParamsAndAddRefScript\n  :: Integer                                    -- ^ Bet Until slot\n  -> Integer                                    -- ^ Bet Reveal slot\n  -> GYValue                                    -- ^ Bet step value\n  -> Wallets -> Run (BetRefParams, GYTxOutRef)  -- Our continuation\ncomputeParamsAndAddRefScript betUntil' betReveal' betStep Wallets{..} = do\n  let betUntil = slotFromApi (fromInteger betUntil')\n      betReveal = slotFromApi (fromInteger betReveal')\n  fmap fromJust $ runWallet w1 $ do\n    betUntilTime <- slotToBeginTime betUntil\n    betRevealTime <- slotToBeginTime betReveal\n    let brp = BetRefParams (pubKeyHashToPlutus $ walletPubKeyHash w8) (timeToPlutus betUntilTime) (timeToPlutus betRevealTime) (valueToPlutus betStep)  -- let oracle be wallet `w8`.\n    mORef <- addRefScript (walletAddress w9) (betRefValidator' brp)\n    case mORef of\n      Nothing        -> fail \"Couldn't find index of the Reference Script in outputs\"\n      Just refScript -> return (brp, refScript)\nOur first step is to construct the parameter (BetRefParams) for our parameterized contract. Recall its type is:\ndata BetRefParams = BetRefParams\n  {\n    brpOraclePkh :: PubKeyHash  -- ^ Oracle's payment public key hash. This is needed to assert that UTxO being looked at indeed belongs to the Oracle.\n  , brpBetUntil  :: POSIXTime   -- ^ Time until which bets can be placed.\n  , brpBetReveal :: POSIXTime   -- ^ Time at which Oracle will reveal the correct match result.\n  , brpBetStep   :: Value       -- ^ Each newly placed bet must be more than previous bet by `brpBetStep` amount.\n  }\nFor brpBetUntil, we choose slot 40 but since plutus works in posix time, we need to enter a monad having an instance of GYTxQueryMonad to get posix time from slot and therefore that calculation happens inside runWallet w1. Similarly for brpBetReveal we chose slot 100.\nrunWallet is a utility function (defined again in Utils.hs) which enables us to give the environment. Hm.. what environment you ask? Well in general when constructing the transaction from skeleton we need some context, like who is actually submitting this transaction? As we'll need their address to give them the change output. runWallet takes as first argument, the wallet to generate context from and then the actual run to run against this context.\nNow coming back to our parameters, for brpOraclePkh parameter, we chose that for wallet 8. And we take our step amount to be 200 ada.Though it is not required for this operation (where we place the first bet) but since our placeBet function is overloaded to accept the subsequent bet case too - we need to give reference to the UTxO containing reference script. For that we have a helper function defined in Utils.hs called addRefScript which adds the given script at a given address (we chose that for wallet 9) and returns the reference to it (in Maybe).Now we are almost done to call our run with just one more line to understand.withWalletBalancesCheck takes a list of tuple where the first element of the tuple is the wallet and second element denotes the difference in the wallet's value which we expect after the execution of the operation defined inside its do block. Here we want the balance of wallet 1 (which is the one actually calling this operation) to decrease by the bet amount and also the fees.\nHow do we know the fees?\nWell by running the test without it and then noting the transaction fees from the log messages.\nAnd this covers our first test ðŸ¥³.","multiple-bets-trace#Multiple bets trace":"Now let's write a slightly more involved trace. This time we'll make our trace parameteric over the required contract parameters.Here is the signature of our trace:\n-- | Trace which allows for multiple bets.\nmultipleBetsTraceWrapper\n  :: Integer                                            -- ^ slot for betUntil\n  -> Integer                                            -- ^ slot for betReveal\n  -> GYValue                                            -- ^ bet step\n  -> [(Wallets -> Wallet, OracleAnswerDatum, GYValue)]  -- ^ List denoting the bets\n  -> Wallets -> Run ()                                  -- Our continuation function\nmultipleBetsTraceWrapper betUntil' betReveal' betStep walletBets ws = do\n  -- First step: Get the required parameters for initializing our parameterized script and add the corresponding reference script\n  (brp, refScript) <- computeParamsAndAddRefScript betUntil' betReveal' betStep ws\n  -- Second step: Perform the actual bet operations\n  multipleBetsTraceCore brp refScript walletBets ws\nThe first three parameters correspond to the parameters of contract.The fourth parameter denotes the different bets.We may for instance call this function like so:\ntestRun \"Balance checks with multiple bets\" $ multipleBetsTraceWrapper 400 1000 (valueFromLovelace 10_000_000) \n  [ (w1, OracleAnswerDatum 1, valueFromLovelace 10_000_000)\n  , (w2, OracleAnswerDatum 2, valueFromLovelace 20_000_000)\n  , (w3, OracleAnswerDatum 3, valueFromLovelace 30_000_000)\n  , (w2, OracleAnswerDatum 4, valueFromLovelace 50_000_000)\n  , (w4, OracleAnswerDatum 5, valueFromLovelace 65_000_000 <> fakeGold 1000)\n  ]\nNext we want to add our reference script and compute the actual contract parameters (converting slot to posix) - which is again handled like before.We would then like to perform the actual bet operations. But this time we won't concern ourselves much with actual fees but rather take a threshold of 1 ada. Our approach here is to compare the balances before performaing any operation and after performing all the operations and then see that each wallet has lost the bet amount they placed considering threshold fees.Note: We use balance function to get the balance for the given wallet.\n-- | Trace which allows for multiple bets.\nmultipleBetsTraceCore\n  :: BetRefParams\n  -> GYTxOutRef                                         -- ^ Reference script\n  -> [(Wallets -> Wallet, OracleAnswerDatum, GYValue)]  -- ^ List denoting the bets\n  -> Wallets -> Run ()                                  -- Our continuation function\nmultipleBetsTraceCore brp refScript walletBets ws@Wallets{..} = do\n  let\n      -- | Perform the actual bet operation by the corresponding wallet.\n      performBetOperations [] _ = return ()\n      performBetOperations ((getWallet, dat, bet) : remWalletBets) isFirst = do\n        if isFirst then do\n          void $ runWallet (getWallet ws) $ do\n            void $ placeBetRun refScript brp dat bet Nothing\n          performBetOperations remWalletBets False\n        else do\n          -- need to get previous bet utxo\n          void $ runWallet (getWallet ws) $ do\n            betRefAddr <- betRefAddress brp\n            [_scriptUtxo@GYUTxO {utxoRef}] <- utxosToList <$> utxosAtAddress betRefAddr\n            void $ placeBetRun refScript brp dat bet (Just utxoRef)\n          performBetOperations remWalletBets False\n      -- | To sum the bet amount for the corresponding wallet.\n      sumWalletBets _wallet [] acc = acc\n      sumWalletBets wallet ((getWallet, _dat, bet) : remWalletBets) acc = sumWalletBets wallet remWalletBets (if getWallet ws == wallet then acc <> valueNegate bet else acc)\n      -- | Idea here is that for each wallet, we want to know how much has been bet. If we encounter a new wallet, i.e., wallet for whose we haven't yet computed value lost, we call `sumWalletBets` on it.\n      getBalanceDiff [] _set acc = acc\n      getBalanceDiff wlBets@((getWallet, _dat, _bet) : remWalletBets) set acc =\n        let wallet = getWallet ws\n            wallet'sName = walletName wallet\n        in\n          if Set.member wallet'sName set then getBalanceDiff remWalletBets set acc\n          else\n           getBalanceDiff remWalletBets (Set.insert wallet'sName set) ((wallet := sumWalletBets wallet wlBets mempty) : acc)\n      balanceDiffWithoutFees = getBalanceDiff walletBets Set.empty []\n  balanceBeforeAllTheseOps <- fmap fromJust $ runWallet w1 $ traverse (\\(wallet, _value) -> balance wallet) balanceDiffWithoutFees\n  performBetOperations walletBets True\n  balanceAfterAllTheseOps <- fmap fromJust $ runWallet w1 $ traverse (\\(wallet, _value) -> balance wallet) balanceDiffWithoutFees\n  void $ runWallet w1 $ verify (zip3 balanceDiffWithoutFees balanceBeforeAllTheseOps balanceAfterAllTheseOps)\n  where\n    -- | Function to verify that the wallet indeed lost by /roughly/ the bet amount. We say /roughly/ as fees is assumed to be within (0, 1 ada].\n    verify [] = return ()\n    verify (((wallet, diff), vBefore, vAfter) : xs) =\n      let vAfterWithoutFees = vBefore <> diff\n          (expectedAdaWithoutFees, expectedOtherAssets) = valueSplitAda vAfterWithoutFees\n          (actualAda, actualOtherAssets) = valueSplitAda vAfter\n          -- threshold = valueFromLovelace 1_000_000  -- 1 ada\n          threshold = 1_000_000  -- 1 ada\n      in if expectedOtherAssets == actualOtherAssets && actualAda < expectedAdaWithoutFees && expectedAdaWithoutFees - threshold <= actualAda then verify xs\n             -- valueGreater vAfterWithoutFees vAfter && valueGreaterOrEqual vAfter (valueMinus vAfterWithoutFees threshold) then verify xs\n         else fail (\"For wallet \" <> walletName wallet <> \" expected value (without fees) \" <> show vAfterWithoutFees <> \" but actual is \" <> show vAfter)\nAn eagle eye might notice two comments inside the verify function.Firstly, note that valueSplitAda splits our GYValue into lovelaces and that which remains besides it. Since fees don't affect non-ada tokens (not yet), we compare with respect to threshold using ada tokens.We could also compare GYValue's directly using valueGreater (there is also valueGreaterOrEqual) as done in comments but the current one is slightly more optimal as we need not compare on non-ada tokens again.","but-sometimes-we-want-a-test-to-fail#But sometimes we want a test to fail!":"What happens if the newly placed bet is not more than atleast brpBetStep amount? What happens if the transaction skeleton was somewhat wrong, say we didn't put mustBeSignedBy? What if someone tries to place a bet after brpBetUntil? What if...Well for all such cases, we can assert that a given trace must fail using mustFail like:\ntestRun \"Not adding atleast bet step amount should fail\" $ mustFail . multipleBetsTrace 400 1000 (valueFromLovelace 10_000_000) \n  [ (w1, OracleAnswerDatum 1, valueFromLovelace 10_000_000)\n  , (w2, OracleAnswerDatum 2, valueFromLovelace 20_000_000)\n  , (w3, OracleAnswerDatum 3, valueFromLovelace 30_000_000)\n  , (w2, OracleAnswerDatum 4, valueFromLovelace 50_000_000)\n  , (w4, OracleAnswerDatum 5, valueFromLovelace 55_000_000 <> fakeGold 1000)]\nHere wallet w4 didn't increase the bet by 10 ada and thus must fail.\nSometimes we want to assert specific failure among other possible failures. As mustFail above doesn't distinguish among them, one can simply use catchError like in this test.","unit-tests-for-taking-the-bet-pot#Unit tests for taking the bet pot":"Entire code file for tests pertaining to this operation is available here.\nOn similar lines as before, let's first define our run for takeBets operation:\n-- | Run to call the `takeBets` operation.\ntakeBetsRun :: GYTxOutRef -> BetRefParams -> GYTxOutRef -> GYTxOutRef -> GYTxMonadRun GYTxId\ntakeBetsRun refScript brp toConsume refInput = do\n  addr <- ownAddress\n  skeleton <- takeBets refScript brp toConsume addr refInput\n  sendSkeleton skeleton\nNext, we'll define our trace to call this run:\n-- | Trace for taking bet pot.\ntakeBetsTrace :: Integer                                            -- ^ slot for betUntil\n              -> Integer                                            -- ^ slot for betReveal\n              -> GYValue                                            -- ^ bet step\n              -> [(Wallets -> Wallet, OracleAnswerDatum, GYValue)]  -- ^ List denoting the bets\n              -> Integer                                            -- ^ Actual answer\n              -> (Wallets -> Wallet)                                -- ^ Taker\n              -> Maybe Integer                                      -- ^ Expected fees\n              -> Wallets -> Run ()  -- Our continuation function\ntakeBetsTrace betUntil' betReveal' betStep walletBets answer getTaker mExpectedFees ws@Wallets{..} = do\n  (brp, refScript) <- computeParamsAndAddRefScript betUntil' betReveal' betStep ws\n  multipleBetsTraceCore brp refScript walletBets ws\n  -- Now lets take the bet\n  mMRef <- runWallet w1 $ addRefInput True (walletAddress w8) (datumFromPlutusData $ OracleAnswerDatum answer)\n  let taker = getTaker ws\n  case mMRef of\n    Just (Just refInput) -> do\n      void $ runWallet taker $ do\n        betRefAddr <- betRefAddress brp\n        [_scriptUtxo@GYUTxO {utxoRef, utxoValue}] <- utxosToList <$> utxosAtAddress betRefAddr\n        waitUntilSlot $ slotFromApi (fromInteger betReveal')\n        case mExpectedFees of\n          Just expectedFees ->\n            withWalletBalancesCheck [taker := utxoValue <> valueNegate (valueFromLovelace expectedFees)] $ do\n              takeBetsRun refScript brp utxoRef refInput\n          Nothing -> takeBetsRun refScript brp utxoRef refInput\n    _anyOtherMatch -> fail \"Couldn't place reference input successfully\"\nHere we first did the common step of computing the required script parameters and adding the reference script.Then we used addRefInput defined in Utils.hs whose purpose here would become clear by seeing its haddock documentation below:\n-- | Adds an input (whose datum we'll refer later) and returns the reference to it.\naddRefInput:: Bool       -- ^ Whether to inline this datum?\n           -> GYAddress  -- ^ Where to place this output?\n           -> GYDatum    -- ^ Our datum.\n           -> GYTxMonadRun (Maybe GYTxOutRef)\nNext we simply wait until time for bet revealation and claim our pot!Now that we have our trace for taking bet pot, we can try testing for other conditions - examples for some are written in the TakeBetPot.hs file.We use a custom fork of Plutus simple model.To convey the message better, we have a pattern synonym defined in Utils.hs file:\npattern (:=) :: x -> y -> (x, y)\npattern (:=) x y = (x, y)\nSince we require the signature being present in the skeleton, we can't place bet on anyone else's behalf anyways."}},"/introduction":{"title":"Introduction","data":{"":"Atlas is an all-in-one, Haskell-native application backend for writing off-chain code for on-chain Plutus smart contracts. Atlas has been designed by Genius Yield, in collaboration with MLabs, Well-Typed and Plank.","features#Features":"","easily-build-transactions#Easily build transactions":"Use an intuitive API to abstract away the complexity around building transactions, balancing UTxOs, and interfacing with Plutus smart contracts.","leverage-first-class-haskell#Leverage first-class Haskell":"Avoid code duplication between on-chain and off-chain code, interoperate with advanced functionalities offered by IOG's Cardano/Plutus libraries, and easily convert between Atlas and Cardano/Plutus types.","utilize-modular-data-providers#Utilize modular data providers":"Query ledger state information from remote provider such as Maestro or from your own node with the help of Kupo. You can also build and contribute your own data provider!","test-extensively#Test extensively":"Use Atlas' test harness to write realistic unit tests that correspond to on-chain behavior, and execute integration tests against cardano node in a private network.","stay-up-to-date#Stay up to date":"Benefit from Cardano's latest innovations such as Reference Inputs, Inline Datums and Reference Scripts. Conway we are looking at you ðŸ‘€.","where-to-next#Where to next?":"Work through an end-to-end example here: Getting Started.\nThis guide tracks the latest commit of Atlas. We bring changes into Atlas, only when corresponding updates have been made into the documentation as well."}},"/more-tutorials":{"title":"More Tutorials","data":{"vesting#Vesting":"See the introductory walkthrough of Atlas given by Dr. Lars using his with favourite example, Vesting, here. Associated code is available at atlas-examples repository."}}}