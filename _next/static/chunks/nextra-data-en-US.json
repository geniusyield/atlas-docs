{"/additional-features/blueprint":{"title":"Blueprint","data":{"":"Plutus Contract Blueprint, as introduced by CIP-57 is an effective way of communicating desired structure of validator's associated types such as datum and redeemer to your off-chain code.With Atlas, you can easily have these types generated for you based on provided schema, along with useful helper utilities!\nIf your validator is parameterised, parameters must be \"data\" encoded (instead of scott or sums-of-products encoding) as blueprint notation requires it (data) to be primary binary interface. This is not an issue for datums & redeemers as they are required to be data encoded anyway.Validators written by tools such as Aiken use data encoding for validator parameters.\nHere we have a parameterised Aiken validator. Mainly, it checks that sum of integers and length of bytestrings given in parameters, datum & redeemer sum up to a specific value.For this validator, we have a simple off-chain code here, have a look at it and we provide some description for it below.We first use Template Haskell to splice declarations from makeBPTypes and uponBPTypes. makeBPTypes introduces types from definitions given in blueprint file and uponBPTypes creates data related instances such as ToData, FromData for these types.It is useful to see generated Template Haskell code to know for type and provided utility names which can be done via -ddump-splices GHC flag. You may combine this with -ddump-to-file to save the output to a file. If you are using cabal, see this answer on where one can find dumped splice files.Now we can apply parameters (whose types have been generated by Atlas) to our validator with provided applyParamsToBPValidator_baz_baz_spend function and obtain GYScript from it using scriptFromBPSerialisedScript function. Likewise we have types generated for our datum & redeemer, sweet!Rest of the off-chain code just tries to interact with the validator by creating a UTxO towards it and then later consuming from it.\nTo interact with blueprint file, you'll usually just need to import GeniusYield.Types.Blueprint.TH module (which is exposed by GeniusYield.Types module), however if you want to inspect the parsed blueprint file, you can use readBlueprint.\nSee CIP-85 to understand about different encodings used.We could achieve both in single splice, however, since we are using utilities from PlutusTx to derive ToData etc. instances, they require type to be in scope first."}},"/additional-features/certificates":{"title":"Certificates","data":{"":"Atlas has rich support of all possible certificates. GeniusYield.Types.TxCert module provide constructors to build them along with useful instructions describing conditions for certificate to be considered valid. Following tests illustrate how one can construct & work with these certificates:\nCertificates related to registering, updating & unregistering a delegated representative (DRep): GeniusYield.Test.Privnet.DRep.\nCertificates pertaining to stake address registration, delegation & deregistration (this also illustrates usage of stake validator): GeniusYield.Test.Privnet.Stake.\nThose related to stake pool registration & retirement: GeniusYield.Test.Privnet.StakePool.\nCommittee related certificates: GeniusYield.Test.Privnet.Committee."}},"/additional-features/governance":{"title":"Governance procedures","data":{"":"Atlas has support for facilitating proposal & voting procedures. Test GeniusYield.Test.Privnet.Gov illustrates how to make a proposal and then how to vote on it. Governance related types are defined in GeniusYield.Types.Governance module."}},"/additional-features/monad-io":{"title":"Provide MonadIO instances of query/builder monadic interpreters","data":{"":"Out of the box, we don't provide MonadIO instances for these interpreters as we don't want to allow arbitrary IO action within them. But it can be easily defined like so:\nimport GeniusYield.TxBuilder.IO.Unsafe (unsafeIOToQueryMonad, unsafeIOToTxBuilderMonad)\ninstance MonadIO GYTxQueryMonadIO where\n    liftIO = unsafeIOToQueryMonad\ninstance MonadIO GYTxBuilderMonadIO where\n    liftIO = unsafeIOToTxBuilderMonad"}},"/additional-features/simple-scripts":{"title":"Simple Scripts","data":{"":"Atlas supports simple scripts, also known as native and timelock scripts. The functionality of simple scripts is explained in the ledger design document of Shelley & Mary era here and also in cardano-node-wiki.Simple scripts can be specified via exposed constructors of GYSimpleScript. They can also be read from their JSON representation as GYSimpleScript has a FromJSON instance. We also provide a utility function, readSimpleScript, to read JSON representation from a file.Simple scripts can also be attached to UTxO outputs, allowing them to be used later as reference scripts when building transactions. You can find an example here, that demonstrates how to interact with simple scripts, both when used as a reference and when given directly for transaction validation."}},"/getting-started":{"title":"Getting Started","data":{"":"Learn the most important framework concepts in just few minutes by coding a complete end-to-end example."}},"/getting-started/browser-integration":{"title":"Browser Integration","data":{"":"Now that we have our server running, we need front-end UI to interact with it.For all of the operations, the approach (as previously mentioned) is same which is to first get the unsigned transaction from server, use browser wallet's signTx method to get spending key witness for this transaction, and then use server's endpoint to add witness to this transaction & submit it.\nThe entire code pertaining to browser operations is available here.\nAn outline of this whole process is given below, illustrated via add-ref-script endpoint:\n// Obtain access to browser wallet api\nconst api: WalletApi = await window.cardano[selectedWallet].enable(); // Creating a type such as `WalletApi` was entirely optional.\n// Obtaining UTxOs to be used collaterals as given by browser wallet.\nconst colls = await api.experimental.getCollateral();\n// Create request body for calling our endpoint\nconst body = {\n  arsUsedAddrs: await api.getUsedAddresses(),\n  arsChangeAddr: await api.getChangeAddress(),\n  ...(0 in colls && { arsCollateral: colls[0] }),\n  arsPutAddress: convertAddrToRaw(values.putAddress), // implementation detail\n  arsBetParams: processBrpParams(brpParams), // implementation detail\n};\nconsole.log(body);\n// Call endpoint\nconst { data } = await axios.post(\"http://localhost:8081/betref/add-ref-script\", body);\nconsole.log(data);\n// Sign & submit\nconst { data: submitData } = await axios.post(\n  \"http://localhost:8081/tx/add-wit-and-submit\",\n  {\n    awasTxUnsigned: data.urspTxBodyHex,\n    awasTxWit: await api.signTx(data.urspTxBodyHex, true), // Note that this second argument (corresponding to \"partial signing\") needs to be `true` as for inputs such as those belonging to script already have their witness and we need to give witness only for inputs belonging to us.\n  },\n  {\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  }\n);\nWhat follows is the demo for all of the operations we defined.\nDue to security reasons, you would need to run this page locally (instructions here) to check out the following demo.\nAnd with this, we come to an end of our Getting Started guide ðŸ¥³! Hope you enjoyed it ðŸ’™\nHave questions? Ask them at Cardano StackExchange."}},"/getting-started/endpoints":{"title":"Creating Endpoints","data":{"":"Now that we are confident with our smart contract, it's time that we make it accessible to end user.The approach here would be\nFront-end asks to construct transaction for the concerned operation.\nIt then receives this transaction, which is complete besides missing for signature for spending inputs belonging to browser wallet. It calls wallet api's signTx method upon this body to get this signature (key witness).\nFrontend now passes this unsigned transaction along with the witness it received to our backend endpoint which will add this witness to the transaction, making it complete and would then submit it.\nWe'll use Servant to create our endpoints and one may understand it by following their easy to understand tutorial here.\nDo note that we can also sign the transactions in server using the signGYTxBody function defined in GeniusYield.Types.TxBody module.","providing-data-provider#Providing Data Provider":"","defining-provider-configuration#Defining Provider Configuration":"As noted earlier, building transaction bodies require gathering suitable information from the blockchain. For this purpose, we'll require a provider. Atlas is unopinionated and allows user to plug in provider of their choice, including a locally hosted one.Currently Atlas supports the following providers (& it would be highly appreciated if community enriches this by contributing to Atlas):\nMaestro.\nLocally ran node along with Kupo. We have tested with version 10.1.3 of cardano-node and 2.10.0 of Kupo.\nNote that node connection is supported both via network socket and Ogmios URL.\nBlockfrost.\nFollowing API functions don't have an optimal implementation for Blockfrost:\nutxosAtTxOutRefs\nutxosAtTxOutRefsWithDatums\nutxosAtAddressWithDatums\nutxosAtAddresses\nutxosAtAddressesWithDatums\nutxosAtPaymentCredentialWithDatums\nutxosAtPaymentCredentials\nutxosAtPaymentCredentialsWithDatums\nIn general, we recommend either Maestro or local node with Kupo as provider.\nTo provide information about the provider, we will create a config.json file whose contents could be as follows:\nWe have given a sample config.json file here.\n{\n  \"coreProvider\": ...,\n  \"networkId\": \"preprod\",\n  \"logging\": [{ \"type\": { \"tag\": \"stderr\" }, \"severity\": \"Debug\", \"verbosity\": \"V2\" }],\n  \"logTiming\": false\n}\nwhere coreProvider field can have one of following possible values:\n\"coreProvider\": { \"maestroToken\": \"<Your-API-Key>\", \"turboSubmit\": false },\n\"coreProvider\": { \n  \"socketPath\": \"path-to-node-socket\",\n  \"kupoUrl\": \"http://localhost:1442\",\n  \"localTxSubmissionCache\": {\n    \"cacheInterval\": 1\n  },\n  \"mempoolCache\": {\n    \"cacheInterval\": 1\n  }\n},\n\"coreProvider\": {\n  \"ogmiosUrl\": \"http://localhost:1337\",\n  \"kupoUrl\": \"http://localhost:1442\"\n  \"localTxSubmissionCache\": {\n    \"cacheInterval\": 1\n  },\n  \"mempoolCache\": {\n    \"cacheInterval\": 1\n  }\n},\n\"coreProvider\": { \"blockfrostKey\": \"<Your-API-Key>\" },\nHere is the explanation for each of the JSON keys above:\ncoreProvider: This field is the differentiating factor between different providers.\nFor Maestro, maestroToken holds the api key and turboSubmit field dictates whether the transactions are to be submitted via their turbo submit endpoint.\nFor Local Node with Kupo provider, socketPath is the path towards node socket (usually named node.socket) file, kupoUrl is the url where endpoints are made available by Kupo, it is usually http://localhost:1442.\nmempoolCache denotes if one would like to use mempool to know for already spent inputs and to be made available outputs when utilising UTxO query functions such as utxosAtAddresses. cacheInterval here denotes how long (in seconds) will the mempool information would be cached as we would not want to query mempool frequently.\nSimilarly localTxSubmissionCache denotes if one would like to consider locally submitted transactions to know for already spend inputs and to be made available outputs when utilising UTxO query functions. cacheInterval here denotes how long (in seconds) would one like to consider previously submitted transactions. We wouldn't want to carry huge amount of data in memory, so it's better to forget about old submitted transactions as their information would already be reflected in the tip.\nFor Ogmios with Kupo provider, ogmiosUrl is the URL of Ogmios host and rest of the fields are same as in \"Local node with Kupo provider\".\nFor Blockfrost, blockfrostKey holds the required api key.\nnetworkId: Specifies your network and must be one of mainnet, preprod, preview, testnet (for legacy testnet) & privnet (for local private network).\nlogging: It's a list of scribes to register. Its parameters (like severity, verbosity) and its general usage can be understood by going over their official haddock documentation here. Katip is also explained in this book on web development in Haskell. Please have a look at haddock for FromJSON and ToJSON instances of GYLogScriptType to see sample usage.\nlogTiming: (Optional) If set to true, operations involving provider are timed and corresponding durations are logged.","parsing-given-configuration#Parsing Given Configuration":"The file server-main.hs fires up our server. It reads & parses the configuration file and using it makes our endpoints (which we will define shortly) available. Here is its entire code.\n-- | Getting path for our core configuration.\nparseArgs :: IO FilePath\nparseArgs = do\n  args <- getArgs\n  case args of\n    coreCfg: _ -> return coreCfg\n    _invalidArgument -> fail \"Error: wrong arguments, needed a path to the CoreConfig JSON configuration file\\n\"\nmain :: IO ()\nmain = do\n  putStrLn \"Writing Swagger file ...\"\n  BL8.writeFile \"swagger-api.json\" (encodePretty apiSwagger)\n  putStrLn \"parsing Config ...\"\n  coreCfgPath <- parseArgs\n  coreCfg <- coreConfigIO coreCfgPath  -- Parsing our core configuration.\n  putStrLn \"Loading Providers ...\"\n  withCfgProviders coreCfg \"api-server\"  $ \\providers -> do\n    let port = 8081\n        ctx = Ctx coreCfg providers\n    putStrLn $ \"Starting server at \\n \" <> \"http://localhost:\" <> show port\n    run port $ app ctx\napp :: Ctx -> Application\napp ctx = cors (const $ Just simpleCorsResourcePolicy { corsRequestHeaders = [HttpTypes.hContentType] }) $ serve appApi $ hoistServer appApi (Handler . ExceptT . try)  $ apiServer ctx\nFocussing on the highlighted lines, you can see that it first reads the path to the configuration file (you would for instance run this file like so cabal run betref-server -- config.json) in line coreCfgPath <- parseArgs{:haskell}, then it parses this file coreCfg <- coreConfigIO coreCfgPath{:haskell}.We then see the use of an interesting function withCfgProviders. It's type is withCfgProviders :: GYCoreConfig  -> GYLogNamespace -> (GYProviders -> IO a) -> IO a{:haskell}, thus, this function first takes our parsed configuration file, then a namespace, finally followed by a continuation GYProviders -> IO a. Idea here is that this function will setup a GYProviders from the parsed configuration file and send it to this continuation to obtain its result.","defining-endpoints#Defining Endpoints":"","shared-context#Shared Context":"Entire code for it is available here\nOur endpoints would need an information for our provider, thus we have created the type for it, called Ctx. It's usage is made clear by function defined next, runQuery and runTx.Note about our handling of collateral: Browser wallets usually have the option to set for collateral, in such a case wallets would create an UTxO specifically to be used as collateral and such an UTxO will be reserved, i.e., wallet won't be spending it. CIP 40 changed the properties related to collateral and therefore we can safely take even that UTxO as collateral which has large amounts of ada and it could also contain multiple assets. Therefore if there is no collateral set by browser wallet, framework is capable of choosing suitable UTxO as collateral (and also sets for return collateral & total collateral fields appropriately) and in that case it is also free to spend it, if required by transaction builder. But if however there is a 5-ada collateral set by wallet, then framework would use it as collateral and would also reserve it, i.e., it won't pick to spend it unless explicitly mentioned by transaction skeleton. Also note that, we'll use browser wallet's getCollateral() method to get for collateral. This method usually returns a list of ada-only UTxOs in wallet within a specific range (like in case of Nami, it is those with ada less than or equal to 50). We would send first element of this list (if exists) to backend and framework would check if the value contained in this UTxO is exactly 5 ada or not (like Nami's getCollateral method returns only a singleton list if collateral is set in wallet), if not, framework would ignore this (i.e., would not reserve for it) and would itself pick suitable UTxO as collateral. If however you want this to be reserved (& of course used as collateral) regardless of it's value, see the comment in call to runGYTxBuilderMonadIO in runTx function.\n-- | Our Context.\ndata Ctx = Ctx\n  { ctxCoreCfg   :: !GYCoreConfig\n  , ctxProviders :: !GYProviders\n  }\n-- | To run for simple queries, the one which don't requiring building for transaction skeleton.\nrunQuery :: Ctx -> GYTxQueryMonadIO a -> IO a\nrunQuery ctx q = do\n  let nid = cfgNetworkId $ ctxCoreCfg ctx\n      providers = ctxProviders ctx\n  runGYTxQueryMonadIO nid providers q\n-- | Tries to build for given skeleton.\nrunTx ::\n  Ctx ->\n  -- | User's used addresses.\n  [GYAddress] ->\n  -- | User's change address.\n  GYAddress ->\n  -- | Browser wallet's reserved collateral (if set).\n  Maybe GYTxOutRefCbor ->\n  GYTxBuilderMonadIO (GYTxSkeleton v) ->\n  IO GYTxBody\nrunTx ctx addrs addr collateral skeleton = do\n  let nid = cfgNetworkId $ ctxCoreCfg ctx\n      providers = ctxProviders ctx\n  runGYTxBuilderMonadIO\n    nid\n    providers\n    addrs\n    addr\n    ( collateral\n        >>= ( \\c ->\n                Just\n                  ( getTxOutRefHex c\n                  , True -- Make this as `False` to not do 5-ada-only check for value in this given UTxO to be used as collateral.\n                  )\n            )\n    )\n    (skeleton >>= buildTxBody)","submit-endpoint#Submit Endpoint":"Entire code for it is available here\nWe'll soon see endpoints which will return for unsigned transaction to the browser but assuming that we already have a unsigned transaction CBOR & the missing signature, let's see how we can define an endpoint which will add this missing key witness to the transaction body and would then submit it using our provider.Input to this endpoint is a type AddWitAndSubmitParams encapsulating our unsigned transaction body & missing key witness.Then we have our function handleAddWitAndSubmitTx which adds the witness to the transaction making it complete and then it submits it. The response generated here is of type SubmitTxResponse and you can modify the same to include other fields if required.\n-- | Return type of API when submitting a transaction.\ndata SubmitTxResponse = SubmitTxResponse\n                          { submitTxFee :: !Integer\n                          , submitTxId  :: !GYTxId\n                          } deriving (Show, Generic, ToJSON, Swagger.ToSchema)\n-- | Input parameters to add for reference script.\ndata AddWitAndSubmitParams = AddWitAndSubmitParams\n  { awasTxUnsigned :: !GYTx\n  , awasTxWit      :: !GYTxWitness\n  } deriving (Generic, FromJSON, Swagger.ToSchema)\n-- | Construct `SubmitTxResponse` return type from the given signed transaction body.\ntxBodySubmitTxResponse :: GYTxBody -> SubmitTxResponse\ntxBodySubmitTxResponse txBody = SubmitTxResponse\n                                  { submitTxFee = txBodyFee txBody\n                                  , submitTxId  = txBodyTxId txBody\n                                  }\n-- | Type for our Servant API.\ntype TxAPI =\n      \"add-wit-and-submit\"\n    :> ReqBody '[JSON] AddWitAndSubmitParams\n    :> Post '[JSON] SubmitTxResponse\n-- | Serving our API.\nhandleTx :: Ctx -> ServerT TxAPI IO\nhandleTx = handleAddWitAndSubmitTx\n-- | Handle for adding key witness to the unsigned transaction & then submit it.\nhandleAddWitAndSubmitTx :: Ctx -> AddWitAndSubmitParams -> IO SubmitTxResponse\nhandleAddWitAndSubmitTx ctx AddWitAndSubmitParams{..} = do\n  let txBody = getTxBody awasTxUnsigned\n  void $ gySubmitTx (ctxProviders ctx) $ makeSignedTransaction awasTxWit txBody\n  return $ txBodySubmitTxResponse txBody","transaction-building-endpoints#Transaction Building Endpoints":"Entire code for it is available here\nAt this point, it should be easy to follow the code here. We first define the input type for our endpoint, we also derive its FromJSON instance so that we can parse it from JSON that our front-end will send for it and we also derive its Swagger.ToSchema instance so as to document our endpoint. Then our endpoint calls the relevant operation which we defined before to get transactoin skeleton, using which we obtain the transaction body with the help of functions such as runTxI and return the result (wrapped in our UnsignedTxResponse type).\nYou can see that all of our endpoints here ask for a list of used addresses, this makes them compatible with wallets that are not in single address mode (by default) such as Eternl.\n-- | Input wrapper around corresponding Plutus type.\ndata BetRefParams = BetRefParams\n  { brpOracleAddress :: !GYAddress\n  , brpBetUntil      :: !GYTime\n  , brpBetReveal     :: !GYTime\n  , brpBetStep       :: !GYValue\n  } deriving (Show, Generic, FromJSON, Swagger.ToSchema)\n-- | Convert the above `BetRefParams` with corresponding representation defined in our Plutus validator script.\nbetParamsToScript :: BetRefParams -> Script.BetRefParams\nbetParamsToScript brp = Script.BetRefParams\n  { Script.brpOraclePkh = pubKeyHashToPlutus $ fromJust $ addressToPubKeyHash $ brpOracleAddress brp\n  , Script.brpBetUntil = timeToPlutus $  brpBetUntil brp\n  , Script.brpBetReveal = timeToPlutus $ brpBetReveal brp\n  , Script.brpBetStep = valueToPlutus $  brpBetStep brp\n  }\n-- | Input parameters for place bet operation.\ndata PlaceBetRefParams = PlaceBetRefParams\n  { pbrUsedAddrs  :: ![GYAddress]\n  , pbrChangeAddr :: !GYAddress\n  , pbrCollateral :: !(Maybe GYTxOutRefCbor)\n  , pbrBetParams  :: !BetRefParams\n  , pbrBetGuess   :: !Integer\n  , pbrBetAmt     :: !GYValue\n  , pbrRefScript  :: !GYTxOutRef\n  , pbrPrevBetRef :: !(Maybe GYTxOutRef)\n  } deriving (Show, Generic, FromJSON, Swagger.ToSchema)\n-- | Input parameters for take bets operation.\ndata TakeBetRefParams = TakeBetRefParams\n  { tbrUsedAddrs         :: ![GYAddress]\n  , tbrChangeAddr        :: !GYAddress\n  , tbrCollateral        :: !(Maybe GYTxOutRefCbor)\n  , tbrBetParams         :: !BetRefParams\n  , tbrRefScript         :: !GYTxOutRef\n  , tbrPrevBetRef        :: !GYTxOutRef\n  , tbrOracleRefInputRef :: !GYTxOutRef\n  } deriving (Show, Generic, FromJSON, Swagger.ToSchema)\n-- | Input parameters to add for reference script.\ndata AddRefScriptParams = AddRefScriptParams\n  { arsUsedAddrs  :: ![GYAddress]\n  , arsChangeAddr :: !GYAddress\n  , arsCollateral :: !(Maybe GYTxOutRefCbor)\n  , arsPutAddress :: !GYAddress\n  , arsBetParams  :: !BetRefParams\n  } deriving (Show, Generic, FromJSON, Swagger.ToSchema)\n-- | Input parameters to add for reference input.\ndata AddRefInputParams = AddRefInputParams\n  { ariUsedAddrs  :: ![GYAddress]\n  , ariChangeAddr :: !GYAddress\n  , ariCollateral :: !(Maybe GYTxOutRefCbor)\n  , ariPutAddress :: !GYAddress\n  , ariBetAnswer  :: !Integer\n  } deriving (Show, Generic, FromJSON, Swagger.ToSchema)\n-- | Return type for our API endpoints defined here.\ndata UnsignedTxResponse = UnsignedTxResponse\n  { urspTxBodyHex :: !T.Text              -- ^ Unsigned transaction cbor.\n  , urspTxFee     :: !(Maybe Integer)     -- ^ Tx fees.\n  , urspUtxoRef   :: !(Maybe GYTxOutRef)  -- ^ Some operations might need to show for relevant UTxO generated.\n  } deriving (Show, Generic, FromJSON, ToJSON, Swagger.ToSchema)\n-- | Construct `UnsignedTxResponse` return type for our endpoint given the transaction body & relevant index for UTxO (if such exists).\nunSignedTxWithFee :: GYTxBody -> Maybe GYTxOutRef -> UnsignedTxResponse\nunSignedTxWithFee txBody mUtxoRef = UnsignedTxResponse\n  { urspTxBodyHex  = T.pack $ txToHex $ unsignedTx txBody\n  , urspTxFee      = Just $ txBodyFee txBody\n  , urspUtxoRef    = mUtxoRef\n  }\n-- | Type for our Servant API.\ntype BetRefApi =\n       \"place\"\n    :> ReqBody '[JSON] PlaceBetRefParams\n    :> Post    '[JSON] UnsignedTxResponse\n  :<|> \"take\"\n    :> ReqBody '[JSON] TakeBetRefParams\n    :> Post    '[JSON] UnsignedTxResponse\n  :<|> \"add-ref-script\"\n    :> ReqBody  '[JSON] AddRefScriptParams\n    :> Post     '[JSON] UnsignedTxResponse\n  :<|> \"add-ref-input\"\n    :> ReqBody  '[JSON] AddRefInputParams\n    :> Post     '[JSON] UnsignedTxResponse\n-- | Serving our API.\nhandleBetRefApi :: Ctx -> ServerT BetRefApi IO\nhandleBetRefApi ctx =   handlePlaceBet ctx\n                   :<|> handleTakeBet ctx\n                   :<|> handleAddRefScript ctx\n                   :<|> handleOracleRefInput ctx\n-- | Handle for place bet operation.\nhandlePlaceBet :: Ctx -> PlaceBetRefParams -> IO UnsignedTxResponse\nhandlePlaceBet ctx PlaceBetRefParams{..} = do\n  let brp = betParamsToScript pbrBetParams\n  validatorAddress <- runQuery ctx (betRefAddress brp)\n  txBody <- runTxI ctx pbrUsedAddrs pbrChangeAddr pbrCollateral\n              $ placeBet pbrRefScript (betParamsToScript pbrBetParams) (Script.OracleAnswerDatum pbrBetGuess) pbrBetAmt (head pbrUsedAddrs) pbrPrevBetRef\n  placeUtxoRef <- case find (\\utxo -> utxoAddress utxo == validatorAddress) $ utxosToList $ txBodyUTxOs txBody of\n        Nothing -> fail \"Shouldn't happen: No reference for placed bet in body\"\n        Just utxo -> pure $ utxoRef utxo\n  pure $ unSignedTxWithFee txBody $ Just placeUtxoRef\n-- | Handle for take bets operation.\nhandleTakeBet :: Ctx -> TakeBetRefParams -> IO UnsignedTxResponse\nhandleTakeBet ctx TakeBetRefParams{..} = do\n  txBody <- runTxI ctx tbrUsedAddrs tbrChangeAddr tbrCollateral\n              $ takeBets tbrRefScript (betParamsToScript tbrBetParams) tbrPrevBetRef (head tbrUsedAddrs) tbrOracleRefInputRef\n  pure $ unSignedTxWithFee txBody Nothing\n-- | Handle for adding reference script.\nhandleAddRefScript :: Ctx -> AddRefScriptParams  -> IO UnsignedTxResponse\nhandleAddRefScript  ctx AddRefScriptParams{..} = do\n  let validator = betRefValidator' (betParamsToScript arsBetParams)\n  txBody <- runTxI ctx arsUsedAddrs arsChangeAddr arsCollateral\n              $ pure $ addRefScript' arsPutAddress validator\n  let refs   = Limbo.findRefScriptsInBody txBody\n  outRef <- case Map.lookup (Some (validatorToScript validator)) refs of\n                 Nothing  -> fail \"Shouldn't happen: No reference for added Script in body\"\n                 Just ref -> return ref\n  pure $ unSignedTxWithFee txBody $ Just outRef\n-- | Handle for adding reference input.\nhandleOracleRefInput :: Ctx -> AddRefInputParams  -> IO UnsignedTxResponse\nhandleOracleRefInput  ctx AddRefInputParams{..} = do\n  let ourDatumPlutus = Script.OracleAnswerDatum ariBetAnswer\n      ourDatumGY = datumFromPlutusData ourDatumPlutus\n  txBody <- runTxI ctx ariUsedAddrs ariChangeAddr ariCollateral\n              $ pure $ addRefInput' ariPutAddress ourDatumPlutus\n  let utxos = utxosToList $ txBodyUTxOs txBody\n      ourDatumHash = hashDatum ourDatumGY\n      mRefInputUtxo = find (\\utxo ->\n        case utxoOutDatum utxo of\n          GYOutDatumHash dh  -> ourDatumHash == dh\n          GYOutDatumInline d -> ourDatumGY == d\n          GYOutDatumNone     -> False\n        ) utxos\n  case mRefInputUtxo of\n    Nothing               -> fail \"Shouldn't happen: Couldn't find the desired UTxO in Tx outputs\"\n    Just GYUTxO {utxoRef} -> pure $ unSignedTxWithFee txBody $ Just utxoRef","wrap-up#Wrap-Up":"Our both the endpoints file (transaction submition & transaction building) our wrapped up in our Api.hs following the usual servant boilerplate.\n-- | Type for our Servant API.\ntype Api =\n        \"tx\"  :> TxAPI\n  :<|>  \"betref\" :>  BetRefApi\nappApi :: Proxy Api\nappApi = Proxy\napiSwagger  :: Swagger\napiSwagger  = toSwagger appApi\napiServer :: Ctx -> ServerT Api IO\napiServer ctx =\n       handleTx ctx\n  :<|> handleBetRefApi ctx\nNow coming back to our server-main.hs file, we can now understand the highlighted code sections which relates to obtaining the Swagger file (generated from apiSwagger function above) and running up our servant server.\nWe follow simpleCorsResourcePolicy (also allowing Content-Type request header) so that calls by our front-end (which runs on different origin) don't get blocked.\n-- | Getting path for our core configuration.\nparseArgs :: IO FilePath\nparseArgs = do\n  args <- getArgs\n  case args of\n    coreCfg: _ -> return coreCfg\n    _invalidArgument -> fail \"Error: wrong arguments, needed a path to the CoreConfig JSON configuration file\\n\"\nmain :: IO ()\nmain = do\n  putStrLn \"Writing Swagger file ...\"\n  BL8.writeFile \"swagger-api.json\" (encodePretty apiSwagger)\n  putStrLn \"parsing Config ...\"\n  coreCfgPath <- parseArgs\n  coreCfg <- coreConfigIO coreCfgPath  -- Parsing our core configuration.\n  putStrLn \"Loading Providers ...\"\n  withCfgProviders coreCfg \"api-server\"  $ \\providers -> do\n    let port = 8081\n        ctx = Ctx coreCfg providers\n    putStrLn $ \"Starting server at \\n \" <> \"http://localhost:\" <> show port\n    run port $ app ctx\napp :: Ctx -> Application\napp ctx = cors (const $ Just simpleCorsResourcePolicy { corsRequestHeaders = [HttpTypes.hContentType] }) $ serve appApi $ hoistServer appApi (Handler . ExceptT . try)  $ apiServer ctx\nNext we'll see how to call these endpoints in our front-end!"}},"/getting-started/how-to-build":{"title":"How to build?","data":{"":"We currently support GHC version 9.6.5 and compilation is tested with cabal version 3.10.2.0.Besides basic Haskell tooling (GHC and cabal), since we depend upon libraries used in cardano-node, one would need to have additional dependencies as described in this guide related to building node from source. When referring to that guide, for our purposes, section on \"Installing the Haskell environment\" and sections following (& including) \"Downloading the source code for cardano-node\" are irrelevant.Additionally one would need libpq-dev or postgresql installed in their environment otherwise an error suggesting missing pg_config can occur.We build Atlas in our Github CI using environment described here which one can also refer if they encounter a build failure.To verify if environment is configured properly, one can clone Atlas repository from here and run cabal update && cabal build all to see if build is successful.\nIf you receive an error related to building postgresql-libpq:+use-pkg-config, try unsetting use-pkg-config flag in your cabal.project.local file.","building-with-nix#Building with Nix":"Alternatively, we provide a nix shell with all dependencies baked in. Please refer to this guide on how to configure nix and later one can enter development shell via nix develop."}},"/getting-started/operations":{"title":"Operations over Contract","data":{"":"Having understood the contract. Now is the time we actually start using our framework to build the transactions for it.The main principle to understand here is that - we only need to give the essentials, i.e. we only specify what we want and it is the job of the framework to do the rest.For instance, we may tell that we want to consume a specific input belonging to the script's address and generate a specific output. Given that, it becomes framework's job to do the rest, say:\nSelect available UTxO's in user's wallet and generate suitable change output to balance the transaction, considering fees.\nMake sure all generated UTxO's satisfy minimum ada requirement.\nHandle collateral.\netc, etc.\nThus, we only specify at high-level what we want. This would become clear as we actually start writing operations for our contract.Entire code for these operations is available here.\nWhen working with Atlas inside your project, since Atlas isn't on Hackage, you'll need to specify it as a remote package inside your cabal.project. Moreover, since Atlas itself relies on dependencies which are outside Hackage, those would need to be specified too. To streamline this, it's best to use the cabal.project mentioned in atlas-examples repository where you would just need to modify packages: stanza depending upon your project.","operation-1-generating-address-for-our-smart-contract#Operation 1: Generating address for our Smart Contract":"","generating-validator-for-our-smart-contract#Generating Validator for our Smart Contract":"Following the usual drill, we generate the Validator given contract parameters (following is written in file Compiled.hs):\n-- | Generates validator given params.\nbetRefValidator :: BetRefParams -> PlutusTx.CompiledCode (PlutusTx.BuiltinData -> PlutusTx.BuiltinData -> PlutusTx.BuiltinData -> ())\nbetRefValidator betRefParams =\n    $$(PlutusTx.compile [|| mkBetRefValidator||]) `PlutusTx.unsafeApplyCode` PlutusTx.liftCode plcVersion100 betRefParams\nInside Atlas, Plutus scripts are represented as GYScript (v :: PlutusVersion).\nThe mentioned GeniusYield.Types.Script module contains a lot of helper utilities such as scriptFromPlutus which takes in Plutus's PlutusTx.CompiledCode a type to give out GYScript v where type variable v is of kind PlutusVersion which is defined in GeniusYield.Types.PlutusVersion module and is used to tag plutus ledger version of our validator script.If we look at the type signature of scriptFromPlutus, we see: scriptFromPlutus :: forall v a. SingPlutusVersionI v => PlutusTx.CompiledCode a -> GYScript v where for the time being we can ignore the description of the typeclass SingPlutusVersionI besides noting the fact that only types (currently 'PlutusV1, 'PlutusV2 & 'PlutusV3) of kind PlutusVersion have an instance for it. So here, our function scriptFromPlutus works for all type variable v which have an instance of SingPlutusVersionI but there is no way to learn what this v is based solely on the input PlutusTx.CompiledCode a and therefore, caller must specify it, either by providing type signature (of callee or caller due to type inference) or by using visible type application. Our first operation does make use of it but before looking at it, we need to understand about GYTxQueryMonad.","interlude---gytxquerymonad#Interlude - GYTxQueryMonad":"When we want to obtain the address of the script from its hash, besides the hash, we also need to know the network we are currently operating at. Is it some testnet or mainnet?Similarly, transaction building involves querying the ledger for various information like say querying UTxO's present at one's address, similarly it might need help of some chain indexer to query datum in case output contains only the datum's hash.All of this is captured by typeclass GYTxQueryMonad documented here. It is strongly advised to see methods made available by it.So, if we are working inside a monad which happens to also provide an instance for it, we would happily be able to query such an information.","generating-address#Generating address":"In this operation, we only need to obtain network details with the help of this monad. Here is the code to obtain address (notice that we have provided multiple versions of the same code here):\nType of scriptAddress used below is scriptAddress :: forall (m :: * -> *) (v :: PlutusVersion). GYTxQueryMonad m => GYScript v -> m GYAddress. Thus with respect to type application, the first parameter is for monad and second one is PlutusVersion kinded.Internally this function queries for network details.\n-- A. Type is given by `scriptAddress`.\n-- | Validator in question, obtained after giving required parameters.\nbetRefValidator' ::  SingPlutusVersionI v => BetRefParams -> GYScript v\nbetRefValidator' brp = scriptFromPlutus $ betRefValidator brp\n-- | Address of the validator, given params.\nbetRefAddress :: (HasCallStack, GYTxQueryMonad m) => BetRefParams -> m GYAddress\nbetRefAddress brp = scriptAddress @_ @'PlutusV2 $ betRefValidator' brp\n-- B. Type is given by `scriptFromPlutus` using type application.\n-- | Validator in question, obtained after giving required parameters.\nbetRefValidator' brp = scriptFromPlutus @'PlutusV2 $ betRefValidator brp\n-- | Address of the validator, given params.\nbetRefAddress :: (HasCallStack, GYTxQueryMonad m) => BetRefParams -> m GYAddress\nbetRefAddress brp = scriptAddress $ betRefValidator' brp\n-- C. Type is specified using signature.\n-- | Validator in question, obtained after giving required parameters.\nbetRefValidator' :: BetRefParams -> GYScript 'PlutusV2\nbetRefValidator' brp = scriptFromPlutus $ betRefValidator brp\n-- | Address of the validator, given params.\nbetRefAddress :: (HasCallStack, GYTxQueryMonad m) => BetRefParams -> m GYAddress\nbetRefAddress brp = scriptAddress $ betRefValidator' brp\nWell what is this monad m being used here? Well any! As long as it has an instance for GYTxQueryMonad. When we will start writing tests, then we'll use all of these operations and most likely how to use them would become clear then.","operation-2-adding-input-to-refer-later-reference-input#Operation 2: Adding Input to refer later (Reference Input)":"","interlude---gytxskeleton#Interlude - GYTxSkeleton":"As mentioned before, we just mention at high level what we want in a transaction. This is captured by GYTxSkeleton datatype and its description is mentioned below.\nFields\tRepresented by\tAdditional details\tInputs\tgytxIns\tIt is a list of inputs where for each input, we have its UTxO reference (the \"TxIn\" as the cardano ledger specification calls it) and a witness. In case this UTxO doesn't belong to a script, we just need spending key witness, otherwise we need the associated script, its datum and input redeemer where the associated script could be provided as part of this transaction body or could be obtained from reference input. See GeniusYield.Types.TxIn.\tOutputs\tgytxOuts\tList of outputs produced by this transaction where for each output we can mention whether the datum is to be inlined or not and whether this output stores any script. See GeniusYield.Types.TxOut.\tReference Inputs\tgytxRefIns\tSet of reference to UTxOs corresponding to reference inputs.\tMints\tgytxMint\tMap of minting policy to pair of redeemer and another map for token name to mint amount for that token.\tWithdrawals\tgytxWdrls\tIt is a list of withdrawals. Each withdrawal is specified by the concerned stake address with it's associated available rewards and witness. Witness could either be a key witness or a script witness.\tSignatories\tgytxSigs\tSet of Public Key Hash of Signatories.\tCertificates\tgytxCerts\tList of transaction certificates.\tValid after\tgytxInvalidBefore\tJust the corresponding node slot.\tValid before\tgytxInvalidAfter\tSame as above.\tMetadata\tgytxMetadata\tTransaction metadata.\tVoting procedures\tgytxVotingProcedures\tTransaction voting procedures.\tProposal procedures\tgytxProposalProcedures\tTransaction proposal procedures.\t\nWhen constructing the transaction, we just need to specify what we want in this skeleton.This skeleton naturally has a monoid instance where two skeletons are combined by running mappend over each of their fields. We have utility functions defined in the same (GeniusYield.TxBuilder.Class) module like:\nmustHaveOutput :: GYTxOut v -> GYTxSkeleton v\nmustHaveOutput o = emptyGYTxSkeleton {gytxOuts = [o]}\nmustHaveInput :: GYTxIn v -> GYTxSkeleton v\nmustHaveInput i = emptyGYTxSkeleton {gytxIns = [i]}\nmustHaveRefInput :: VersionIsGreaterOrEqual v PlutusV2 => GYTxOutRef -> GYTxSkeleton v\nmustHaveRefInput i = emptyGYTxSkeleton { gytxRefIns = GYTxSkeletonRefIns (Set.singleton i) }\nmustMint :: GYMintingPolicy u -> GYRedeemer -> GYTokenName -> Integer -> GYTxSkeleton v\nmustMint p r tn n = emptyGYTxSkeleton {gytxMint = Map.singleton (Some p) (Map.singleton tn n, r)}\nmustBeSignedBy :: GYPubKeyHash -> GYTxSkeleton v\nmustBeSignedBy pkh = emptyGYTxSkeleton {gytxSigs = Set.singleton pkh}\nisInvalidBefore :: GYSlot -> GYTxSkeleton v\nisInvalidBefore s = emptyGYTxSkeleton {gytxInvalidBefore = Just s}\nisInvalidAfter :: GYSlot -> GYTxSkeleton v\nisInvalidAfter s = emptyGYTxSkeleton {gytxInvalidAfter = Just s}\nmustHaveTxMetadata :: Maybe GYTxMetadata -> GYTxSkeleton v\nmustHaveTxMetadata m = emptyGYTxSkeleton {gytxMetadata = m}\nmustHaveWithdrawal :: GYTxWdrl v -> GYTxSkeleton v\nmustHaveWithdrawal w = mempty {gytxWdrls = [w]}\nmustHaveCertificate :: GYTxCert v -> GYTxSkeleton v\nmustHaveCertificate c = mempty {gytxCerts = [c]}\nThus we can specify that our transaction must have this output (using mustHaveOutput) and that output and must have this input (using mustHaveInput) and so on... and combine them all into a single skeleton using mappend.","skeleton-for-adding-reference-input#Skeleton for adding reference input":"Here we want to create an output at a given address (Oracle's address) with the given datum. This UTxO is to be later used as a reference input by script where the script would refer to its datum. Here we have decided to keep this datum inline.\n-- | Add UTxO to be used as reference input at a given address with given datum.\naddRefInput :: GYAddress -> OracleAnswerDatum -> GYTxSkeleton 'PlutusV2\naddRefInput addr dat =\n  mustHaveOutput $ GYTxOut addr mempty (Just (datumFromPlutusData dat, GYTxOutUseInlineDatum)) Nothing\n  -- Note that the value can be empty as tx building logic would add the needed minimum UTxO ada.\nNote that we have mentioned the value as empty for this UTxO and this is one of the beauties of our framework that it will itself manage adding lovelaces to satisfy minimum ada requirement.","q-can-you-create-a-skeleton-for-adding-reference-script#Q: Can you create a skeleton for adding reference script?":"Toggle Answer \nGiven the output address addr :: GYAddress{:haskell} and the Plutus V2 validator script :: GYScript 'PlutusV2{:haskell}, we can write mustHaveOutput $ GYTxOut addr mempty (Just (datumFromPlutusData (), GYTxOutDontUseInlineDatum)) (Just script){:haskell}","operation-3-placing-a-bet#Operation 3: Placing a bet":"","placing-the-first-bet#Placing the first bet":"In case this is a first bet (a program handling the bets can decide whether the bet being placed by the user is first or not by querying the UTxOs at the script address), then we just need to produce an output at the script address with the bet value and our guess.\n-- | Operation to place bet.\nplaceBet :: (HasCallStack, GYTxMonad m)\n              => GYTxOutRef         -- ^ Reference Script.\n              -> BetRefParams       -- ^ Validator Params.\n              -> OracleAnswerDatum  -- ^ Guess.\n              -> GYValue            -- ^ Bet amount to place.\n              -> GYAddress          -- ^ Own address.\n              -> Maybe GYTxOutRef   -- ^ Reference to previous bets UTxO (if any).\n              -> m (GYTxSkeleton PlutusV2)\nplaceBet refScript brp guess bet ownAddr mPreviousBetsUtxoRef = do\n  pkh <- addressToPubKeyHash' ownAddr\n  betAddr <- betRefAddress brp\n  case mPreviousBetsUtxoRef of\n    -- This is the first bet.\n    Nothing -> do\n      return $ mustHaveOutput $ GYTxOut\n        { gyTxOutAddress = betAddr\n        , gyTxOutValue = bet\n        , gyTxOutDatum = Just (datumFromPlutusData $ BetRefDatum [(pubKeyHashToPlutus pkh, guess)] (valueToPlutus bet), GYTxOutDontUseInlineDatum)\n        , gyTxOutRefS    = Nothing\n        }\nAt this point, it should be clear what is happening in the above code block. This function is somewhat overloaded and is handling both the cases whether the bet is first or not and it determines this using the presence of reference to a UTxO (representing previous bets) at validator script. In case there isn't one, i.e., Nothing for our Maybe value, we are placing the first bet. Notice that we mention that our datum shouldn't be inlined to output using GYTxOutDontUseInlineDatum.","placing-subsequent-bets#Placing subsequent bets":"Here we would be exercising script's logic for the first time. We would be consuming the UTxO present at script address. We have defined a function, viz. input which would take in the following parameters:\nBetRefParams: to generate the validator script or else we can read the script from the UTxO pertaining to reference script.\nReference to reference script UTxO.\nReference of script input to consume.\nThe datum present at this input. Recall that our datum was not inlined for this particular output, we therefore would need lookup the datum using lookupDatum to pass the actual datum to this function.\nRedeemer action.\nThus, we have its definition as:\n-- | Utility function to consume script UTxO.\ninput :: BetRefParams -> GYTxOutRef -> GYTxOutRef -> BetRefDatum -> BetRefAction -> GYTxSkeleton 'PlutusV3\ninput brp refScript inputRef dat red =\n  mustHaveInput\n    GYTxIn\n      { gyTxInTxOutRef = inputRef\n      , gyTxInWitness =\n          GYTxInWitnessScript\n            (GYBuildPlutusScriptReference refScript $ betRefValidator' brp)\n            (datumFromPlutusData dat)\n            (redeemerFromPlutusData red)\n      }\nIn case we didn't want to use reference script, we would write gyTxInWitness as:\ngyTxInWitness  = GYTxInWitnessScript\n        (GYBuildPlutusScriptInlined (betRefValidator' brp))\n        (datumFromPlutusData dat)\n        (redeemerFromPlutusData red)\nFollowing is the complete code for handling this case. Few comments to facilitate its understanding:\nWe first query the UTxO corresponding to previous bets at script address and we then query for its datum using utxoDatum' which tries its best to retrieve the datum and raises an exception in case it fails. This is its signature: utxoDatum' :: (GYTxQueryMonad m, Plutus.FromData a) => GYUTxO -> m (GYAddress, GYValue, a).\nNote: utxoAtTxOutRef' is a wrapper around utxoAtTxOutRef which raises an exception in case the result was Nothing.\nWe then see the use of gyLogDebug' which as you would expect is for logging purposes. The first argument that it takes correspond to namespace as used by Katip. This is where integration of off-chain and on-chain code really begins to shine âœ¨, having the Show instance defined for some of our on-chain types allows us to log them.\ntimeFromPlutus is as you'll expect - gives us the framework's representation of time from that of plutus. And enclosingSlotFromTime' uses ledger's information to determine the corresponding slot for the given time. We need this as cardano's node work in slots. We mention that our transaction is to be invalid after this slot using isInvalidAfter.\nWe mention that our transaction must have our public key hash as signatories when plutus smart contract asks for it using mustBeSignedBy.\nLastly, this transaction must generate an output to the script's address with the updated datum and added value.\nvalueToPlutus gives the corresponding value type used by plutus from what we have in our framework (viz., GYValue).\nAll these skeletons are combined together using mappend defined for GYTxSkeleton.\n    -- Need to append to previous.\n    Just previousBetsUtxoRef -> do\n      previousUtxo <- utxoAtTxOutRef' previousBetsUtxoRef\n      (_addr, previousValue, dat@(BetRefDatum previousGuesses _previousBet)) <- utxoDatum' previousUtxo\n      gyLogDebug' \"\" $ printf \"previous guesses %s\" (show previousGuesses)\n      betUntilSlot <- enclosingSlotFromTime' (timeFromPlutus $ brpBetUntil brp)\n      gyLogDebug' \"\" $ printf \"bet until slot %s\" (show betUntilSlot)\n      return $\n           input brp refScript previousBetsUtxoRef dat (Bet guess)\n        <> mustHaveOutput GYTxOut\n              { gyTxOutAddress = betAddr\n              , gyTxOutValue = bet <> previousValue\n              , gyTxOutDatum = Just (datumFromPlutusData $ BetRefDatum ((pubKeyHashToPlutus pkh, guess) : previousGuesses) (valueToPlutus bet), GYTxOutDontUseInlineDatum)\n              , gyTxOutRefS    = Nothing\n              }\n        <> isInvalidAfter betUntilSlot\n        <> mustBeSignedBy pkh","operation-4-taking-the-bet-pot#Operation 4: Taking the bet pot":"At this point, reading following code snippet should make sense as it is similar to what we have done before. Here note that we are using mustHaveRefInput to tell that the transaction must have the following UTxO reference as a reference input.\nObserve that we don't need to specify that the value we successfully consume from the script's UTxO must reach us because transaction balancer would add the change output to us.\n-- | Operation to take UTxO corresponding to previous bets.\ntakeBets :: (HasCallStack, GYTxMonad m)\n              => GYTxOutRef    -- ^ Reference Script.\n              -> BetRefParams  -- ^ Validator params.\n              -> GYTxOutRef    -- ^ Script UTxO to consume.\n              -> GYAddress     -- ^ Own address.\n              -> GYTxOutRef    -- ^ Oracle reference input.\n              -> m (GYTxSkeleton PlutusV2)\ntakeBets refScript brp previousBetsUtxoRef ownAddr oracleRefInput = do\n  pkh <- addressToPubKeyHash' ownAddr\n  previousUtxo <- utxoAtTxOutRef' previousBetsUtxoRef\n  (_addr, _previousValue, dat) <- utxoDatum' previousUtxo\n  betRevealSlot <- enclosingSlotFromTime' (timeFromPlutus $ brpBetReveal brp)\n  return $\n       input brp refScript previousBetsUtxoRef dat Take\n    <> isInvalidBefore betRevealSlot\n    <> mustHaveRefInput oracleRefInput\n    <> mustBeSignedBy pkh","additional-useful-features#Additional Useful Features":"","utxosdatums#utxosDatums":"Sometimes we want to see all valid UTxOs at our script address. In Cardano, anyone can form UTxO at any address and such a UTxO need not have valid datum as required by our script. utxosDatums can be used wither out invalid ones. See it's usage in Vesting example.","mustmint#mustMint":"We weren't minting any tokens in our example here and thus didn't make use of mustMint skeleton function. It's sample usage is given in this example. Which also illustrates how one can mint NFT and shows usage of someUTxO function which essentially gives some random UTxO belonging to wallet.","withdrawals-stake-validator--stake-certificates#Withdrawals, Stake Validator & Stake Certificates":"We haven't made use of withdrawals, stake certificates and stake validators in our example. A sample illustration is provided in this privnet test.","additional-certificates#Additional certificates":"Atlas has rich support of all possible certificates, see our section on Certificates to learn more about working with them.","governance-procedures#Governance procedures":"See Governance procedures section to learn how to do governance procedures using Atlas.","monad-hierarchy#Monad hierarchy":"In Atlas we have hierarchy of monads with increasing level of capabilities. We already introduced GYTxQueryMonad. Besides it, we also have following monads. Don't worry if it appears overwhelming, they are mainly there for advanced usage and you would very rarely need to bother about their internals.","gytxuserquerymonad#GYTxUserQueryMonad":"GYTxQueryMonad is a super-class of GYTxUserQueryMonad. It is to be used for queries which have access to user's wallet details, such as change address, used addresses and so on. Please have a look at it's haddock entry here to view available functions.","gytxbuildermonad#GYTxBuilderMonad":"GYTxUserQueryMonad is a superclass of GYTxBuilderMonad. Purpose of GYTxBuilderMonad is to allow for functions related to transaction building. This however could have been part of GYTxUserQueryMonad but is separate only to allow for different custom transaction building strategy to be used as default. As we will soon see, in our code, we would use buildTxBody to build for transaction, and that would be possible only if we are working inside GYTxBuilderMonad.","gytxmonad#GYTxMonad":"GYTxBuilderMonad is a superclass of GYTxMonad. Difference between GYTxMonad and GYTxBuilderMonad is that former allows for signing of transactions, thus it requires access to user's private key. The main function we would encounter from this class is signAndSubmitConfirmed.","gytxgamemonad#GYTxGameMonad":"GYTxMonad is a superclass of GYTxGameMonad. This monad allows for simulating multiple users, and is mainly used for testing. We touch more on it in our testing section.This is making use of \"singletons\" and one can read about it from the \"Dependent Types\" chapter (the last one) in Thinking with Types book."}},"/getting-started/smart-contract-intro":{"title":"Smart Contract","data":{"":"Let's now start by writing a smart contract that we will use to convey framework's important features.\nThis contract is for illustrative purposes only. We do not recommend using it in a production environment.\nHere we'll be writing our smart contract in Plutus-tx (aka Plinth) but do note that we are not limited to it. If you are using Aiken, check out our Blueprint section to see how easily Aiken validators can be plugged into Atlas, also supporting creation of high level Haskell types corresponding to blueprint schema.And in general, one can read the compiled validator's CBOR using scriptFromCBOR function defined here (Operations over Contract chapter explains about types such as GYScript, PlutusVersion which are used in this function). Similarly, there is readScript defined in the same file to read from the compiled text envelope file.Note that if your validator is written in Plutarch, we recommend Ply to read Plutarch compiled scripts. In particular, check out this example where GeniusYield reads it's plutarch validators into Atlas.\nBesides Plutus scripts, Atlas also supports Simple scripts. Check out Simple Scripts section to learn more!","contract-description#Contract Description":"A setting here is that we have a sport match happening and a group of friends want to bet on the number of goals scored by their favorite team in it.Winner is the one whose guess is closest (and in case of tie - the one who takes it fastest!).The smart contract code is available here. This example was inspired by MLabs.\nSince the underlying version of plutus library we are using defaults to version 1.1.0 of plutus core, we need to explicitly set target-version to 1.0.0 (as this example uses Plutus V2 ledger version, but Atlas also supports Plutus V3), and that is why there is ghc-options: -fplugin-opt PlutusTx.Plugin:target-version=1.0.0 in our cabal file.","contract-parameters#Contract Parameters":"brpOraclePkh :: PubKeyHash: We'll be using a reference input, and its datum will give us the actual result (the number of goals). Since the reference input UTxO must belong to Oracle, we check it using Oracle's payment public key hash.\nbrpBetUntil :: POSIXTime: Time until which bets can be placed.\nbrpBetReveal :: POSIXTime: Time that the Oracle will reveal the match results.\nbrpBetStep :: Value: Minimum value that bets must increase by.\nThus, the parameters of our contract are given by:\n-- | Our contract is parameterized with this.\ndata BetRefParams = BetRefParams\n  { brpOraclePkh :: PubKeyHash  -- ^ Oracle's payment public key hash. This is needed to assert that UTxO being looked at indeed belongs to the Oracle.\n  , brpBetUntil  :: POSIXTime   -- ^ Time until which bets can be placed.\n  , brpBetReveal :: POSIXTime   -- ^ Time at which Oracle will reveal the correct match result.\n  , brpBetStep   :: Value       -- ^ Each newly placed bet must be more than previous bet by `brpBetStep` amount.\n  }\nPlutusTx.unstableMakeIsData ''BetRefParams","reference-input-datum#Reference Input Datum":"The Oracle tells us the number of goals scored by the concerned team:\n-- | Goals made my the concerned team.\ntype TeamGoals = Integer\n-- | Match result given by the Oracle.\nnewtype OracleAnswerDatum = OracleAnswerDatum TeamGoals deriving newtype (Eq, Show)\nPlutusTx.unstableMakeIsData ''OracleAnswerDatum","contract-datum#Contract Datum":"It consists of two fields:\nList containing each person's guess along with their payment public key hash. Key hash is used to tie guess with the guesser. Every time a new guess is made, we prepend it to this list.\nThis key hash is obtained from transaction signatories - we insist on key hash being present in signatories as otherwise anyone may override bet of someone else.\nAmount denoting the previously placed bet. Note that the total value in the UTxO belonging to contract is the culmination of all the previously placed bets and thus it isn't in general equal to last placed bet. We use this to assert that the newly placed bet is more than the previous one by brpBetStep amount.\n-- | List of guesses by users along with the maximum bet placed yet. A new guess gets /prepended/ to this list. Note that since we are always meant to increment previously placed bet with `brpBetStep`, the newly placed bet would necessarily be maximum (it would be foolish to initialize `brpBetStep` with some negative amounts).\ndata BetRefDatum = BetRefDatum\n  { brdBets        :: [(PubKeyHash, OracleAnswerDatum)]\n  , brdPreviousBet :: Value\n  }\nPlutusTx.unstableMakeIsData ''BetRefDatum","contract-redeemer#Contract Redeemer":"There are two actions available to user:\nTo place a bet - in which case they give their guess.\nTo take the bets in the pot after the result is out.\nThis is therefore codified as:\n-- | Redeemer representing choices available to the user.\ndata BetRefAction = Bet !OracleAnswerDatum  -- ^ User makes a guess.\n                  | Take                    -- ^ User takes the pot.\nPlutusTx.unstableMakeIsData ''BetRefAction","contract-logic#Contract Logic":"","placing-a-bet#Placing a bet":"Initial bet gets placed as it is (in Cardano, spending validator script is executed only when spending an UTxO belonging to it but not for creating at it).For subsequent bets, we require three conditions:\nThe bet must be before (inclusive) the brpBetUntil time.\nThere must be exactly one continuing output at the script address whose datum shall have the current guess prepended to it along with the current bet amount.\nThe current bet must be more than the previous bet by at least brpBetStep amount.\nThis is coded as:\n{-# INLINABLE mkBetRefValidator' #-}\n-- | Core smart contract logic. Read its description from Atlas guide.\nmkBetRefValidator' :: BetRefParams -> BetRefDatum -> BetRefAction -> ScriptContext -> Bool\nmkBetRefValidator' (BetRefParams oraclePkh betUntil betReveal betStep) (BetRefDatum previousGuesses previousBet) brAction ctx =\n  case brAction of\n    Bet guess  ->\n      let\n        sOut = case getContinuingOutputs ctx of\n          [sOut']        -> sOut'\n          _anyOtherMatch -> traceError \"Expected only one continuing output.\"\n        outValue = txOutValue sOut\n        sIn = maybe (traceError \"Could not find own input\") txInInfoResolved (findOwnInput ctx)\n        inValue = txOutValue sIn\n        (guessesOut, betOut) = case outputToDatum sOut of\n          Nothing                                -> traceError \"Could not resolve for script output datum\"\n          Just (BetRefDatum guessesOut' betOut') -> (guessesOut', betOut')\n      in\n        traceIfFalse\n          \"Must be before `BetUntil` time\"\n            (to betUntil `contains` validRange) &&\n        traceIfFalse\n          \"Guesses update is wrong\"\n            ((signerPkh, guess) : previousGuesses == guessesOut) &&\n        traceIfFalse\n          \"The current bet must be more than the previous bet by atleast `brpBetStep` amount\"\n            (outValue `geq` (inValue <> previousBet <> betStep)) &&\n        traceIfFalse\n          \"Out bet is wrong\"\n            (betOut == outValue - inValue)\nWhere we have the following common helpers for both the redemeer actions:\n  where\n    info :: TxInfo\n    info = scriptContextTxInfo ctx\n    validRange :: POSIXTimeRange\n    validRange = txInfoValidRange info\n    signerPkh :: PubKeyHash\n    signerPkh = case txInfoSignatories info of\n      [signerPkh']   -> signerPkh'\n      []             -> traceError \"No signatory\"\n      _anyOtherMatch -> traceError \"Expected only one signatory\"\n    outputToDatum :: FromData b => TxOut -> Maybe b\n    outputToDatum o = case txOutDatum o of\n      NoOutputDatum      -> Nothing\n      OutputDatum d      -> processDatum d\n      OutputDatumHash dh -> processDatum =<< findDatum dh info\n      where processDatum = fromBuiltinData . getDatum","taking-the-bet-pot#Taking the bet pot":"In this case we require the following four conditions:\nThis operation must occur after (inclusive) brpBetReveal time.\nThe script must get fully spend, i.e., there shouldn't be any continuing outputs to this script address.\nThe reference input whose datum is used to see actual answer should belong to concerned Oracle.\nGuess should be closest among all.\nThis is therefore coded as:\n    Take ->\n      let\n        Just guess = find ((== signerPkh) . fst) previousGuesses  -- Note that `find` returns the first match. Since we were always prepending, this is valid.\n        oracleIn = case filter (isNothing . txOutReferenceScript) (txInInfoResolved <$> txInfoReferenceInputs info) of\n          [oracleIn']    -> oracleIn'\n          []             -> traceError \"No reference input provided\"\n          _anyOtherMatch -> traceError \"Expected only one reference input\"\n        oracleAnswer = case outputToDatum oracleIn of\n          Nothing                                  -> traceError \"Could not resolve for datum\"\n          (Just (OracleAnswerDatum oracleAnswer')) -> oracleAnswer'\n        guessDiff = getGuessDiff $ snd guess\n        getGuessDiff (OracleAnswerDatum g) = abs (oracleAnswer - g)\n        oracleInPkh = case toPubKeyHash (txOutAddress oracleIn) of\n          Nothing  -> traceError \"Not PKH for oracle address\"\n          Just pkh -> pkh\n      in\n        traceIfFalse\n          \"Must be after `RevealTime`\"\n            (from betReveal `contains` validRange) &&\n        traceIfFalse\n          \"Must fully spend Script\"\n            (null (getContinuingOutputs ctx)) &&\n        traceIfFalse\n          \"Reference input must be from Oracle address (wrt Payment part)\"\n            (oracleInPkh == oraclePkh) &&\n        traceIfFalse\n          \"Guess is not closest\"\n            (all (\\pg -> getGuessDiff (snd pg) >= guessDiff) previousGuesses)\nAnd lo behold! This is our contract.For instance, here we assert that UTxO being used as reference input must belong to Oracle's address but do note that anyone can create an UTxO at Oracle's address."}},"/":{"title":"Index","data":{}},"/introduction":{"title":"Introduction","data":{"":"Atlas is an all-in-one, Haskell-native application backend for writing off-chain code for on-chain Plutus smart contracts. Atlas has been designed by Genius Yield, in collaboration with MLabs, Well-Typed and Plank.","features#Features":"","easily-build-transactions#Easily build transactions":"Use an intuitive API to abstract away the complexity around building transactions, balancing UTxOs, and interfacing with Plutus smart contracts.","leverage-first-class-haskell#Leverage first-class Haskell":"Write type-safe abstractions, harnessing the power & security of Haskell.","utilize-modular-data-providers#Utilize modular data providers":"Query ledger state information from remote provider such as Maestro, Blockfrost or from your own node with the help of Kupo. You can also build and contribute your own data provider!","test-extensively#Test extensively":"Use Atlas' test harness to write realistic test harness,\nwhich can be run against either an emulator or a private Cardano network. Atlas offers a unified testing approach and the same test code can seamlessly execute on both an emulated mock ledger and an actual private Cardano test network.","stay-up-to-date#Stay up to date":"Benefit from Cardano's latest innovations such as Governance Actions, Reference Inputs, Inline Datums, Reference Scripts, and so on.","where-to-next#Where to next?":"Work through an end-to-end example here: Getting Started.\nThis guide tracks the Atlas version 0.12.0."}},"/more-tutorials":{"title":"More Tutorials","data":{"vesting#Vesting":"See the introductory walkthrough of Atlas given by Dr. Lars using his with favourite example, Vesting, here. Associated code is available at atlas-examples repository."}},"/getting-started/testing":{"title":"Testing","data":{"":"Writing smart contracts and operations over them go hand in hand with testing them.Tests are also an excellent way to check your smart contracts\ninstead of building transactions using cardano-cli\nand submitting them to a local node.","levels-of-testing#Levels of testing":"Now that we have written our smart contracts and defined the required operations,\nlet's see whether they work as expected. When it comes to testing dApps there are\nplenty of techniques and approaches. Let's focus on levels at which we can\nperform testing:\nTesting of UPLC functions. You may want to verify that individual functions\nyour validators consist of, indeed hold some properties. This is\nuseful if your on-chain logic is convoluted and involves complex computations.\nThis level is tightly coupled to the language you use to build your smart contracts\nso you should consult the respective documentation.\nTesting of individual contracts (script level).\nYou might want to verify that the on-chain contracts you developed behave as expected\nin isolation just by calling them with hand-constructed arguments (like script context) since they are just functions after all\nand checking the results. Here again, you can use language-specific tools.\nBut in case your contracts are already compiled down to UPLC code,\nyou will need a special testing framework to do that.\nAtlas currently doesn't provide such a thing, but there exist some projects of help,\nnamely liqwid-context-builder\nfrom Liqwid's Libs mono repo. It allows one to easily construct various transaction contexts\nand verify a result that a particular script evaluates.\nTesting of operations (transactions).\nAt this level, one can execute whole operations (transactions)\nan application provides and verifies that they a) can run through and\nb) confirm that some conditions we are interested in are held.\nA nice thing to know about Atlas is that it allows you to reuse the code for operations\nyou created in the previous step, \"Operations over Contract\".\nThis is the level of testing we discuss in this section.\nYou can also make a distinction between testing individual transactions and\ntesting a flow of transactions, but in practice, it proves to be hard\nto prepare a hand-made environment for most intermediary transactions to be run in\nwithout running transactions that precede, so mostly it boils down\nto test the whole transaction flow.","overview-of-unified-testing-in-atlas#Overview of unified testing in Atlas":"Testing of whole operations (transactions) requires a Cardano ledger to evaluate them\nand keep the state.\nThere are two interchangeable options available in Atlas.\nWe will call them ledger backends throughout the rest of the section:\nCLB emulator\n(a modern replacement for deprecated PSM library)\nis the preferable way to test operations.\nIt's built around the pure Cardano ledger without the use of any network or consensus bits\nand offers incredibly high speed with a tiny memory footprint,\nbut with some functional limitations.\nYou can easily spin up a fresh emulator ledger for every test case,\nwhich makes running tests in isolation a trivial task.\nCardano private test network option (privnet for short) provides a more realistic environment.\nIt is a cluster of three cardano-node instances\nthat potentially could support all Cardano features,\nincluding staking and governance.\nThe main downside of a privnet is that testing time is significantly bigger and since spawning a testnet is a time-consuming operation, it's practically impossible to have a fresh network for every test case\nbut rather we prefer single testnet for the whole test suite run.\nBear in mind that the behavior of the CLB emulator and a Cardano private network differ.Not all features are supported in the emulator, and some notions, e.g. blocks and time\nis not represented enough in the emulator to carry out all tests.Fortunately, you can switch easily between two backends with unified testing.\nNow that we know what the two backends available are,\nlet's spend some time understanding what unified testing in Atlas offers.\nIf we dissect a test case within a test suite\nwe can identify the following things involved:\nAn application under testing, including:\nSmart contracts\nOperations, which usually prepare transactions (or their skeletons)\nDefinition of a test case, including:\nA prelude sequence of actions that prepare the state for a particular\noperation to be ready to be executed\nA condition that wraps an operation we are testing  in the test case\nand expresses checks we want to verify\nTest suite runtime:\nA ledger backend\nSome code to run a test case against a backend\nThe idea of unified testing pursues the goal of making items under (1) and (2) reusable\nacross different (currently, the two mentioned above) ledger backends.Let's run through an example test suite to get the idea and figure out its details.","testing-placing-a-bet#Testing placing a bet":"You can find the entire code for this example here.\nMind you we are using tasty to write tests.\nOur objective here would be to write test cases for one of two main operations\nfrom the bet-ref example - namely for placing bet operation.The test-suite given can be executed with cabal run betref-tests command. Do note that, in the initial setup, you would notice an initial test failure, this is due to a quirk in the workings of cardano-testnet when spinning up private testnet and should be ignored. Note that before running this command, make sure that you have required version of cardano-cli & cardano-node installed and available inside your path, use cabal install --package-env=$(pwd) --overwrite-policy=always cardano-cli cardano-node from the root of the atlas-examples repository to achieve that.","testing-environment#Testing environment":"Unified testing hides implementation details specific to ledger backends under\na layer of abstraction. Regardless of the backend we ultimately choose there is\nTestInfo datatype that provides access to user wallets among other things.\nA wallet is represented by User datatype that holds signing keys, address,\nand collateral to use:\ndata TestInfo = TestInfo\n  { testGoldAsset :: !GYAssetClass\n  , testIronAsset :: !GYAssetClass\n  , testWallets :: !Wallets }\ndata Wallets = Wallets\n    { w1 :: !User\n    ... more eighth wallets ...\n    }\ndata User = User\n    { userPaymentSKey     :: !GYPaymentSigningKey\n    , userStakeSKey       :: !(Maybe GYStakeSigningKey)\n    , userAddresses       :: !(NonEmpty GYAddress)\n    , userChangeAddress   :: !GYAddress\n    , userCollateral      :: Maybe UserCollateral\n    }\nEvery wallet in Wallets will be funded with an initial set of assets:\nMillion ADA.\nMillion fakeGold.\nMillion fakeIron.\nfakeGold and fakeIron are testing Cardano native assets that might be useful\n(though you can ignore them safely).In previous sections, we got acquainted with several monads available in Atlas\nnamely GYTxQueryMonad and GYTxMonad that allowed us to query the blockchain\nand to construct transactions. Now it's time to introduce another monad that\nfacilitates testing - GYTxGameMonad. Its most important action is called\nasUser and allows to run computations in GYTxMonad using a particular\nwallet (signature is slightly simplified):\nasUser :: User -> GYTxMonad a -> m a\nWe conventionally call actions in GYTxGameMonad \"runners\" since they run some\noperations by submitting them under a particular user. We will see examples soon.Then we have two functions that allow us to make a test case for a particular\nbackend out of a runner (the signature again is slightly modified here):\nmkTestFor :: TestName -> (TestInfo -> GYTxGameMonad a) -> TestTree\nmkPrivnetTestFor :: Setup -> TestName ->  (TestInfo -> GYTxGameMonad a) -> TestTree\nBoth functions take a name for a test case and a continuation function of type\nTestInfo -> GYTxGameMonad a. Then they internally generate the environment to\ndo the job. The difference is that mkPrivnetTestFor also takes a value of type\nSetup that contains information about an instance of a private network.\nThis highlights an important distinction between them:\nmkTestFor spawns a new instance of the emulator on every call - that way\nall test cases will be given with a fresh (new) blockchain ledger state having\nthe above balances to those 9 wallets.\nmkPrivnetTestFor is supposed to be run inside a helper function\nwithPrivnet which spins up a private testnet according to the configuration\nprovided and calls a series of test cases (i.e. the whole test suite) against it.\nLet's use these bits to build various test cases for operations\nwithin bet-ref example.","defining-runner-for-bet-placing-operation#Defining runner for bet placing operation":"Let's start with the runner to test placeBet operation. We won't see anything\nnew here. It just uses asUser action we just learned to run the operation.\nWe need values of all arguments that our operation takes. We cannot know them, so\nwe just take all of them as arguments to the runner itself, except the address as\nit can be obtained using ownAddresses function. This function  gives back all\nthe addresses of the wallet (User) that we provide to asUser.\nOnce we get the result of the operation, we can build, sign, and submit a transaction.\nHere, again, the wallet we specified to asUser action is used to sign it\n(though you can add additional signatures manually).\nLet's take a look at the code (you can find the full version in the sources,\nhere it's slightly redacted for simplicity).\n-- | Run to call the `placeBet` operation.\nrunPlaceBet\n  :: GYTxGameMonad m                   -- We write runners in `GYTxGameMonad` monad\n  => GYTxOutRef                        -- ^ Script output reference\n  -> BetRefParams                      -- ^ Parameters\n  -> OracleAnswerDatum                 -- ^ Bet guess\n  -> GYValue                           -- ^ Bet value\n  -> Maybe GYTxOutRef                  -- ^ Ref output with existing bets\n  -> User                              -- ^ User that plays bet\n  -> m GYTxId\nrunPlaceBet refScript brp guess bet mPrevBets user =\n  asUser user $ do\n    -- Get the address\n    addr <- maybeM (throwAppError $ someBackendError \"No own addresses\")\n      pure  $ listToMaybe <$> ownAddresses\n    -- Call the operation\n    skeleton <- placeBet refScript brp guess bet addr mPrevBets\n    -- Submit the transaction\n    buildTxBody skeleton >>= signAndSubmitConfirmed","additional-runners#Additional runners":"Let's take a look at the arguments our runner takes:\nrunPlaceBet\n  :: GYTxOutRef                        -- ^ Script output reference\n  -> BetRefParams                      -- ^ Parameters\n  -> OracleAnswerDatum                 -- ^ Bet guess\n  -> GYValue                           -- ^ Bet value\n  -> Maybe GYTxOutRef                  -- ^ Ref output with existing bets\n  -> User                              -- ^ User that plays bet\n  -> m GYTxId\nBet guess, value, existing bets, and the user that plays a bet pertain to the\ntest case, so we should somehow pick or generate values for them\n(we will just use some sensible values in this example).\nBut the first argument of type GYTxOutRef can't seem to be easy to know.\nIt's the transaction output reference (transaction hash and output index number)\nthat should contain a reference script on the ledger. To create it we need to build\nand submit another transaction.So we need another runner that applies the script to arguments, builds a transaction\nthat will deploy it, sign and submits it. Let's pretend we don't have such an operation\nto build a transaction to deploy within our application but what we have is\na function that makes the script. Notice the use GYTxQueryMonad here since all that function\nneeds is only to figure out the current slot in the ledger to make the calculations:\n-- | Queries the current slot, calculates the parameters, and builds\n-- a script that is ready to be deployed.\nmkScript\n  :: GYTxQueryMonad m\n  => Integer        -- ^ How many slots betting should be open\n  -> Integer        -- ^ How many slots should pass before oracle reveals answer\n  -> GYPubKeyHash   -- ^ Oracle PKH\n  -> GYValue        -- ^ Bet step value\n  -> m (BetRefParams, GYScript PlutusV2)\nmkScript betUntil betReveal oraclePkh betStep = do\n ... [the body is omitted] ...\nIt takes several parameters that define the process of betting,\ndoes some calculations, and gives us back all the parameters of type BetRefParams\nand also GYScript PlutusV2 which is the script we can deploy. So in this case\nwe have to build the transaction directly within the runner. Fortunately,\nwe can use addRefScript function that does exactly what we need:\n-- | Runner to build and submit a transaction that deploys the reference script.\nrunDeployScript\n  :: GYTxGameMonad m\n  => Integer                        -- ^ Bet Until slot\n  -> Integer                        -- ^ Bet Reveal slot\n  -> GYValue                        -- ^ Bet step value\n  -> Wallets\n  -> m (BetRefParams, GYTxOutRef)\nrunDeployScript betUntil betReveal betStep ws = do\n  (params, script) <- mkScript betUntil betReveal (userPkh $ oracle ws) betStep\n  asUser (admin ws) $ do\n    let sAddr = userAddr (holder ws)\n    refScript <- addRefScript sAddr script\n    pure (params, refScript)\nThis runner doesn't call any application operations, but now we can run it\nbefore our main runner runPlaceBet since it returns both BetRefParams\nand GYTxOutRef we need to call the main runner and ultimately placeBet\noperation.","place-first-bet-test#Place first bet test":"Now we are finally ready to write our first test.\nIt should first use runDeployScript to calculate and deploy the script\nand then run the main runner runPlaceBet\nchecking that a transaction goes through and the balance of the user\nthat submits it gets smaller accordingly\n(of course, we could imagine other checks as well).\n-- | Test for placing the first bet.\nfirstBetTest\n  :: GYTxGameMonad m\n  => Integer\n  -> Integer\n  -> GYValue\n  -> OracleAnswerDatum\n  -> GYValue\n  -> TestInfo\n  -> m ()\nfirstBetTest betUntil betReveal betStep dat bet (testWallets -> ws@Wallets{w1}) = do\n  (brp, refScript) <- runDeployScript betUntil betReveal betStep ws\n  withWalletBalancesCheckSimple [w1 := valueNegate bet] $ do\n    void $ runPlaceBet refScript brp dat bet Nothing w1\nThe code almost verbatim repeats what we just said using the function withWalletBalancesCheckSimple.\nIt allows checking the change of wallet's balance with no caring about transaction and storage fees\n(the latter is also known as minimal ADA - the number of coins that should accompany Cardano native tokens).\nThis convenience is possible because Atlas manages its own record of\nall fees that were spent over the course of tests, so they can be accounted\nautomatically. This way we just provide the expected delta in balance by negating\nbet's value. More precisely this function takes a list of tuples where the first element\nof the tuple is the wallet and the second element denotes the difference in\nthe wallet's value which we expect after the execution of the operation\ndefined inside its do block.\nHere we want the balance of wallet 1 (which is the one calling this operation)\nto decrease with the bet amount and also the fees.We specify all parameters when defining a test case:\nplaceBetTests :: TestTree\nplaceBetTests = testGroup \"Place Bet (Emulator)\"\n    [ mkTestFor \"Balance checks after placing first bet\" firstBetTest'\n    ]\nfirstBetTest' :: GYTxGameMonad m => TestInfo -> m ()\nfirstBetTest' = firstBetTest\n  40\n  100\n  (valueFromLovelace 200_000_000)\n  (OracleAnswerDatum 3)\n  (valueFromLovelace 20_000_000)","multiple-bets-test#Multiple bets test":"Now let's write a slightly more involved test. This time we want to make sure\nthat many bets placed in a raw using different wallets can be submitted and the\nbalances of the wallets change accordingly.Let's start with defining some additional type aliases to save up space:\n-- This is an alias for fields of `Wallet` datatype\ntype Wallet = Wallets -> User\n-- This type represent a bet made by a wallet\ntype Bet = (Wallet, OracleAnswerDatum, GYValue)\nNow we want to write a function mkMultipleBetsTest, we can pass a list\nof concrete bets to build a test case:\nmultipleBetsTest :: GYTxGameMonad m => TestInfo -> m ()\nmultipleBetsTest TestInfo{..} = mkMultipleBetsTest\n  400 1_000 (valueFromLovelace 10_000_000) -- game params\n  -- list of bets\n  [ (w1, OracleAnswerDatum 1, valueFromLovelace 10_000_000)\n  , (w2, OracleAnswerDatum 2, valueFromLovelace 20_000_000)\n  , (w3, OracleAnswerDatum 3, valueFromLovelace 30_000_000)\n  , (w2, OracleAnswerDatum 4, valueFromLovelace 50_000_000)\n  , (w4, OracleAnswerDatum 5, valueFromLovelace 65_000_000\n                                <> valueSingleton testGoldAsset 1_000)\n  ]\n  testWallets\nAs usual, let's commence with a runner. We already have a runner for placing a\nsingle bet so we can reuse it:\n-- | Runner for multiple bets.\nrunMultipleBets\n  :: GYTxGameMonad m\n  => BetRefParams\n  -> GYTxOutRef                 -- ^ Reference script\n  -> [Bet]\n  -> Wallets\n  -> m ()\nrunMultipleBets brp refScript bets ws = go bets True\n  where\n    go [] _ = return ()\n    go ((getWallet, dat, bet) : remBets) isFirst = do\n      if isFirst then do\n        gyLogInfo' \"\" \"placing the first bet\"\n        void $ runPlaceBet refScript brp dat bet Nothing (getWallet ws)\n        go remBets False\n      else do\n        gyLogInfo' \"\" \"placing a next bet\"\n        -- need to get previous bet utxo\n        betRefAddr <- betRefAddress brp\n        GYUTxO{utxoRef} <- head . utxosToList <$> utxosAtAddress betRefAddr Nothing\n        gyLogDebug' \"\" $ printf \"previous bet utxo: %s\" utxoRef\n        void $ runPlaceBet refScript brp dat bet (Just utxoRef) (getWallet ws)\n        go remBets False\nThe runner recursively traverses the list of bets, calling runPlaceBet on every\nelement, indicating whether it is the first element or not using the last\nparameter of go. Once we have the runner at hand we can write the test. We are\ngoing to skip some details to handle balances, you can find the full version in\nthe source code.\n-- | Makes a test case for placing multiple bets.\nmkMultipleBetsTest\n  :: GYTxGameMonad m\n  => Integer                 -- ^ Number of slots for betting\n  -> Integer                 -- ^ Number of slots for revealing\n  -> GYValue                 -- ^ Bet step\n  -> [Bet]                   -- ^ List denoting the bets\n  -> Wallets                 -- ^ Wallets available\n  -> m ()\nmkMultipleBetsTest betUntil betReveal betStep bets ws = do\n  -- Deploy script\n  (brp, refScript) <- runDeployScript betUntil betReveal betStep ws\n  -- Get the balance\n  balanceBefore <- getBalance\n  gyLogDebug' \"\" $ printf \"balanceBeforeAllTheseOps: %s\" (mconcat balanceBefore)\n  -- Run operations\n  runMultipleBets brp refScript bets ws\n  -- Get the balance again\n  balanceAfter <- getBalance\n  gyLogDebug' \"\" $ printf \"balanceAfterAllTheseOps: %s\" (mconcat balanceAfter)\n  -- Check the difference\n  verify $ zip3\n    walletsAndBets\n    balanceBefore\n    balanceAfter\n  where\n    ... some balance-related functions are omitted here ...\n    -- | Function to verify that the wallet indeed lost by /roughly/ the bet amount.\n    -- We say /roughly/ as fees is assumed to be within (0, 1 ada].\n    verify :: GYTxGameMonad m => [((User, GYValue), GYValue, GYValue)] -> m ()\n    verify [] = return ()\n    verify (((wallet, diff), vBefore, vAfter) : xs) =\n      let vAfterWithoutFees = vBefore <> diff\n          (expectedAdaWithoutFees, expectedOtherAssets) = valueSplitAda vAfterWithoutFees\n          (actualAda, actualOtherAssets) = valueSplitAda vAfter\n          threshold = 1_000_000  -- 1 ada\n      in\n        if expectedOtherAssets == actualOtherAssets\n            && actualAda < expectedAdaWithoutFees\n            && expectedAdaWithoutFees - threshold <= actualAda\n        then verify xs\n        else\n          throwAppError . someBackendError . T.pack $\n            printf \"For wallet %s expected value (without fees) %s but actual is %s\"\n              (show $ userAddr wallet)\n              (show vAfterWithoutFees)\n              (show vAfter)","writing-negative-tests#Writing negative tests":"But sometimes we want a test to fail! What happens if the newly placed bet is\nnot more than at least brpBetStep amount? What happens if the transaction\nskeleton is somewhat wrong, say we didn't put mustBeSignedBy? What if someone\ntries to place a bet after brpBetUntil? What if...Let's add another test:\nfailingMultipleBetsTest :: GYTxGameMonad m => TestInfo -> m ()\nfailingMultipleBetsTest TestInfo{..} = mkMultipleBetsTest\n  400 1_000 (valueFromLovelace 10_000_000)\n  [ (w1, OracleAnswerDatum 1, valueFromLovelace 10_000_000)\n  , (w2, OracleAnswerDatum 2, valueFromLovelace 20_000_000)\n  , (w3, OracleAnswerDatum 3, valueFromLovelace 30_000_000)\n  , (w2, OracleAnswerDatum 4, valueFromLovelace 50_000_000)\n  , (w4, OracleAnswerDatum 5, valueFromLovelace 55_000_000\n                                <> valueSingleton testGoldAsset 1_000)\n  ]\n  testWallets\nIf we run it we will get an error, since the last bet doesn't respect the minimal\nbet step which is 10_000_000 lovelaces. Well for all such cases, we can assert\nthat a given trace must fail. It's done slightly differently for the emulator and\na private test network. For the emulator we just use mustFail:\nplaceBetTestsClb :: TestTree\nplaceBetTestsClb = testGroup \"Place bet\"\n    [ mkTestFor \"Multiple bets - to small step\" $ mustFail . failingMultipleBetsTest\n    ]\nFor a private testnet it's more wordy:\nplaceBetTests :: Setup -> TestTree\nplaceBetTests setup = testGroup \"Place bet\"\n    [ mkPrivnetTestFor' \"Multiple bets - too small step\" GYDebug setup $\n        handleError\n          (\\case\n              GYBuildTxException GYBuildTxBodyErrorAutoBalance {} -> pure ()\n              e -> throwError e\n          )\n        . failingMultipleBetsTest\n    ]\nThis section concludes our journey to testing dApps with Atlas.If you were to have fine-grained control over balance change, use withWalletBalancesCheck instead.To convey the message better, we have a defined (:=) pattern synonym:\npattern (:=) :: x -> y -> (x, y)\npattern (:=) x y = (x, y)"}}}