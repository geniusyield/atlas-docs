{"/getting-started":{"title":"Getting Started","data":{"":"Learn the most important framework concepts in just few minutes by coding a complete end-to-end example."}},"/getting-started/browser-integration":{"title":"Browser Integration","data":{"":"Now that we have our server running, we need front-end UI to interact with it.For all of the operations, the approach (as previously mentioned) is same which is to first get the unsigned transaction from server, sign it in browser and then submit the signed transaction either directly from wallet or from server's submit endpoint.So essentially, we only have signing operation happening outside of our server-side code and operating in browser. To perform it, we make use of Cardano Multiplatform Lib and is a boilerplate for all of our operations.\nThe entire code pertaining to browser operations is available here.\n\nconst signAndSubmitTx = async (api: WalletApi, txCborHex: string): Promise<string> => {\n\nconsole.log('Unsigned transaction CBOR hex is ' + txCborHex);\n\n// Parse the base tx into the serialization lib model.\nconst transaction = C.Transaction.from_bytes(fromHex(txCborHex));\nconst txWitnessses = transaction.witness_set();\nconst txVKeyWitnesses = txWitnessses.vkeys() ?? C.Vkeywitnesses.new();\n\n// Get the user to sign the base tx in the browser via wallet.\nconst signedWitnessSet = C.TransactionWitnessSet.from_bytes(\nfromHex(await api.signTx(toHex(transaction.to_bytes()), true))\n);\n\n// Extract the vkey witnesses from the signing witness.\nconst walletVkeyWitnesses = signedWitnessSet.vkeys(); // This won't actually be nullish (CIP 30).\n\n// Combine the wallet vkey witnesses with any existing vkey witnesses.\nfor (let i = 0; i < walletVkeyWitnesses?.len() ?? 0; i++) {\ntxVKeyWitnesses.add(walletVkeyWitnesses.get(i));\n}\n\n// Overwrite the vkeys in the tx witnesses.\ntxWitnessses.set_vkeys(txVKeyWitnesses);\n\n// Compose the final tx.\nconst finalTx = C.Transaction.new(transaction.body(), txWitnessses, transaction.auxiliary_data());\n\n// Convert to cbor hex. You can submit this in the browser with `api.submitTx()` or using the submit endpoint at backend.\nconst finalTxCbor = toHex(finalTx.to_bytes());\nconsole.log('Final transaction CBOR is ' + finalTxCbor);\nreturn finalTxCbor;\n}\nWhere the api above was simply obtained from browser like so const api: WalletApi = await window.cardano[selectedWallet].enable();{:ts}. Creating a type such as WalletApi was entirely optional.An outline of this whole process is given below (actual body construction for this illustrative add-ref-script request can be seen in the given code):\nconst {data} = await axios.post('http://localhost:8081/betref/add-ref-script', body)\nconst finalTxCbor = await signAndSubmitTx(api, data.urspTxBodyHex)\n// txHash = await wallet.submitTx(finalTxCbor);  // alternate\nconst {data: submitData} = await axios.post('http://localhost:8081/tx/submit', finalTxCbor, {\nheaders: {\n'Content-Type': 'application/json'  // was inferred in previous `post`\n}\n})\nconsole.log(submitData)\nWhat follows is the demo for all of the operations we defined.\nIn case the requests get blocked by browser, try running this page locally, instructions for which are available here.\n\nAnd with this, we come to an end of our Getting Started guide ðŸ¥³! Hope you enjoyed it ðŸ’™\n\nHave questions? Ask them at Cardano StackExchange."}},"/getting-started/endpoints":{"title":"Creating Endpoints","data":{"":"Now that we are confident with our smart contract, it's time that we make it accessible to end user.The approach here would be that front-end will first ask us for the unsigned transaction body by giving us the relevant parameters needed to construct it. Then front-end will get this transaction body signed in browser to obtain signed transaction body which it will then submit either via browser wallet's endpoint or via calling the submit endpoint which we will define here.We'll use Servant to create our endpoints and one may understand it by following their easy to understand tutorial here.\nDo note that we can also sign the transactions in server using the signTx function defined in TxBody.hs","providing-data-provider#Providing Data Provider":"","defining-provider-configuration#Defining Provider Configuration":"As noted earlier, building transaction bodies require gathering suitable information from the blockchain. For this purpose, we'll require a provider. Atlas is unopinionated and allows user to plug in provider of their choice, including a locally hosted one.Currently Atlas supports the following providers (& it would be highly appreciated if community enriches this by contributing to Atlas):\nMaestro.\nLocally ran node.\nCardano DB Sync (but only for private network tests).\n\nTo provide information about the provider, we will create a config.json file whose contents could be as follows:\nWe have given a sample config.json file here.\n\n\n\n{\n\"coreProvider\": { \"maestroToken\": \"<Your-API-Key>\" },\n\"networkId\": \"testnet-preprod\",\n\"logging\": [{ \"type\": { \"tag\": \"stderr\" }, \"severity\": \"Debug\", \"verbosity\": \"V2\" }],\n\"utxoCacheEnable\": false\n}\n\n\n\n{\n\"coreProvider\": { \"socketPath\": \"<Path-To-node.socket-File>\", \"maestroToken\": \"<Your-API-Key>\" },\n\"networkId\": \"testnet-preprod\",\n\"logging\": [{ \"type\": { \"tag\": \"stderr\" }, \"severity\": \"Debug\", \"verbosity\": \"V2\" }],\n\"utxoCacheEnable\": false\n}\n\n\nHere is the explaination for each of the JSON keys above:\ncoreProvider: This field is the differentiating factor between different providers. Above we have given how it would look like for locally ran node & Maestro. Note that local node option still requires Maestro key for lookupDatum query.\nnetworkId: Specifies your network and must be one of mainnet, testnet-preprod, testnet-preview, testnet (for legacy testnet) & privnet (for local private network).\nlogging: It's a list of scribes to register. Its parameters (like severity, verbosity) and its general usage can be understood by going over their official haddock documentation here. Katip is also explained in this book on web development in Haskell.\nutxoCacheEnable: Enabling this boolean will enable cache (using Data.Cache) whereby queries related to fetching UTxOs won't generate call to provider if the entry exists in cache (& has not yet expired).","parsing-given-configuration#Parsing Given Configuration":"The file server-main.hs fires up our server. It reads & parses the configuration file and using it makes our endpoints (which we will define shortly) available. Here is its entire code.\n-- | Getting path for our core configuration.\nparseArgs :: IO FilePath\nparseArgs = do\nargs <- getArgs\ncase args of\ncoreCfg: _ -> return coreCfg\n_invalidArgument -> fail \"Error: wrong arguments, needed a path to the CoreConfig JSON configuration file\\n\"\n\nmain :: IO ()\nmain = do\nputStrLn \"Writing Swagger file ...\"\nBL8.writeFile \"swagger-api.json\" (encodePretty apiSwagger)\n\nputStrLn \"parsing Config ...\"\ncoreCfgPath <- parseArgs\ncoreCfg <- coreConfigIO coreCfgPath  -- Parsing our core configuration.\n\nputStrLn \"Loading Providers ...\"\nwithCfgProviders coreCfg \"api-server\"  $ \\providers -> do\nlet port = 8081\nctx = Ctx coreCfg providers\nputStrLn $ \"Starting server at \\n \" <> \"http://localhost:\" <> show port\nrun port $ app ctx\n\n\napp :: Ctx -> Application\napp ctx = cors (const $ Just simpleCorsResourcePolicy { corsRequestHeaders = [HttpTypes.hContentType] }) $ serve appApi $ hoistServer appApi (Handler . ExceptT . try)  $ apiServer ctx\nFocussing on the highlighted lines, you can see that it first reads the path to the configuration file (you would for instance run this file like so cabal run betref-server -- config.json) in line coreCfgPath <- parseArgs{:haskell}, then it parses this file coreCfg <- coreConfigIO coreCfgPath{:haskell}.We then see the use of an interesting function withCfgProviders. It's type is withCfgProviders :: GYCoreConfig  -> GYLogNamespace -> (GYProviders -> IO a) -> IO a{:haskell}, thus, this function first takes our parsed configuration file, then a namespace, finally followed by a continuation GYProviders -> IO a. Idea here is that this function will setup a GYProviders from the parsed configuration file and send it to this continuation to obtain its result.","defining-endpoints#Defining Endpoints":"","shared-context#Shared Context":"Entire code for it is available here\nOur endpoints would need an information for our provider, thus we have created the type for it, called Ctx. It's usage is made clear by function defined next, runQuery which in essence correspond to ctxRunC we saw in section on Integration Tests. Reasoning for runTxI, runTxF & runTxWithStrategyF follows similarly.\n-- | Our Context.\ndata Ctx = Ctx\n{ ctxCoreCfg   :: !GYCoreConfig\n, ctxProviders :: !GYProviders\n}\n\n-- | To run for simple queries, the one which don't requiring building for transaction skeleton.\nrunQuery :: Ctx -> GYTxQueryMonadNode a -> IO a\nrunQuery ctx q = do\nlet nid       = cfgNetworkId $ ctxCoreCfg ctx\nproviders = ctxProviders ctx\nrunGYTxQueryMonadNode nid providers q\n\n-- | Wraps our skeleton under `Identity` and calls `runTxF`.\nrunTxI :: Ctx\n-> [GYAddress]     -- ^ user's used addresses\n-> GYAddress       -- ^ user's change address\n-> GYTxOutRefCbor  -- ^ user's collateral\n-> GYTxMonadNode (GYTxSkeleton v)\n-> IO GYTxBody\nrunTxI = coerce (runTxF @Identity)\n\n-- | Tries to build for given skeletons wrapped under traversable structure.\nrunTxF :: Traversable t\n=> Ctx\n-> [GYAddress]     -- ^ user's used addresses\n-> GYAddress       -- ^ user's change address\n-> GYTxOutRefCbor  -- ^ user's collateral\n-> GYTxMonadNode (t (GYTxSkeleton v))\n-> IO (t GYTxBody)\nrunTxF = runTxWithStrategyF GYRandomImproveMultiAsset\n\n-- | Create 'TxBody' from a 'GYTxSkeleton', with the specified coin selection strategy.\nrunTxWithStrategyF :: Traversable t\n=> GYCoinSelectionStrategy\n-> Ctx\n-> [GYAddress]\n-> GYAddress\n-> GYTxOutRefCbor\n-> GYTxMonadNode (t (GYTxSkeleton v))\n-> IO (t GYTxBody)\nrunTxWithStrategyF cstrat ctx addrs addr collateral skeleton  = do\nlet nid       = cfgNetworkId $ ctxCoreCfg ctx\nproviders = ctxProviders ctx\nrunGYTxMonadNodeF cstrat nid providers addrs addr (getTxOutRefHex collateral) skeleton","submit-endpoint#Submit Endpoint":"Entire code for it is available here\nWe'll soon see endpoints which will return for unsigned transaction to the browser but assuming that we already have a signed transaction CBOR, let's see how we can define an endpoint to submit it using our provider.Focussing at handleSubmitTx function, we see that we first parse the obtained CBOR text in our GYTx type, then we simply call the submit operation for our providor. Then we send back the response letting our front-end know about the transaction fees (which though it would already know when having performed the signing operation, but other fields could also be added here depending upon use case) and the transactoin id.\n-- | Return type of API when submitting a transaction.\ndata SubmitTxResponse = SubmitTxResponse\n{ submitTxFee :: !Integer\n, submitTxId  :: !GYTxId\n} deriving (Show, Generic, ToJSON, Swagger.ToSchema)\n\n-- | Construct `SubmitTxResponse` return type from the given signed transaction body.\ntxBodySubmitTxResponse :: GYTxBody -> SubmitTxResponse\ntxBodySubmitTxResponse txBody = SubmitTxResponse\n{ submitTxFee = txBodyFee txBody\n, submitTxId  = txBodyTxId txBody\n}\n\n-- | Type for our Servant API.\ntype TxAPI =\n\"submit\" :> ReqBody '[JSON] GYTx :> Post '[JSON] SubmitTxResponse\n\n-- | Serving our API.\nhandleTx :: Ctx -> ServerT TxAPI IO\nhandleTx = handleSubmitTx\n\n-- | Handle for submit operation.\nhandleSubmitTx :: Ctx -> GYTx -> IO SubmitTxResponse\nhandleSubmitTx ctx tx = do\nvoid (gySubmitTx (ctxProviders ctx) tx)\nreturn $ txBodySubmitTxResponse (getTxBody tx)","transaction-building-endpoints#Transaction Building Endpoints":"Entire code for it is available here\nAt this point, it should be easy to follow the code here. We first define the input type for our endpoint, we also derive its FromJSON instance so that we can parse it from JSON that our front-end will send for it and we also derive its Swagger.ToSchema instance so as to document our endpoint. Then our endpoint calls the relevant operation which we defined before to get transactoin skeleton, using which we obtain the transaction body with the help of functions such as runTxI and return the result (wrapped in our UnsignedTxResponse type).\nYou can see that all of our endpoints here ask for a list of used addresses, this makes them compatible with wallets that are not in single address mode (by default) such as Eternl.\n\n-- | Input wrapper around corresponding Plutus type.\ndata BetRefParams = BetRefParams\n{ brpOracleAddress :: !GYAddress\n, brpBetUntil      :: !GYTime\n, brpBetReveal     :: !GYTime\n, brpBetStep       :: !GYValue\n} deriving(Show, Generic, FromJSON, Swagger.ToSchema)\n\n-- | Convert the above `BetRefParams` with corresponding representation defined in our Plutus validator script.\nbetParamsToScript :: BetRefParams -> Script.BetRefParams\nbetParamsToScript brp = Script.BetRefParams\n{ Script.brpOraclePkh = pubKeyHashToPlutus $ fromJust $ addressToPubKeyHash $ brpOracleAddress brp\n, Script.brpBetUntil = timeToPlutus $  brpBetUntil brp\n, Script.brpBetReveal = timeToPlutus $ brpBetReveal brp\n, Script.brpBetStep = valueToPlutus $  brpBetStep brp\n}\n\n-- | Input parameters for place bet operation.\ndata PlaceBetRefParams = PlaceBetRefParams\n{ pbrUsedAddrs  :: ![GYAddress]\n, pbrChangeAddr :: !GYAddress\n, pbrCollateral :: !GYTxOutRefCbor\n, pbrBetParams  :: !BetRefParams\n, pbrBetGuess   :: !Integer\n, pbrBetAmt     :: !GYValue\n, pbrRefScript  :: !GYTxOutRef\n, pbrPrevBetRef :: !(Maybe GYTxOutRef)\n} deriving (Show, Generic, FromJSON, Swagger.ToSchema)\n\n-- | Input parameters for take bets operation.\ndata TakeBetRefParams = TakeBetRefParams\n{ tbrUsedAddrs         :: ![GYAddress]\n, tbrChangeAddr        :: !GYAddress\n, tbrCollateral        :: !GYTxOutRefCbor\n, tbrBetParams         :: !BetRefParams\n, tbrRefScript         :: !GYTxOutRef\n, tbrPrevBetRef        :: !GYTxOutRef\n, tbrOracleRefInputRef :: !GYTxOutRef\n} deriving (Show, Generic, FromJSON, Swagger.ToSchema)\n\n-- | Input parameters to add for reference script.\ndata AddRefScriptParams = AddRefScriptParams\n{ arsUsedAddrs  :: ![GYAddress]\n, arsChangeAddr :: !GYAddress\n, arsCollateral :: !GYTxOutRefCbor\n, arsPutAddress :: !GYAddress\n, arsBetParams  :: !BetRefParams\n} deriving (Show, Generic, FromJSON, Swagger.ToSchema)\n\n-- | Input parameters to add for reference input.\ndata AddRefInputParams = AddRefInputParams\n{ ariUsedAddrs  :: ![GYAddress]\n, ariChangeAddr :: !GYAddress\n, ariCollateral :: !GYTxOutRefCbor\n, ariPutAddress :: !GYAddress\n, ariBetAnswer  :: !Integer\n} deriving (Show, Generic, FromJSON, Swagger.ToSchema)\n\n-- | Return type for our API endpoints defined here.\ndata UnsignedTxResponse = UnsignedTxResponse\n{ urspTxBodyHex  :: !T.Text           -- ^ Unsigned transaction cbor.\n, urspTxFee      :: !(Maybe Integer)  -- ^ Tx fees.\n, urspUtxoRefIdx :: !(Maybe Word)     -- ^ Some operations might need to show for relevant UTxO generated, this index will let UI know of it. Note that Transaction ID would change after getting signed.\n} deriving (Show, Generic, FromJSON, ToJSON, Swagger.ToSchema)\n\n-- | Construct `UnsignedTxResponse` return type for our endpoint given the transaction body & relevant index for UTxO (if such exists).\nunSignedTxWithFee :: GYTxBody -> Maybe Word -> UnsignedTxResponse\nunSignedTxWithFee txBody mUtxoRefIdx = UnsignedTxResponse\n{ urspTxBodyHex  = T.pack $ txToHex $ unsignedTx txBody\n, urspTxFee      = Just $ txBodyFee txBody\n, urspUtxoRefIdx = mUtxoRefIdx\n}\n\n-- | Type for our Servant API.\ntype BetRefApi =\n\"place\"\n:> ReqBody '[JSON] PlaceBetRefParams\n:> Post    '[JSON] UnsignedTxResponse\n:<|> \"take\"\n:> ReqBody '[JSON] TakeBetRefParams\n:> Post    '[JSON] UnsignedTxResponse\n:<|> \"add-ref-script\"\n:> ReqBody  '[JSON] AddRefScriptParams\n:> Post     '[JSON] UnsignedTxResponse\n:<|> \"add-ref-input\"\n:> ReqBody  '[JSON] AddRefInputParams\n:> Post     '[JSON] UnsignedTxResponse\n\n-- | Serving our API.\nhandleBetRefApi :: Ctx -> ServerT BetRefApi IO\nhandleBetRefApi ctx =   handlePlaceBet ctx\n:<|> handleTakeBet ctx\n:<|> handleAddRefScript ctx\n:<|> handleOracleRefInput ctx\n\n-- | Handle for place bet operation.\nhandlePlaceBet :: Ctx -> PlaceBetRefParams -> IO UnsignedTxResponse\nhandlePlaceBet ctx PlaceBetRefParams{..} = do\nlet brp = betParamsToScript pbrBetParams\nvalidatorAddress <- runQuery ctx (betRefAddress brp)\ntxBody <- runTxI ctx pbrUsedAddrs pbrChangeAddr pbrCollateral\n$ placeBet pbrRefScript (betParamsToScript pbrBetParams) (Script.OracleAnswerDatum pbrBetGuess) pbrBetAmt (head pbrUsedAddrs) pbrPrevBetRef\nplaceUtxoRef <- case find (\\utxo -> utxoAddress utxo == validatorAddress) $ utxosToList $ txBodyUTxOs txBody of\nNothing -> fail \"Shouldn't happen: No reference for placed bet in body\"\nJust utxo -> pure $ utxoRef utxo\npure $ unSignedTxWithFee txBody (Just $ snd $ txOutRefToTuple placeUtxoRef)\n\n-- | Handle for take bets operation.\nhandleTakeBet :: Ctx -> TakeBetRefParams -> IO UnsignedTxResponse\nhandleTakeBet ctx TakeBetRefParams{..} = do\ntxBody <- runTxI ctx tbrUsedAddrs tbrChangeAddr tbrCollateral\n$ takeBets tbrRefScript (betParamsToScript tbrBetParams) tbrPrevBetRef (head tbrUsedAddrs) tbrOracleRefInputRef\npure $ unSignedTxWithFee txBody Nothing\n\n-- | Handle for adding reference script.\nhandleAddRefScript :: Ctx -> AddRefScriptParams  -> IO UnsignedTxResponse\nhandleAddRefScript  ctx AddRefScriptParams{..} = do\nlet validator = betRefValidator' (betParamsToScript arsBetParams)\ntxBody <- runTxI ctx arsUsedAddrs arsChangeAddr arsCollateral\n$ pure $ addRefScript' arsPutAddress validator\nlet refs   = Limbo.findRefScriptsInBody txBody\noutRef <- case Map.lookup (Some (validatorToScript validator)) refs of\nNothing  -> fail \"Shouldn't happen: No reference for added Script in body\"\nJust ref -> return ref\npure $ unSignedTxWithFee txBody (Just $ snd $ txOutRefToTuple outRef)\n\n-- | Handle for adding reference input.\nhandleOracleRefInput :: Ctx -> AddRefInputParams  -> IO UnsignedTxResponse\nhandleOracleRefInput  ctx AddRefInputParams{..} = do\nlet ourDatumPlutus = Script.OracleAnswerDatum ariBetAnswer\nourDatumGY = datumFromPlutusData ourDatumPlutus\ntxBody <- runTxI ctx ariUsedAddrs ariChangeAddr ariCollateral\n$ pure $ addRefInput' ariPutAddress ourDatumPlutus\nlet utxos = utxosToList $ txBodyUTxOs txBody\nourDatumHash = hashDatum ourDatumGY\nmRefInputUtxo = find (\\utxo ->\ncase utxoOutDatum utxo of\nGYOutDatumHash dh  -> ourDatumHash == dh\nGYOutDatumInline d -> ourDatumGY == d\nGYOutDatumNone     -> False\n) utxos\ncase mRefInputUtxo of\nNothing               -> fail \"Shouldn't happen: Couldn't find the desired UTxO in Tx outputs\"\nJust GYUTxO {utxoRef} -> pure $ unSignedTxWithFee txBody (Just $ snd $ txOutRefToTuple utxoRef)","wrap-up#Wrap-Up":"Our both the endpoints file (transaction submition & transaction building) our wrapped up in our Api.hs following the usual servant boilerplate.\n-- | Type for our Servant API.\ntype Api =\n\"tx\"  :> TxAPI\n:<|>  \"betref\" :>  BetRefApi\n\nappApi :: Proxy Api\nappApi = Proxy\n\napiSwagger  :: Swagger\napiSwagger  = toSwagger appApi\n\napiServer :: Ctx -> ServerT Api IO\napiServer ctx =\nhandleTx ctx\n:<|> handleBetRefApi ctx\nNow coming back to our server-main.hs file, we can now understand the highlighted code sections which relates to obtaining the Swagger file (generated from apiSwagger function above) and running up our servant server.\nWe follow simpleCorsResourcePolicy (also allowing Content-Type request header) so that calls by our front-end (which runs on different origin) don't get blocked.\n\n-- | Getting path for our core configuration.\nparseArgs :: IO FilePath\nparseArgs = do\nargs <- getArgs\ncase args of\ncoreCfg: _ -> return coreCfg\n_invalidArgument -> fail \"Error: wrong arguments, needed a path to the CoreConfig JSON configuration file\\n\"\n\nmain :: IO ()\nmain = do\nputStrLn \"Writing Swagger file ...\"\nBL8.writeFile \"swagger-api.json\" (encodePretty apiSwagger)\n\nputStrLn \"parsing Config ...\"\ncoreCfgPath <- parseArgs\ncoreCfg <- coreConfigIO coreCfgPath  -- Parsing our core configuration.\n\nputStrLn \"Loading Providers ...\"\nwithCfgProviders coreCfg \"api-server\"  $ \\providers -> do\nlet port = 8081\nctx = Ctx coreCfg providers\nputStrLn $ \"Starting server at \\n \" <> \"http://localhost:\" <> show port\nrun port $ app ctx\n\n\napp :: Ctx -> Application\napp ctx = cors (const $ Just simpleCorsResourcePolicy { corsRequestHeaders = [HttpTypes.hContentType] }) $ serve appApi $ hoistServer appApi (Handler . ExceptT . try)  $ apiServer ctx\nNext we'll see how to call these endpoints in our front-end!"}},"/getting-started/integration-tests":{"title":"Integration Tests","data":{"":"We already saw how we can conveniently write tests for our smart contract using our wrapper upon Plutus simple model. But these tests were running against a mock ledger, i.e., we really were just simulating it by having some mock data-structures (say set of UTxOs) which were getting updated on submission of successful transaction. We could however write tests to test against the real node and have it slightly more convenient to program against by spinning up our own private network (privnet for short). Here is the table which outlines the differences between the two approaches:\nTests using PSM Wrapper\tTests using Private Network\tRuns against mock ledger\tRuns against real node\tEach unit test gets fresh set of wallets (having original balance)\tEach subsequent unit test continues upon the effects caused by previous ones\tFast, purer (no IO) & convenient\tSlow as each slot is 0.1 second\nThus these tests are suitable for integration testing.","spinning-up-private-network#Spinning up private network":"Our private network is adapted from WoofPool's cardano-private-testnet-setup repository.To spin up it up:\nClone this repository. Make sure to not clone it in some deep nested path as then the path length towards the generated socket file (node.sock) may exceed 108 characters.\nEnter it & checkout geniusyield branch.\nEnter the following in terminal: ./scripts/automate.sh (you would need to have cardano-node & cardano-cli available in your PATH).\n\nOnce it says, \"Congrats! Your network is ready for use!\" you can attempt to run the tests (in another terminal).First, let's say the path to private-testnet-simple is X, then being inside your example project folder, you can execute the tests by running GENIUSYIELD_PRIVNET_DIR=$X/private-testnet cabal run betref-privnet-tests -- -j1The -j1 is needed so that the tests run sequentially.\nRemember to stop (CTRL-C, and killall cardano-node) the private testnet, or it will eventually eat all of your disk space.\nThe way we have it setup for our test boilerplate is that we have three users where second and third user have the following balances:\n5 UTxOs each containing thousand ada\n1 million each of gold & iron tokens\n\n\"User 1\" UTxOs list isn't that clean but does include 5 UTxOs each containing roughly thousand ada plus some other UTxOs containing a lot more ada. Also User 1 has 3 million each of gold & iron tokens.We'll see how to create a new user soon.\nUnless you kill & restart the private network, running your privnet tests again, would have them run in the modified network state. So in general, if you wish to reexecute the command mentioned before, viz. ATLAS_PRIVNET_DIR=$(pwd)/private-testnet-simple/private-testnet cabal run privnet-tests -- -j1, you should first restart the privnet.","understanding-our-first-test#Understanding our first test":"The tests are written in this file and are being called here.\nHere is the code (& explaination follows after it):\ntestCaseSteps \"Balance checks & taking pot by closest guesser should pass\" $ \\info -> withSetup setup info $ \\ctx -> do\n\n-- First step: Construct the parameters and obtain validator from it.\n--\n-- Let's define a new User to represent Oracle (not necessary though)\noracleUser <- newTempUserCtx ctx User1 (valueFromLovelace 20_000_000)\n(currentSlot, slotConfig) <- getSlotAndConfig ctx\nlet betUntilSlotDelta = 100\nbetRevealSlotDelta = 200\nbetUntilTime = slotToBeginTimePure slotConfig (unsafeAdvanceSlot currentSlot betUntilSlotDelta)\nbetRevealTime = slotToBeginTimePure slotConfig (unsafeAdvanceSlot currentSlot betRevealSlotDelta)\nbrp = BetRefParams (pubKeyHashToPlutus $ userPkh oracleUser) (timeToPlutus betUntilTime) (timeToPlutus betRevealTime) (valueToPlutus $ valueFromLovelace 10_000_000)\nvalidator = betRefValidator' brp\nvalidatorAddress <- ctxRunC ctx User1 $ betRefAddress brp\n-- Second step: Putting reference script for validator.\nrefScript <- addRefScriptCtx ctx User1 (validatorToScript validator)\nthreadDelay 1_000_000\n-- Third step: Put some bets.\n--\n-- 1st bet.\ntxBodyLock <- ctxRunI ctx User1 $ placeBet refScript brp (OracleAnswerDatum 1) (valueFromLovelace 10_000_000) (ctxUserAddr ctx User1) Nothing\nlockedORef <- findOutput validatorAddress txBodyLock\nvoid $ submitTx ctx User1 txBodyLock\nthreadDelay 1_000_000\n\n--\n-- 2nd bet.\ntxBodyLock <- ctxRunI ctx User2 $ placeBet refScript brp (OracleAnswerDatum 2) (valueFromLovelace 20_000_000) (ctxUserAddr ctx User2) (Just lockedORef)\nlockedORef <- findOutput validatorAddress txBodyLock\nvoid $ submitTx ctx User2 txBodyLock\nthreadDelay 1_000_000\n--\n-- 3rd bet.\ntxBodyLock <- ctxRunI ctx User1 $ placeBet refScript brp (OracleAnswerDatum 3) (valueFromLovelace 35_000_000) (ctxUserAddr ctx User1) (Just lockedORef)\nlockedORef <- findOutput validatorAddress txBodyLock\nvoid $ submitTx ctx User1 txBodyLock\nthreadDelay 1_000_000\n\n-- Fourth step, get the bets pot.\n--\n-- Let's first wait for the required amount\nctxWaitUntilSlot ctx (unsafeAdvanceSlot currentSlot betRevealSlotDelta)  -- here this `currentSlot` is what we obtained sometime ago, the actual current slot has certainly increased a lot by now.\n--\n-- Let's then add for the reference input\nrefInputORef <- addRefInputCtx ctx User1 True (userAddr oracleUser) (datumFromPlutusData (OracleAnswerDatum 2))\nthreadDelay 1_000_000\n--\n-- Balance of `User2` before unlocking\nbalance <- ctxQueryBalance ctx User2\n--\n-- Unlock operation\ntxBodyUnlock <- ctxRunI ctx User2 $ takeBets refScript brp lockedORef (ctxUserAddr ctx User2) refInputORef\nvoid $ submitTx ctx User2 txBodyUnlock\nthreadDelay 1_000_000\n--\n-- Balance of `User2` after unlocking\nbalance' <- ctxQueryBalance ctx User2\nlet diff = valueMinus balance' balance\nadaChange = fst $ valueSplitAda diff  -- should be withing [65 ada - max-fee, 65 ada)\nadaExpectedIncrease = 65_000_000\nmaxFee = 1_000_000\nassertBool \"User2 ada increase must be b/w [adaExpectedIncrease - maxFee, adaExpectedIncrease)\"\n$ adaExpectedIncrease - maxFee <= adaChange && adaChange < adaExpectedIncrease\nThe first line testCaseSteps \"test description\" $ \\info -> withSetup setup info $ \\ctx -> do can be seen as a boilerplate for all of your tests.ctx denotes the so called context (of type Ctx) and contains information about our users, additional tokens, etc. It is defined in Ctx.hs file and it is essential to go over that file if you intend to write these tests.Variable info is used to log messages and you can use it in your test's do block like info $ printf \"Hello from %s\" \"Atlas\"We next see the use of newTempUserCtx utility function. As mentioned before, we already have three users in our context, where they have the type User:\ndata User = User\n{ userSKey :: !GYPaymentSigningKey\n, userAddr :: !GYAddress\n, userColl :: !GYTxOutRef\n}\n\nWe also have a type UserIdx defined for these three users:\ndata UserIdx\n= User1\n| User2\n| User3\n\nBut at rare times, we might need to create a new user. Such a user would not be part of the context and thus would be local to the test creating it.We can do that with the help of newTempUserCtx function. It accepts the context parameter, the index for the user which will fund this new user and the value to be given to this new user. Note that internally it will create two UTxOs for this new user, where one would be for collateral and will take 5 ada from the given value.Next we see the use of getSlotAndConfig function. Earlier when we wrote for PSM tests, we could work in absolute slots as we were always running each test from the beginning of ledger but this is not the case here. Thus, we would need to work with relative slots, i.e., we find the current slot and then add offset with respect to it. Function getSlotAndConfig has the folowing definition:\ngetSlotAndConfig :: Ctx -> IO (GYSlot, GYSlotConfig)\ngetSlotAndConfig ctx = do\nslot <- ctxCurrentSlot ctx\nsc   <- ctxSlotConfig ctx\nreturn (slot, sc)\nNext we compute for our contract parameters and since we already obtained the slot config, we can use slotToBeginTimePure instead of slotToBeginTime.We next see the use of ctxRunC. To understand it, we need to first look at signature of ctxRunF.\nctxRunF :: forall t v. Traversable t => Ctx -> UserIdx -> ReaderT GYCompiledScripts GYTxMonadNode (t (GYTxSkeleton v)) -> IO (t GYTxBody)\nWe see that it has a type variable t which should have an instance of Traversable. The other two functions, namely ctxRunC & ctxRunI call this ctxRunF function with suitable instantiation of type variable t.Here is the table which explains about these three (ctxRunF, ctxRunC & ctxRunI) related functions:\nFunction\tWhen to use?\tWhat does it do?\tctxRunI\tWhen you want to build for single GYTxSkeleton\tIt wraps our skeleton under Identity, that is what suffix I stands for\tctxRunF\tWhen you have say multiple skeletons, like [GYTxSkeleton], or Maybe GYTxSkeleton\t-\tctxRunC\tWhen you don't want to build skeletons. This is in particular useful for operations like utxosAtAddress\tThe type constructor Const is defined as newtype Const a b = Const { getConst :: a } and therefore type parameter b is phantom and thus this function helps us ignore for GYTxSkeleton\nWe next add for reference script using helper utility function addRefScriptCtx.We then start placing our bets, once we have the transaction body, we use findOutput function which gives us the reference to the UTxO (the first one it finds) that is being locked at the script address. We use threadDelay 1_000_000 to wait for one second so that our transaction is added to the blockchain.After placing our bets, we use ctxWaitUntilSlot to wait till the unlock slot.We next add for our reference input using addRefInputCtx helper utility function.Now before performing the unlock operation, we query the balance of unlocker so that we can compare with it later using ctxQueryBalance function.Next we perform the unlock operation (calling our takeBets operation).Lastly, we verify that the unlocker was able to take all the bets by comparing the balance.\nThere exists a helper function in Asserts.hs for what we did in the last step, i.e., to see that our expected value matches the actual considering fees, here is its definition:\n{- Asserts if the user funds change as expected.\nThe `fees` argument is an estimation for the transaction fees.\n-}\nassertUserFunds :: Integer -> Ctx -> UserIdx -> GYValue -> IO ()\nassertUserFunds fees ctx uid expectedValue = do\ncurrentValue <- ctxQueryBalance ctx uid\nlet (cLovelace, cAssets) = valueSplitAda currentValue\n(eLovelace, eAssets) = valueSplitAda expectedValue\nassertBool (unwords [\"The non-Ada token didn't change as expected\",\n\"\\nExpected: \", show eAssets,\n\"\\nCurrent: \", show cAssets])\n(cAssets == eAssets)\nassertBool (unwords [\"The lovelaces didn't change as expected,\",\n\"\\nExpected: \", show eLovelace,\n\"\\nCurrent: \", show cLovelace])\n((cLovelace + fees >= eLovelace) &&\n(cLovelace < eLovelace))","writing-a-failing-test#Writing a failing test":"Now let's see another test where we slightly modify the last step (all the rest is same) and this time we instead try to take funds by not the closest guesser.\n-- Fourth step, get the bets pot.\n--\n-- Let's first wait for the required amount\nctxWaitUntilSlot ctx (unsafeAdvanceSlot currentSlot betRevealSlotDelta)  -- here this `currentSlot` is what we obtained sometime ago, the actual current slot has certainly increased a lot by now.\n--\n-- Let's then add for the reference input\nrefInputORef <- addRefInputCtx ctx User1 True (userAddr oracleUser) (datumFromPlutusData (OracleAnswerDatum 2))\nthreadDelay 1_000_000\n--\n-- Unlock operation\n-- But this time by wrong guesser\nassertThrown isTxBodyErrorAutoBalance $ ctxRunI ctx User1 $ takeBets refScript brp lockedORef (ctxUserAddr ctx User1) refInputORef\nNotice that we try catching the error using assertThrown function. Here isTxBodyErrorAutoBalance is defined as (both this & assertThrown have their definitions in Asserts.hs file):\nisTxBodyErrorAutoBalance :: BuildTxException -> Bool\nisTxBodyErrorAutoBalance (BuildTxBodyErrorAutoBalance _) = True\nisTxBodyErrorAutoBalance _                               = False\nThus our assertThrown function checks for two things:\nWhether our action indeed raises an exception.\nIf an exception is raised, does it saitsfy our predicate? For instance, here our predicate was isTxBodyErrorAutoBalance.\n\n\nYou can also catch for IO error like:\nerrored <- catchIOError (submitTx ctx User1 txBody >> pure False) (\\_ -> pure True)\nunless errored $ assertFailure \"Expecting an IOError exception\"\n\nWith this we conclude upon writing integration tests.For convenience, you can write a bash script which combines setup, running tests & closing the privnet all into one simple script.Even though this user is local to the test which created it, it would still persist in our private network.Technically, it's not wrapper that is happening place here but rather we coerce with Identity newtype.Therefore this function is intended to be used when we create only a single output for an external address.https://unix.stackexchange.com/q/367008"}},"/getting-started/operations":{"title":"Operations over Contract","data":{"":"Having understood the contract. Now is the time we actually start using our framework to build the transactions for it.The main principle to understand here is that - we only need to give the essentials, i.e. we only specify what we want and it is the job of the framework to do the rest.For instance, we may tell that we want to consume a specific input belonging to the script's address and generate a specific output. Given that, it becomes framework's job to do the rest, say:\nSelect available UTxO's in user's wallet and generate suitable change output to balance the transaction, considering fees.\nMake sure all generated UTxO's satisfy minimum ada requirement.\nHandle collateral.\netc, etc.\n\nThus, we only specify at high-level what we want. This would become clear as we actually start writing operations for our contract.Entire code for these operations is available here.","operation-1-generating-address-for-our-smart-contract#Operation 1: Generating address for our Smart Contract":"","generating-validator-for-our-smart-contract#Generating Validator for our Smart Contract":"Following the usual drill, we generate the Validator given contract parameters (following is written in file Compiled.hs):\n-- | Generates validator given params.\nbetRefValidator :: BetRefParams -> Validator\nbetRefValidator betRefParams = mkValidatorScript $\n$$(PlutusTx.compile [|| mkBetRefValidator||]) `PlutusTx.applyCode` PlutusTx.liftCode betRefParams\nWhat we have obtained is of type Validator, defined in plutus-ledger-api, which is nothing but a wrapper around Script type defined in same.Likewise, we have our own types, GYValidator (similarly GYMintingPolicy for minting policy scripts) & GYScript (defined in Script.hs) to represent these in our framework.The file mentioned Script.hs contains a lot of helper utilities such as validatorFromPlutus which takes in Plutus's Validator type to give out GYValidator. Though there has been slight abuse in mentioning type here as what is actually given out is GYValidator v where type variable v is of kind PlutusVersion which is defined in file PlutusVersion.hs which you can understand as being here to denote plutus version for our validator script.If we look at the type signature of validatorFromPlutus, we see: validatorFromPlutus :: forall v. SingPlutusVersionI v => Plutus.Validator -> GYValidator v where for the time being we can ignore the description of the typeclass SingPlutusVersionI besides noting the fact that only types (currently 'PlutusV1 & 'PlutusV2) of kind PlutusVersion have an instance for it. So here, our function validatorFromPlutus works for all type variable v which have an instance of SingPlutusVersionI but there is no way to learn what this v is based solely on the input Plutus.Validator and therefore, caller must specify it, either by providing type signature (of callee or caller due to type inference) or by using visible type application. Our first operation does make use of it but before looking at it, we need to understand about GYTxQueryMonad.","interlude---gytxquerymonad#Interlude - GYTxQueryMonad":"When we want to obtain the address of the script from its hash, besides the hash, we also need to know the network we are currently operating at. Is it some testnet or mainnet?Similarly, transaction building involves querying the ledger for various information like say querying UTxO's present at one's address, similarly it might need help of some chain indexer to query datum in case output contains only the datum's hash.All of this is captured by typeclass GYTxQueryMonad defined here and also shown below (kindly see all these functions defined for this typeclass).\n-- | Class of monads for querying chain data.\nclass MonadError GYTxMonadException m => GYTxQueryMonad m where\n{-# MINIMAL networkId, lookupDatum, (utxoAtTxOutRef | utxosAtTxOutRefs), (utxosAtAddress | utxosAtAddresses), slotConfig, currentSlot, logMsg #-}\n\n-- | Get the network id\nnetworkId :: m GYNetworkId\n\n-- | Lookup datum by its hash.\nlookupDatum :: GYDatumHash -> m (Maybe GYDatum)\n\n-- | Lookup 'GYUTxO' at 'GYTxOutRef'.\n--\nutxoAtTxOutRef :: GYTxOutRef -> m (Maybe GYUTxO)\nutxoAtTxOutRef ref = do\nutxos <- utxosAtTxOutRefs [ref]\nreturn $ case utxosToList utxos of\n[]       -> Nothing\nutxo : _ -> Just utxo\n\n-- | Lookup 'GYUTxOs' at multiple 'GYTxOutRef's at once\nutxosAtTxOutRefs :: [GYTxOutRef] -> m GYUTxOs\nutxosAtTxOutRefs orefs = utxosFromList <$> wither utxoAtTxOutRef orefs\n\n-- | Lookup 'GYUTxOs' at 'GYAddress'.\nutxosAtAddress :: GYAddress -> m GYUTxOs\nutxosAtAddress = utxosAtAddresses . return\n\n-- | Lookup 'GYUTxOs' at zero or more 'GYAddress'.\nutxosAtAddresses :: [GYAddress] -> m GYUTxOs\nutxosAtAddresses = foldM f mempty\nwhere\nf :: GYUTxOs -> GYAddress -> m GYUTxOs\nf utxos addr = (<> utxos) <$> utxosAtAddress addr\n\n-- | Lookup the `[GYTxOutRef]`s at a `GYAddress`\nutxoRefsAtAddress :: GYAddress -> m [GYTxOutRef]\nutxoRefsAtAddress = fmap (Map.keys . mapUTxOs id) . utxosAtAddress\n\n{- | Obtain the slot config for the network.\n\nImplementations using era history to create slot config may raise 'GYEraSummariesToSlotConfigError'.\n-}\nslotConfig :: m GYSlotConfig\n\n-- | Lookup the current 'GYSlot'.\ncurrentSlot :: m GYSlot\n\n-- | Log a message with specified namespace and severity.\nlogMsg :: HasCallStack => GYLogNamespace -> GYLogSeverity -> String -> m ()\nSo, if we are working inside a monad which happens to also provide an instance for it, we would happily be able to query such an information.","generating-address#Generating address":"In this operation, we only need to obtain network details with the help of this monad. Here is the code to obtain address (notice that we have provided multiple versions of the same code here):\nType of scriptAddress used below (& defined in Class.hs) is scriptAddress :: forall (m :: * -> *) (v :: PlutusVersion). GYTxQueryMonad m => GYValidator v -> m GYAddress. Thus with respect to type application, the first parameter is for monad and second one is PlutusVersion kinded.Internally this function queries for network details.\n\n\n\n-- A. Type is given by `scriptAddress`.\n\n-- | Validator in question, obtained after giving required parameters.\nbetRefValidator' ::  SingPlutusVersionI v => BetRefParams -> GYValidator v\nbetRefValidator' brp = validatorFromPlutus $ betRefValidator brp\n\n-- | Address of the validator, given params.\nbetRefAddress :: (HasCallStack, GYTxQueryMonad m) => BetRefParams -> m GYAddress\nbetRefAddress brp = scriptAddress @_ @'PlutusV2 $ betRefValidator' brp\n\n\n\n-- B. Type is given by `validatorFromPlutus` using type application.\n\n-- | Validator in question, obtained after giving required parameters.\nbetRefValidator' brp = validatorFromPlutus @'PlutusV2 $ betRefValidator brp\n\n-- | Address of the validator, given params.\nbetRefAddress :: (HasCallStack, GYTxQueryMonad m) => BetRefParams -> m GYAddress\nbetRefAddress brp = scriptAddress $ betRefValidator' brp\n\n\n\n-- C. Type is specified using signature.\n\n-- | Validator in question, obtained after giving required parameters.\nbetRefValidator' :: BetRefParams -> GYValidator 'PlutusV2\nbetRefValidator' brp = validatorFromPlutus $ betRefValidator brp\n\n-- | Address of the validator, given params.\nbetRefAddress :: (HasCallStack, GYTxQueryMonad m) => BetRefParams -> m GYAddress\nbetRefAddress brp = scriptAddress $ betRefValidator' brp\n\n\nWell what is this monad m being used here? Well any! As long as it has an instance for GYTxQueryMonad. When we will start writing tests, then we'll use all of these operations and most likely how to use them would become clear then.","operation-2-adding-input-to-refer-later-reference-input#Operation 2: Adding Input to refer later (Reference Input)":"","interlude---gytxskeleton#Interlude - GYTxSkeleton":"As mentioned before, we just mention at high level what we want in a transaction. This is captured by GYTxSkeleton defined here and its description is mentioned below.\nFields\tRepresented by\tAdditional details\tInputs\tgytxIns\tIt is a list of inputs where for each input, we have its UTxO reference (the \"TxIn\" as the cardano ledger specification calls it) and a witness. In case this UTxO doesn't belong to a script, we just need spending key witness, otherwise we need the associated script, its datum and input redeemer where the associated script could be provided as part of this transaction body or could be obtained from reference input. See TxIn.hs.\tOutputs\tgytxOuts\tList of outputs produced by this transaction where for each output we can mention whether the datum is to be inlined or not and whether this output stores any script. See TxOut.hs.\tReference Inputs\tgytxRefIns\tSet of reference to UTxOs corresponding to reference inputs. Defined in same file, viz. Class.hs.\tMints\tgytxMint\tMap of minting policy to pair of redeemer and another map for token name to mint amount for that token.\tSignatories\tgytxSigs\tSet of Public Key Hash of Signatories.\tValid after\tgytxInvalidBefore\tJust the corresponding node slot.\tValid before\tgytxInvalidAfter\tSame as above.\nCorresponding snippet of haskell code:\ndata GYTxSkeleton (v :: PlutusVersion) = GYTxSkeleton\n{ gytxIns           :: ![GYTxIn v]\n, gytxOuts          :: ![GYTxOut v]\n, gytxRefIns        :: !(GYTxSkeletonRefIns v)\n, gytxMint          :: !(Map (Some GYMintingPolicy) (Map GYTokenName Integer, GYRedeemer))\n, gytxSigs          :: !(Set GYPubKeyHash)\n, gytxInvalidBefore :: !(Maybe GYSlot)\n, gytxInvalidAfter  :: !(Maybe GYSlot)\n} deriving Show\nWhen constructing the transaction, we just need to specify what we want in this skeleton.This skeleton naturally has a monoid instance where two skeletons are combined by running mappend over each of their fields. We have utility functions defined in the same file Class.hs like (note that there are other helpful functions defined in the same file and it would in general be useful to go over them):\nmustHaveOutput :: GYTxOut v -> GYTxSkeleton v\nmustHaveOutput o = emptyGYTxSkeleton {gytxOuts = [o]}\n\nmustHaveInput :: GYTxIn v -> GYTxSkeleton v\nmustHaveInput i = emptyGYTxSkeleton {gytxIns = [i]}\n\nmustHaveRefInput :: VersionIsGreaterOrEqual v PlutusV2 => GYTxOutRef -> GYTxSkeleton v\nmustHaveRefInput i = emptyGYTxSkeleton { gytxRefIns = GYTxSkeletonRefIns (Set.singleton i) }\n\nmustMint :: GYMintingPolicy u -> GYRedeemer -> GYTokenName -> Integer -> GYTxSkeleton v\nmustMint p r tn n = emptyGYTxSkeleton {gytxMint = Map.singleton (Some p) (Map.singleton tn n, r)}\n\nmustBeSignedBy :: GYPubKeyHash -> GYTxSkeleton v\nmustBeSignedBy pkh = emptyGYTxSkeleton {gytxSigs = Set.singleton pkh}\n\nisInvalidBefore :: GYSlot -> GYTxSkeleton v\nisInvalidBefore s = emptyGYTxSkeleton {gytxInvalidBefore = Just s}\n\nisInvalidAfter :: GYSlot -> GYTxSkeleton v\nisInvalidAfter s = emptyGYTxSkeleton {gytxInvalidAfter = Just s}\nThus we can specify that our transaction must have this output (using mustHaveOutput) and that output and must have this input (using mustHaveInput) and so on... and combine them all into a single skeleton using mappend.","skeleton-for-adding-reference-input#Skeleton for adding reference input":"Here we want to create an output at a given address (Oracle's address) with the given datum. This UTxO is to be later used as a reference input by script where the script would refer to its datum. Here we have decided to keep this datum inline as currently framework is not supporting reading datum for a reference input whose output contains only datum hash.\n-- | Add UTxO to be used as reference input at a given address with given datum.\naddRefInput :: GYAddress -> OracleAnswerDatum -> GYTxSkeleton 'PlutusV2\naddRefInput addr dat =\nmustHaveOutput $ GYTxOut addr mempty (Just (datumFromPlutusData dat, GYTxOutUseInlineDatum)) Nothing\n-- Note that the value can be empty as tx building logic would add the needed minimum UTxO ada.\nNote that we have mentioned the value as empty for this UTxO and this is one of the beauties of our framework that it will itself manage adding lovelaces to satisfy minimum ada requirement.","q-can-you-create-a-skeleton-for-adding-reference-script#Q: Can you create a skeleton for adding reference script?":"Toggle Answer\nGiven the output address addr :: GYAddress{:haskell} and the Plutus V2 validator script :: GYValidator 'PlutusV2{:haskell}, we can write mustHaveOutput $ GYTxOut addr mempty (Just (datumFromPlutusData (), GYTxOutDontUseInlineDatum)) (Just $ validatorToScript script){:haskell}","operation-3-placing-a-bet#Operation 3: Placing a bet":"","placing-the-first-bet#Placing the first bet":"In case this is a first bet (a program handling the bets can decide whether the bet being placed by the user is first or not by querying the UTxOs at the script address), then we just need to produce an output at the script address with the bet value and our guess.\n-- | Operation to place bet.\nplaceBet :: (HasCallStack, GYTxMonad m)\n=> GYTxOutRef         -- ^ Reference Script.\n-> BetRefParams       -- ^ Validator Params.\n-> OracleAnswerDatum  -- ^ Guess.\n-> GYValue            -- ^ Bet amount to place.\n-> GYAddress          -- ^ Own address.\n-> Maybe GYTxOutRef   -- ^ Reference to previous bets UTxO (if any).\n-> m (GYTxSkeleton PlutusV2)\nplaceBet refScript brp guess bet ownAddr mPreviousBetsUtxoRef = do\npkh <- addressToPubKeyHash' ownAddr\nbetAddr <- betRefAddress brp\ncase mPreviousBetsUtxoRef of\n-- This is the first bet.\nNothing -> do\nreturn $ mustHaveOutput $ GYTxOut\n{ gyTxOutAddress = betAddr\n, gyTxOutValue = bet\n, gyTxOutDatum = Just (datumFromPlutusData $ BetRefDatum [(pubKeyHashToPlutus pkh, guess)] (valueToPlutus bet), GYTxOutDontUseInlineDatum)\n, gyTxOutRefS    = Nothing\n}\nAt this point, it should be clear what is happening in the above code block. This function is somewhat overloaded and is handling both the cases whether the bet is first or not and it determines this using the presence of reference to a UTxO (representing previous bets) at validator script. In case there isn't one, i.e., Nothing for our Maybe value, we are placing the first bet. Notice that we mention that our datum shouldn't be inlined to output using GYTxOutDontUseInlineDatum.","placing-subsequent-bets#Placing subsequent bets":"Here we would be exercising script's logic for the first time. We would be consuming the UTxO present at script address. We have defined a function, viz. input which would take in the following parameters:\nBetRefParams: to generate the validator script or else we can read the script from the UTxO pertaining to reference script.\nReference to reference script UTxO.\nReference of script input to consume.\nThe datum present at this input. Recall that our datum was not inlined for this particular output, we therefore would need lookup the datum using lookupDatum to pass the actual datum to this function.\nRedeemer action.\n\nThus, we have its definition as:\n-- | Utility function to consume script UTxO.\ninput :: BetRefParams -> GYTxOutRef -> GYTxOutRef -> BetRefDatum -> BetRefAction -> GYTxSkeleton 'PlutusV2\ninput brp refScript inputRef dat red =\nmustHaveInput GYTxIn\n{ gyTxInTxOutRef = inputRef\n, gyTxInWitness  = GYTxInWitnessScript\n(GYInReference refScript $ validatorToScript $ betRefValidator' brp)\n(datumFromPlutusData dat)\n(redeemerFromPlutusData red)\n}\n\nIn case we didn't want to use reference script, we would write gyTxInWitness as:\ngyTxInWitness  = GYTxInWitnessScript\n(GYInScript (validatorToScript $ betRefValidator' brp))\n(datumFromPlutusData dat)\n(redeemerFromPlutusData red)\n\nFollowing is the complete code for handling this case. Few comments to facilitate its understanding:\nWe first query the UTxO corresponding to previous bets at script address and we then query for its datum using utxoDatum' which tries its best to retrieve the datum and raises an exception in case it fails. This is its signature: utxoDatum' :: (GYTxQueryMonad m, Plutus.FromData a) => GYUTxO -> m (GYAddress, GYValue, a).\nNote: utxoAtTxOutRef' (defined again in Class.hs) is a wrapper around utxoAtTxOutRef which raises an exception in case the result was Nothing.\n\n\nWe then see the use of gyLogDebug' which as you would expect is for logging purposes. The first argument that it takes correspond to namespace as used by Katip. This is where integration of off-chain and on-chain code really begins to shine âœ¨, having the Show instance defined for some of our on-chain types allows us to log them.\ntimeFromPlutus is as you'll expect - gives us the framework's representation of time from that of plutus. And enclosingSlotFromTime' uses ledger's information to determine the corresponding slot for the given time. We need this as cardano's node work in slots. We mention that our transaction is to be invalid after this slot using isInvalidAfter.\nWe mention that our transaction must have our public key hash as signatories when plutus smart contract asks for it using mustBeSignedBy.\nLastly, this transaction must generate an output to the script's address with the updated datum and added value.\nvalueToPlutus gives the corresponding value type used by plutus from what we have in our framework (viz., GYValue).\n\n\n\nAll these skeletons are combined together using mappend defined for GYTxSkeleton.\n-- Need to append to previous.\nJust previousBetsUtxoRef -> do\npreviousUtxo <- utxoAtTxOutRef' previousBetsUtxoRef\n(_addr, previousValue, dat@(BetRefDatum previousGuesses _previousBet)) <- utxoDatum' previousUtxo\ngyLogDebug' \"\" $ printf \"previous guesses %s\" (show previousGuesses)\nbetUntilSlot <- enclosingSlotFromTime' (timeFromPlutus $ brpBetUntil brp)\ngyLogDebug' \"\" $ printf \"bet until slot %s\" (show betUntilSlot)\nreturn $\ninput brp refScript previousBetsUtxoRef dat (Bet guess)\n<> mustHaveOutput GYTxOut\n{ gyTxOutAddress = betAddr\n, gyTxOutValue = bet <> previousValue\n, gyTxOutDatum = Just (datumFromPlutusData $ BetRefDatum ((pubKeyHashToPlutus pkh, guess) : previousGuesses) (valueToPlutus bet), GYTxOutDontUseInlineDatum)\n, gyTxOutRefS    = Nothing\n}\n<> isInvalidAfter betUntilSlot\n<> mustBeSignedBy pkh","operation-4-taking-the-bet-pot#Operation 4: Taking the bet pot":"At this point, reading following code snippet should make sense as it is similar to what we have done before. Here note that we are using mustHaveRefInput to tell that the transaction must have the following UTxO reference as a reference input.\nObserve that we don't need to specify that the value we successfully consume from the script's UTxO must reach us because transaction balancer would add the change output to us.\n\n-- | Operation to take UTxO corresponding to previous bets.\ntakeBets :: (HasCallStack, GYTxMonad m)\n=> GYTxOutRef    -- ^ Reference Script.\n-> BetRefParams  -- ^ Validator params.\n-> GYTxOutRef    -- ^ Script UTxO to consume.\n-> GYAddress     -- ^ Own address.\n-> GYTxOutRef    -- ^ Oracle reference input.\n-> m (GYTxSkeleton PlutusV2)\ntakeBets refScript brp previousBetsUtxoRef ownAddr oracleRefInput = do\npkh <- addressToPubKeyHash' ownAddr\npreviousUtxo <- utxoAtTxOutRef' previousBetsUtxoRef\n(_addr, _previousValue, dat) <- utxoDatum' previousUtxo\nbetRevealSlot <- enclosingSlotFromTime' (timeFromPlutus $ brpBetReveal brp)\nreturn $\ninput brp refScript previousBetsUtxoRef dat Take\n<> isInvalidBefore betRevealSlot\n<> mustHaveRefInput oracleRefInput\n<> mustBeSignedBy pkh","additional-useful-functions#Additional Useful Functions":"","utxosdatums#utxosDatums":"Sometimes we want to see all valid UTxOs at our script address. In Cardano, anyone can form UTxO at any address and such a UTxO need not have valid datum as required by our script. utxosDatums can be used wither out invalid ones. See it's usage in Vesting example.","mustmint#mustMint":"We weren't minting any tokens in our example here and thus didn't make use of mustMint skeleton function. It's sample usage is given in this example. Which also illustrates how one can mint NFT and shows usage of someUTxO function which essentially gives some random UTxO belonging to wallet.This is related to singletons and one can read about it from the \"Dependent Types\" chapter (the last one) in Thinking with Types book.This however is not true for normal inputs where you can specify the datum as we'll see in other operations."}},"/getting-started/smart-contract-intro":{"title":"Smart Contract","data":{"":"Let's start by writing a smart contract that we will convey the framework's most important features.\nThis contract is for illustrative purposes only. We do not recommend using it in a production environment.\n\nHere we'll be writing our smart contract in Haskell but do note that we are not limited to it. You for instance could write your smart contract in any language of your choice and read the compiled CBOR using scriptFromCBOR function defined here (Operations over Contract chapter explains about types such as GYScript, PlutusVersion which are used in this function). Similarly, there is readScript defined in the same file to read from the compiled text envelope file.","contract-description#Contract Description":"Setting here is that we have a sport match happening and a group of friends want to bet on the number of goals scored by their favorite team in it.Winner is the one whose guess is closest (and in case of tie - the one who takes it fastest!).The smart contract code is available here. This example was inspired by MLabs.","contract-parameters#Contract Parameters":"brpOraclePkh :: PubKeyHash: We'll be using a reference input, and its datum will give us the actual result (the number of goals). Since the reference input UTxO must belong to Oracle, we check it using Oracle's payment public key hash.\nbrpBetUntil :: POSIXTime: Time until which bets can be placed.\nbrpBetReveal :: POSIXTime: Time that the Oracle will reveal the match results.\nbrpBetStep :: Value: Minimum value that bets must increase by.\n\nThus, the parameters of our contract are given by:\n-- | Our contract is parameterized with this.\ndata BetRefParams = BetRefParams\n{ brpOraclePkh :: PubKeyHash  -- ^ Oracle's payment public key hash. This is needed to assert that UTxO being looked at indeed belongs to the Oracle.\n, brpBetUntil  :: POSIXTime   -- ^ Time until which bets can be placed.\n, brpBetReveal :: POSIXTime   -- ^ Time at which Oracle will reveal the correct match result.\n, brpBetStep   :: Value       -- ^ Each newly placed bet must be more than previous bet by `brpBetStep` amount.\n}\nPlutusTx.makeLift ''BetRefParams","reference-input-datum#Reference Input Datum":"The Oracle tells us the number of goals scored by the concerned team:\n-- | Goals made my the concerned team.\ntype TeamGoals = Integer\n\n-- | Match result given by the Oracle.\nnewtype OracleAnswerDatum = OracleAnswerDatum TeamGoals deriving newtype (Eq, Show)\nPlutusTx.unstableMakeIsData ''OracleAnswerDatum","contract-datum#Contract Datum":"It consists of two fields:\nList containing each person's guess along with their payment public key hash. Key hash is used to tie guess with the guesser. Every time a new guess is made, we prepend it to this list.\nThis key hash is obtained from transaction signatories - we insist on key hash being present in signatories as otherwise anyone may override bet of someone else.\nAmount denoting the previously placed bet. Note that the total value in the UTxO belonging to contract is the culmination of all the previously placed bets and thus it isn't in general equal to last placed bet. We use this to assert that the newly placed bet is more than the previous one by brpBetStep amount.\n\n\n-- | List of guesses by users along with the maximum bet placed yet. A new guess gets /prepended/ to this list. Note that since we are always meant to increment previously placed bet with `brpBetStep`, the newly placed bet would necessarily be maximum (it would be foolish to initialize `brpBetStep` with some negative amounts).\ndata BetRefDatum = BetRefDatum\n{ brdBets        :: [(PubKeyHash, OracleAnswerDatum)]\n, brdPreviousBet :: Value\n}\nPlutusTx.unstableMakeIsData ''BetRefDatum","contract-redeemer#Contract Redeemer":"There are two actions available to user:\nTo place a bet - in which case they give their guess.\nTo take the bets in the pot after the result is out.\n\nThis is therefore codified as:\n-- | Redeemer representing choices available to the user.\ndata BetRefAction = Bet !OracleAnswerDatum  -- ^ User makes a guess.\n| Take                    -- ^ User takes the pot.\nPlutusTx.unstableMakeIsData ''BetRefAction","contract-logic#Contract Logic":"","placing-a-bet#Placing a bet":"Initial bet gets placed as it is (in Cardano, validator script is executed only when spending an UTxO belonging to it but not for creating at it).For subsequent bets, we require three conditions:\nThe bet must be before (inclusive) the brpBetUntil time.\nThere must be exactly one continuing output at the script address whose datum shall have the current guess prepended to it along with the current bet amount.\nThe current bet must be more than the previous bet by at least brpBetStep amount.\n\nThis is coded as:\n{-# INLINABLE mkBetRefValidator' #-}\n-- | Core smart contract logic. Read its description from Atlas guide.\nmkBetRefValidator' :: BetRefParams -> BetRefDatum -> BetRefAction -> ScriptContext -> Bool\nmkBetRefValidator' (BetRefParams oraclePkh betUntil betReveal betStep) (BetRefDatum previousGuesses previousBet) brAction ctx =\n\ncase brAction of\n\nBet guess  ->\nlet\nsOut = case getContinuingOutputs ctx of\n[sOut']        -> sOut'\n_anyOtherMatch -> traceError \"Expected only one continuing output.\"\noutValue = txOutValue sOut\nsIn = maybe (traceError \"Could not find own input\") txInInfoResolved (findOwnInput ctx)\ninValue = txOutValue sIn\n(guessesOut, betOut) = case outputToDatum sOut of\nNothing                                -> traceError \"Could not resolve for script output datum\"\nJust (BetRefDatum guessesOut' betOut') -> (guessesOut', betOut')\nin\ntraceIfFalse\n\"Must be before `BetUntil` time\"\n(to betUntil `contains` validRange) &&\ntraceIfFalse\n\"Guesses update is wrong\"\n((signerPkh, guess) : previousGuesses == guessesOut) &&\ntraceIfFalse\n\"The current bet must be more than the previous bet by atleast `brpBetStep` amount\"\n(outValue `geq` (inValue <> previousBet <> betStep)) &&\ntraceIfFalse\n\"Out bet is wrong\"\n(betOut == outValue - inValue)\nWhere we have the following common helpers for both the redemeer actions:\nwhere\n\ninfo :: TxInfo\ninfo = scriptContextTxInfo ctx\n\nvalidRange :: POSIXTimeRange\nvalidRange = txInfoValidRange info\n\nsignerPkh :: PubKeyHash\nsignerPkh = case txInfoSignatories info of\n[signerPkh']   -> signerPkh'\n[]             -> traceError \"No signatory\"\n_anyOtherMatch -> traceError \"Expected only one signatory\"\n\noutputToDatum :: FromData b => TxOut -> Maybe b\noutputToDatum o = case txOutDatum o of\nNoOutputDatum      -> Nothing\nOutputDatum d      -> processDatum d\nOutputDatumHash dh -> processDatum =<< findDatum dh info\nwhere processDatum = fromBuiltinData . getDatum","taking-the-bet-pot#Taking the bet pot":"In this case we require the following four conditions:\nThis operation must occur after (inclusive) brpBetReveal time.\nThe script must get fully spend, i.e., there shouldn't be any continuing outputs to this script address.\nThe reference input whose datum is used to see actual answer should belong to concerned Oracle.\nGuess should be closest among all.\n\nThis is therefore coded as:\nTake ->\nlet\nJust guess = find ((== signerPkh) . fst) previousGuesses  -- Note that `find` returns the first match. Since we were always prepending, this is valid.\noracleIn = case filter (isNothing . txOutReferenceScript) (txInInfoResolved <$> txInfoReferenceInputs info) of\n[oracleIn']    -> oracleIn'\n[]             -> traceError \"No reference input provided\"\n_anyOtherMatch -> traceError \"Expected only one reference input\"\noracleAnswer = case outputToDatum oracleIn of\nNothing                                  -> traceError \"Could not resolve for datum\"\n(Just (OracleAnswerDatum oracleAnswer')) -> oracleAnswer'\nguessDiff = getGuessDiff $ snd guess\ngetGuessDiff (OracleAnswerDatum g) = abs (oracleAnswer - g)\noracleInPkh = case toPubKeyHash (txOutAddress oracleIn) of\nNothing  -> traceError \"Not PKH for oracle address\"\nJust pkh -> pkh\nin\ntraceIfFalse\n\"Must be after `RevealTime`\"\n(from betReveal `contains` validRange) &&\ntraceIfFalse\n\"Must fully spend Script\"\n(null (getContinuingOutputs ctx)) &&\ntraceIfFalse\n\"Reference input must be from Oracle address (wrt Payment part)\"\n(oracleInPkh == oraclePkh) &&\ntraceIfFalse\n\"Guess is not closest\"\n(all (\\pg -> getGuessDiff (snd pg) >= guessDiff) previousGuesses)\nAnd lo behold! This is our contract.For instance, here we assert that UTxO being used as reference input must belong to Oracle's address but do note that anyone can create an UTxO at Oracle's address."}},"/getting-started/unit-tests":{"title":"Unit Tests","data":{"":"Writing smart contracts & writing tests go hand in hand. Tests are also an excellent way to conveniently check working of our smart contract instead of using cardano-cli and local node.Now that we have written our smart contract and defined the required operations over it, let's see whether its working as expected.Our test suite is a wrapper around Plutus simple model which is created by MLabs.","why-not-just-use-plutus-simple-model-instead-of-the-wrapper#Why not just use \"Plutus simple model\" instead of the wrapper?":"Reusability: Well firstly to maintain compatibility with our toolchain. For instance, our operations were making use of GYTxQueryMonad monad and thus to be able to reuse those same operations we would need to define an instance for it.\nAdditional checks: But secondly and more importantly, plutus simple model lacks some basic checks, for instance:\nWhether a UTxO satisfies minimum ada requirement.\nTransaction fees requirement.\nTransaction signatures requirement, etc.\n\nWe already handle these cases using our transaction building machinery and thus tests written here reflect the actual environment more.\n\n\nFor this guide there should be no need to go over the plutus simple model documentation but this doesn't mean that one shouldn't. It's very lucid and takes few minutes to cover and can be accessed by cloning their repository, entering the docs folder and running mdbook serve --open.","unit-tests-for-placing-a-bet-operation#Unit tests for placing a bet operation":"Entire code file for tests pertaining to this operation is available here. Note that we are using tasty to write our tests and a file calling these individual unit tests is here.\nOur objective here would be to write tests for each of our operation, hence the name \"unit tests\". Though one may write other sort of tests as well, including property based ones.","defining-run-for-placing-a-bet-operation#Defining Run for placing a bet operation":"Before any jibber-jabber, let's see the code so that we know it isn't as complex as it might seem:\nplaceBetRun :: GYTxOutRef -> BetRefParams -> OracleAnswerDatum -> GYValue -> Maybe GYTxOutRef -> GYTxMonadRun GYTxId\nplaceBetRun refScript brp guess bet mPreviousBetsUtxoRef = do\naddr <- ownAddress\nskeleton <- placeBet refScript brp guess bet addr mPreviousBetsUtxoRef\nsendSkeleton skeleton\n\nWhy do we call it \"run\"? Well if you have gone over the documentation of plutus simple model, you'll know that they have this \"Run\" monad where actually most of the test code gets executed and we have wrapper around this type, which we call GYTxMonadRun (defined in Run.hs). But as an end developer, there is no need to understand about it.Also our GYTxMonadRun has an instance of GYTxQueryMonad.\nThe idea here is that any tests we do related to performing the bet operation would need to call the placeBet function which we have defined before. Therefore we have defined a run to call this function. Our placeBetRun function takes all those parameters which are required by placeBet function, except the address as that we are able to get using ownAddress function. ownAddress function is defined in file Run.hs where actually most of the code related to our wrapper lives and it gives the address of the wallet running this run as we'll shortly see.Lastly sendSkeleton can be understood as submitting the transaction. It will update the mock ledger state and return the transaction id for the submitted transaction. Note that it does raise an exception in case it fails to submit the transaction.","understanding-testrun#Understanding testRun":"Before we see a trace calling the run we just defined, notice that in our testGroup, we have the first test written as:\ntestRun \"Balance checks after placing first bet\" $ firstBetTrace (OracleAnswerDatum 3) (valueFromLovelace 20_000_000) 0_182_793\nNow what is this testRun?This function (defined in Utils.hs) takes a string to represent the name of the test and a continuation function (of type Wallets -> Run a) and then internally generates wallets to give to our continuation function.The type Wallets is defined as:\ndata Wallets = Wallets\n{ w1 :: !Wallet\n, w2 :: !Wallet\n, w3 :: !Wallet\n, w4 :: !Wallet\n, w5 :: !Wallet\n, w6 :: !Wallet\n, w7 :: !Wallet\n, w8 :: !Wallet\n, w9 :: !Wallet\n} deriving (Show, Eq, Ord)\nwhere Wallet is:\ndata Wallet = Wallet\n{ walletPaymentSigningKey :: !GYPaymentSigningKey\n, walletNetworkId         :: !GYNetworkId\n, walletName              :: !String\n}\nderiving (Show, Eq, Ord)\nThus our testRun function, generates these 9 wallets where each wallet is having the following three assets:\nMillion ada. Note: This is split into two UTxO's, one of which is for collateral, having an amount of 5 ada.\nMillion fakeGold.\nMillion fakeIron.\n\nwhere fakeGold and fakeIron are our two non-native assets.Each call to testRun (as you can see - we have multiple tests, all beginning with testRun) runs the given test with a fresh (new) blockchain ledger state having given the above balances to those 9 wallets.In our case, \"Balance checks after placing first bet\" is the name of the test and firstBetTrace (OracleAnswerDatum 3) (valueFromLovelace 20_000_000) 0_182_793 is our continuation function.","defining-a-trace-to-call-placebetrun#Defining a trace to call placeBetRun":"Now let's see the definition firstBetTrace we briefly encountered above:\n-- | Trace for placing the first bet.\nfirstBetTrace :: OracleAnswerDatum  -- ^ Guess\n-> GYValue            -- ^ Bet\n-> Integer            -- ^ Expected fees\n-> Wallets -> Run ()  -- Our continuation function\nfirstBetTrace dat bet expectedFees ws@Wallets{..} = do\n-- First step: Get the required parameters for initializing our parameterized script and add the corresponding reference script\n(brp, refScript) <- computeParamsAndAddRefScript 40 100 (valueFromLovelace 200_000_000) ws\nvoid $ runWallet w1 $ do  -- following operations are ran by first wallet, `w1`\n-- Second step: Perform the actual run.\nwithWalletBalancesCheck [w1 := valueNegate (valueFromLovelace expectedFees <> bet)] $ do\nplaceBetRun refScript brp dat bet Nothing\nHere the last argument is of type Wallets as we noted.Note that this function starts by calling computeParamsAndAddRefScript, therefore let's see about it:\n-- | Function to compute the parameters for the contract and add the corresponding refernce script.\ncomputeParamsAndAddRefScript\n:: Integer                                    -- ^ Bet Until slot\n-> Integer                                    -- ^ Bet Reveal slot\n-> GYValue                                    -- ^ Bet step value\n-> Wallets -> Run (BetRefParams, GYTxOutRef)  -- Our continuation\ncomputeParamsAndAddRefScript betUntil' betReveal' betStep Wallets{..} = do\nlet betUntil = slotFromApi (fromInteger betUntil')\nbetReveal = slotFromApi (fromInteger betReveal')\nfmap fromJust $ runWallet w1 $ do\nbetUntilTime <- slotToBeginTime betUntil\nbetRevealTime <- slotToBeginTime betReveal\nlet brp = BetRefParams (pubKeyHashToPlutus $ walletPubKeyHash w8) (timeToPlutus betUntilTime) (timeToPlutus betRevealTime) (valueToPlutus betStep)  -- let oracle be wallet `w8`.\nmORef <- addRefScript (walletAddress w9) (betRefValidator' brp)\ncase mORef of\nNothing        -> fail \"Couldn't find index of the Reference Script in outputs\"\nJust refScript -> return (brp, refScript)\n\nOur first step is to construct the parameter (BetRefParams) for our parameterized contract. Recall its type is:\ndata BetRefParams = BetRefParams\n{\nbrpOraclePkh :: PubKeyHash  -- ^ Oracle's payment public key hash. This is needed to assert that UTxO being looked at indeed belongs to the Oracle.\n, brpBetUntil  :: POSIXTime   -- ^ Time until which bets can be placed.\n, brpBetReveal :: POSIXTime   -- ^ Time at which Oracle will reveal the correct match result.\n, brpBetStep   :: Value       -- ^ Each newly placed bet must be more than previous bet by `brpBetStep` amount.\n}\nFor brpBetUntil, we choose slot 40 but since plutus works in posix time, we need to enter a monad having an instance of GYTxQueryMonad to get posix time from slot and therefore that calculation happens inside runWallet w1. Similarly for brpBetReveal we chose slot 100.\nrunWallet is a utility function (defined again in Utils.hs) which enables us to give the environment. Hm.. what environment you ask? Well in general when constructing the transaction from skeleton we need some context, like who is actually submitting this transaction? As we'll need their address to give them the change output. runWallet takes as first argument, the wallet to generate context from and then the actual run to run against this context.\nNow coming back to our parameters, for brpOraclePkh parameter, we chose that for wallet 8. And we take our step amount to be 200 ada.Though it is not required for this operation (where we place the first bet) but since our placeBet function is overloaded to accept the subsequent bet case too - we need to give reference to the UTxO containing reference script. For that we have a helper function defined in Utils.hs called addRefScript which adds the given script at a given address (we chose that for wallet 9) and returns the reference to it (in Maybe).Now we are almost done to call our run with just one more line to understand.withWalletBalancesCheck takes a list of tuple where the first element of the tuple is the wallet and second element denotes the difference in the wallet's value which we expect after the execution of the operation defined inside its do block. Here we want the balance of wallet 1 (which is the one actually calling this operation) to decrease by the bet amount and also the fees.\nHow do we know the fees?\nWell by running the test without it and then noting the transaction fees from the log messages.\nAnd this covers our first test ðŸ¥³.","multiple-bets-trace#Multiple bets trace":"Now let's write a slightly more involved trace. This time we'll make our trace parameteric over the required contract parameters.Here is the signature of our trace:\n-- | Trace which allows for multiple bets.\nmultipleBetsTraceWrapper\n:: Integer                                            -- ^ slot for betUntil\n-> Integer                                            -- ^ slot for betReveal\n-> GYValue                                            -- ^ bet step\n-> [(Wallets -> Wallet, OracleAnswerDatum, GYValue)]  -- ^ List denoting the bets\n-> Wallets -> Run ()                                  -- Our continuation function\nmultipleBetsTraceWrapper betUntil' betReveal' betStep walletBets ws = do\n-- First step: Get the required parameters for initializing our parameterized script and add the corresponding reference script\n(brp, refScript) <- computeParamsAndAddRefScript betUntil' betReveal' betStep ws\n-- Second step: Perform the actual bet operations\nmultipleBetsTraceCore brp refScript walletBets ws\nThe first three parameters correspond to the parameters of contract.The fourth parameter denotes the different bets.We may for instance call this function like so:\ntestRun \"Balance checks with multiple bets\" $ multipleBetsTraceWrapper 400 1000 (valueFromLovelace 10_000_000)\n[ (w1, OracleAnswerDatum 1, valueFromLovelace 10_000_000)\n, (w2, OracleAnswerDatum 2, valueFromLovelace 20_000_000)\n, (w3, OracleAnswerDatum 3, valueFromLovelace 30_000_000)\n, (w2, OracleAnswerDatum 4, valueFromLovelace 50_000_000)\n, (w4, OracleAnswerDatum 5, valueFromLovelace 65_000_000 <> fakeGold 1000)\n]\nNext we want to add our reference script and compute the actual contract parameters (converting slot to posix) - which is again handled like before.We would then like to perform the actual bet operations. But this time we won't concern ourselves much with actual fees but rather take a threshold of 1 ada. Our approach here is to compare the balances before performaing any operation and after performing all the operations and then see that each wallet has lost the bet amount they placed considering threshold fees.Note: We use balance function to get the balance for the given wallet.\n-- | Trace which allows for multiple bets.\nmultipleBetsTraceCore\n:: BetRefParams\n-> GYTxOutRef                                         -- ^ Reference script\n-> [(Wallets -> Wallet, OracleAnswerDatum, GYValue)]  -- ^ List denoting the bets\n-> Wallets -> Run ()                                  -- Our continuation function\nmultipleBetsTraceCore brp refScript walletBets ws@Wallets{..} = do\nlet\n-- | Perform the actual bet operation by the corresponding wallet.\nperformBetOperations [] _ = return ()\nperformBetOperations ((getWallet, dat, bet) : remWalletBets) isFirst = do\nif isFirst then do\nvoid $ runWallet (getWallet ws) $ do\nvoid $ placeBetRun refScript brp dat bet Nothing\nperformBetOperations remWalletBets False\nelse do\n-- need to get previous bet utxo\nvoid $ runWallet (getWallet ws) $ do\nbetRefAddr <- betRefAddress brp\n[_scriptUtxo@GYUTxO {utxoRef}] <- utxosToList <$> utxosAtAddress betRefAddr\nvoid $ placeBetRun refScript brp dat bet (Just utxoRef)\nperformBetOperations remWalletBets False\n-- | To sum the bet amount for the corresponding wallet.\nsumWalletBets _wallet [] acc = acc\nsumWalletBets wallet ((getWallet, _dat, bet) : remWalletBets) acc = sumWalletBets wallet remWalletBets (if getWallet ws == wallet then acc <> valueNegate bet else acc)\n-- | Idea here is that for each wallet, we want to know how much has been bet. If we encounter a new wallet, i.e., wallet for whose we haven't yet computed value lost, we call `sumWalletBets` on it.\ngetBalanceDiff [] _set acc = acc\ngetBalanceDiff wlBets@((getWallet, _dat, _bet) : remWalletBets) set acc =\nlet wallet = getWallet ws\nwallet'sName = walletName wallet\nin\nif Set.member wallet'sName set then getBalanceDiff remWalletBets set acc\nelse\ngetBalanceDiff remWalletBets (Set.insert wallet'sName set) ((wallet := sumWalletBets wallet wlBets mempty) : acc)\nbalanceDiffWithoutFees = getBalanceDiff walletBets Set.empty []\nbalanceBeforeAllTheseOps <- fmap fromJust $ runWallet w1 $ traverse (\\(wallet, _value) -> balance wallet) balanceDiffWithoutFees\nperformBetOperations walletBets True\nbalanceAfterAllTheseOps <- fmap fromJust $ runWallet w1 $ traverse (\\(wallet, _value) -> balance wallet) balanceDiffWithoutFees\nvoid $ runWallet w1 $ verify (zip3 balanceDiffWithoutFees balanceBeforeAllTheseOps balanceAfterAllTheseOps)\nwhere\n-- | Function to verify that the wallet indeed lost by /roughly/ the bet amount. We say /roughly/ as fees is assumed to be within (0, 1 ada].\nverify [] = return ()\nverify (((wallet, diff), vBefore, vAfter) : xs) =\nlet vAfterWithoutFees = vBefore <> diff\n(expectedAdaWithoutFees, expectedOtherAssets) = valueSplitAda vAfterWithoutFees\n(actualAda, actualOtherAssets) = valueSplitAda vAfter\n-- threshold = valueFromLovelace 1_000_000  -- 1 ada\nthreshold = 1_000_000  -- 1 ada\nin if expectedOtherAssets == actualOtherAssets && actualAda < expectedAdaWithoutFees && expectedAdaWithoutFees - threshold <= actualAda then verify xs\n-- valueGreater vAfterWithoutFees vAfter && valueGreaterOrEqual vAfter (valueMinus vAfterWithoutFees threshold) then verify xs\nelse fail (\"For wallet \" <> walletName wallet <> \" expected value (without fees) \" <> show vAfterWithoutFees <> \" but actual is \" <> show vAfter)\n\nAn eagle eye might notice two comments inside the verify function.Firstly, note that valueSplitAda splits our GYValue into lovelaces and that which remains besides it. Since fees don't affect non-ada tokens (not yet), we compare with respect to threshold using ada tokens.We could also compare GYValue's directly using valueGreater (there is also valueGreaterOrEqual) as done in comments but the current one is slightly more optimal as we need not compare on non-ada tokens again.","but-sometimes-we-want-a-test-to-fail#But sometimes we want a test to fail!":"What happens if the newly placed bet is not more than atleast brpBetStep amount? What happens if the transaction skeleton was somewhat wrong, say we didn't put mustBeSignedBy? What if someone tries to place a bet after brpBetUntil? What if...Well for all such cases, we can assert that a given trace must fail using mustFail like:\ntestRun \"Not adding atleast bet step amount should fail\" $ mustFail . multipleBetsTrace 400 1000 (valueFromLovelace 10_000_000)\n[ (w1, OracleAnswerDatum 1, valueFromLovelace 10_000_000)\n, (w2, OracleAnswerDatum 2, valueFromLovelace 20_000_000)\n, (w3, OracleAnswerDatum 3, valueFromLovelace 30_000_000)\n, (w2, OracleAnswerDatum 4, valueFromLovelace 50_000_000)\n, (w4, OracleAnswerDatum 5, valueFromLovelace 55_000_000 <> fakeGold 1000)]\nHere wallet w4 didn't increase the bet by 10 ada and thus must fail.\nSometimes we want to assert specific failure among other possible failures. As mustFail above doesn't distinguish among them, one can simply use catchError like in this test.","unit-tests-for-taking-the-bet-pot#Unit tests for taking the bet pot":"Entire code file for tests pertaining to this operation is available here.\nOn similar lines as before, let's first define our run for takeBets operation:\n-- | Run to call the `takeBets` operation.\ntakeBetsRun :: GYTxOutRef -> BetRefParams -> GYTxOutRef -> GYTxOutRef -> GYTxMonadRun GYTxId\ntakeBetsRun refScript brp toConsume refInput = do\naddr <- ownAddress\nskeleton <- takeBets refScript brp toConsume addr refInput\nsendSkeleton skeleton\nNext, we'll define our trace to call this run:\n-- | Trace for taking bet pot.\ntakeBetsTrace :: Integer                                            -- ^ slot for betUntil\n-> Integer                                            -- ^ slot for betReveal\n-> GYValue                                            -- ^ bet step\n-> [(Wallets -> Wallet, OracleAnswerDatum, GYValue)]  -- ^ List denoting the bets\n-> Integer                                            -- ^ Actual answer\n-> (Wallets -> Wallet)                                -- ^ Taker\n-> Maybe Integer                                      -- ^ Expected fees\n-> Wallets -> Run ()  -- Our continuation function\ntakeBetsTrace betUntil' betReveal' betStep walletBets answer getTaker mExpectedFees ws@Wallets{..} = do\n(brp, refScript) <- computeParamsAndAddRefScript betUntil' betReveal' betStep ws\nmultipleBetsTraceCore brp refScript walletBets ws\n-- Now lets take the bet\nmMRef <- runWallet w1 $ addRefInput True (walletAddress w8) (datumFromPlutusData $ OracleAnswerDatum answer)\nlet taker = getTaker ws\ncase mMRef of\nJust (Just refInput) -> do\nvoid $ runWallet taker $ do\nbetRefAddr <- betRefAddress brp\n[_scriptUtxo@GYUTxO {utxoRef, utxoValue}] <- utxosToList <$> utxosAtAddress betRefAddr\nwaitUntilSlot $ slotFromApi (fromInteger betReveal')\ncase mExpectedFees of\nJust expectedFees ->\nwithWalletBalancesCheck [taker := utxoValue <> valueNegate (valueFromLovelace expectedFees)] $ do\ntakeBetsRun refScript brp utxoRef refInput\nNothing -> takeBetsRun refScript brp utxoRef refInput\n_anyOtherMatch -> fail \"Couldn't place reference input successfully\"\nHere we first did the common step of computing the required script parameters and adding the reference script.Then we used addRefInput defined in Utils.hs whose purpose here would become clear by seeing its haddock documentation below:\n-- | Adds an input (whose datum we'll refer later) and returns the reference to it.\naddRefInput:: Bool       -- ^ Whether to inline this datum?\n-> GYAddress  -- ^ Where to place this output?\n-> GYDatum    -- ^ Our datum.\n-> GYTxMonadRun (Maybe GYTxOutRef)\nNext we simply wait until time for bet revealation and claim our pot!Now that we have our trace for taking bet pot, we can try testing for other conditions - examples for some are written in the TakeBetPot.hs file.We use a custom fork of Plutus simple model.To convey the message better, we have a pattern synonym defined in Utils.hs file:\npattern (:=) :: x -> y -> (x, y)\npattern (:=) x y = (x, y)\nSince we require the signature being present in the skeleton, we can't place bet on anyone else's behalf anyways."}},"/":{"title":"Index","data":{"":""}},"/introduction":{"title":"Introduction","data":{"":"Atlas is an all-in-one, Haskell-native application backend for writing off-chain code for on-chain Plutus smart contracts. Atlas has been designed by Genius Yield, in collaboration with MLabs, Well-Typed and Plank.","features#Features":"","easily-build-transactions#Easily build transactions":"Use an intuitive API to abstract away the complexity around building transactions, balancing UTxOs, and interfacing with Plutus smart contracts.","leverage-first-class-haskell#Leverage first-class Haskell":"Avoid code duplication between on-chain and off-chain code, interoperate with advanced functionalities offered by IOG's Cardano/Plutus libraries, and easily convert between Atlas and Cardano/Plutus types.","utilize-modular-data-providers#Utilize modular data providers":"Query ledger state information from Maestro, a local node or Cardano DB Sync. You can also build and contribute your own data provider!","test-extensively#Test extensively":"Use Atlas' test harness to write realistic unit tests that correspond to on-chain behavior, and execute integration tests against cardano node in a private network.","stay-up-to-date#Stay up to date":"Benefit from Cardano's latest innovations such as Reference Inputs, Inline Datums and Reference Scripts.","where-to-next#Where to next?":"Work through an end-to-end example here: Getting Started."}},"/more-tutorials":{"title":"More Tutorials","data":{"":"","vesting#Vesting":"See the introductory walkthrough of Atlas given by Dr. Lars using his with favourite example, Vesting, here. Associated code is available at atlas-examples repository."}}}