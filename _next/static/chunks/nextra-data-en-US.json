{"/additional-features/blueprint":{"title":"Blueprint","data":{"":"Plutus Contract Blueprint, as introduced by CIP-57 is an effective way of communicating desired structure of validator's associated types such as datum & redeemer to your off-chain code.With Atlas, you can easily have these types generated for you based on provided schema, along with some helper utilities, yay!\nIf your validator is parameterised, parameters must be \"data\" encoded (instead of scott or sums-of-products encoding) as blueprint notation desires it (data) to be primary binary interface. This is not an issue for datums & redeemers as they are required to be data encoded anyway.Validators written by tools such as Aiken uses data encoding for validator parameters.\nHere we have a parameterised Aiken validator. Mainly, it checks that sum of integers and length of bytestrings given in parameters, datum & redeemer sum up to a specific value.For it, we have a simple off-chain code here, have a look at it and we provide some description for it below.We first use Template Haskell to splice declarations from makeBPTypes and uponBPTypes. makeBPTypes introduces types from definitions given in blueprint file and uponBPTypes creates data related instances such as ToData, FromData for these types.It is useful to see generated Template Haskell code to know for type and provided utility names which can be done via -ddump-splices GHC flag. You may combine this with -ddump-to-file to save the output to a file. If you are using cabal, see this answer on where one can find dumped splice files.Now we can apply parameters (whose types have been generated by Atlas) to our validator with provided applyParamsToBPValidator_baz_baz_spend function and obtain GYScript from it using scriptFromBPSerialisedScript function. Likewise we have types generated for our datum & redeemer, sweet!Rest of the off-chain code just tries to interact with the validator by creating a UTxO towards it and then later consuming from it.\nTo interact with blueprint file, you'll usually just need to import GeniusYield.Types.Blueprint.TH module (which is exposed by GeniusYield.Types module), however if you want to inspect the parsed blueprint file, you can use readBlueprint.\nSee CIP-85 to understand about different encodings used.We could however achieve both in single splice, however, since we are using utilities from PlutusTx to derive ToData etc. instances, they require type to be in scope first."}},"/getting-started/browser-integration":{"title":"Browser Integration","data":{"":"Now that we have our server running, we need front-end UI to interact with it.For all of the operations, the approach (as previously mentioned) is same which is to first get the unsigned transaction from server, use browser wallet's signTx method to get spending key witness for this transaction, and then use server's endpoint to add witness to this transaction & submit it.\nThe entire code pertaining to browser operations is available here.\nAn outline of this whole process is given below, illustrated via add-ref-script endpoint:\n// Obtain access to browser wallet api\nconst api: WalletApi = await window.cardano[selectedWallet].enable(); // Creating a type such as `WalletApi` was entirely optional.\n// Obtaining UTxOs to be used collaterals as given by browser wallet.\nconst colls = await api.experimental.getCollateral();\n// Create request body for calling our endpoint\nconst body = {\n  arsUsedAddrs: await api.getUsedAddresses(),\n  arsChangeAddr: await api.getChangeAddress(),\n  ...(0 in colls && { arsCollateral: colls[0] }),\n  arsPutAddress: convertAddrToRaw(values.putAddress), // implementation detail\n  arsBetParams: processBrpParams(brpParams), // implementation detail\n};\nconsole.log(body);\n// Call endpoint\nconst { data } = await axios.post(\"http://localhost:8081/betref/add-ref-script\", body);\nconsole.log(data);\n// Sign & submit\nconst { data: submitData } = await axios.post(\n  \"http://localhost:8081/tx/add-wit-and-submit\",\n  {\n    awasTxUnsigned: data.urspTxBodyHex,\n    awasTxWit: await api.signTx(data.urspTxBodyHex, true), // Note that this second argument (corresponding to \"partial signing\") needs to be `true` as for inputs such as those belonging to script already have their witness and we need to give witness only for inputs belonging to us.\n  },\n  {\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n  }\n);\nWhat follows is the demo for all of the operations we defined.\nDue to security reasons, you would need to run this page locally (instructions here) to check out the following demo.\nAnd with this, we come to an end of our Getting Started guide ðŸ¥³! Hope you enjoyed it ðŸ’™\nHave questions? Ask them at Cardano StackExchange."}},"/getting-started":{"title":"Getting Started","data":{"":"Learn the most important framework concepts in just few minutes by coding a complete end-to-end example."}},"/getting-started/endpoints":{"title":"Creating Endpoints","data":{"":"Now that we are confident with our smart contract, it's time that we make it accessible to end user.The approach here would be\nFront-end asks to construct transaction for the concerned operation.\nIt then receives this transaction, which is complete besides missing for signature for spending inputs belonging to browser wallet. It calls wallet api's signTx method upon this body to get this signature (key witness).\nFrontend now passes this unsigned transaction along with the witness it received to our backend endpoint which will add this witness to the transaction, making it complete and would then submit it.\nWe'll use Servant to create our endpoints and one may understand it by following their easy to understand tutorial here.\nDo note that we can also sign the transactions in server using the signTx function defined in GeniusYield.Types.TxBody module.","providing-data-provider#Providing Data Provider":"","defining-provider-configuration#Defining Provider Configuration":"As noted earlier, building transaction bodies require gathering suitable information from the blockchain. For this purpose, we'll require a provider. Atlas is unopinionated and allows user to plug in provider of their choice, including a locally hosted one.Currently Atlas supports the following providers (& it would be highly appreciated if community enriches this by contributing to Atlas):\nMaestro.\nLocally ran node along with Kupo. We have tested with version 8.1.2 of cardano-node and 2.7.2 of Kupo.\nBlockfrost.\nFollowing API functions don't have an optimal implementation for Blockfrost:\nutxosAtTxOutRefs\nutxosAtTxOutRefsWithDatums\nutxosAtAddressWithDatums\nutxosAtAddresses\nutxosAtAddressesWithDatums\nutxosAtPaymentCredentialWithDatums\nutxosAtPaymentCredentials\nutxosAtPaymentCredentialsWithDatums\nIn general, we recommend either Maestro or local node with Kupo as provider.\nTo provide information about the provider, we will create a config.json file whose contents could be as follows:\nWe have given a sample config.json file here.\n{\n  \"coreProvider\": ...,\n  \"networkId\": \"preprod\",\n  \"logging\": [{ \"type\": { \"tag\": \"stderr\" }, \"severity\": \"Debug\", \"verbosity\": \"V2\" }],\n  \"logTiming\": false\n}\nwhere coreProvider field can have one of following possible values:\n\"coreProvider\": { \"maestroToken\": \"<Your-API-Key>\", \"turboSubmit\": false },\n\"coreProvider\": { \"socketPath\": \"path-to-node-socket\", \"kupoUrl\": \"http://localhost:1442\" },\n\"coreProvider\": { \"blockfrostKey\": \"<Your-API-Key>\" },\nHere is the explanation for each of the JSON keys above:\ncoreProvider: This field is the differentiating factor between different providers.\nFor Maestro, maestroToken holds the api key and turboSubmit field dictates whether the transactions are to be submitted via their turbo submit endpoint.\nFor Local Node with Kupo provider, socketPath is the path towards node socket (usually named node.socket) file and kupoUrl is the url where endpoints are made available by Kupo, it is usually http://localhost:1442.\nFor Blockfrost, blockfrostKey holds the required api key.\nnetworkId: Specifies your network and must be one of mainnet, preprod, preview, testnet (for legacy testnet) & privnet (for local private network).\nlogging: It's a list of scribes to register. Its parameters (like severity, verbosity) and its general usage can be understood by going over their official haddock documentation here. Katip is also explained in this book on web development in Haskell. Please have a look at haddock for FromJSON and ToJSON instances of GYLogScriptType to see sample usage.\nlogTiming: (Optional) If set to true, operations involving provider are timed and corresponding durations are logged.","parsing-given-configuration#Parsing Given Configuration":"The file server-main.hs fires up our server. It reads & parses the configuration file and using it makes our endpoints (which we will define shortly) available. Here is its entire code.\n-- | Getting path for our core configuration.\nparseArgs :: IO FilePath\nparseArgs = do\n  args <- getArgs\n  case args of\n    coreCfg: _ -> return coreCfg\n    _invalidArgument -> fail \"Error: wrong arguments, needed a path to the CoreConfig JSON configuration file\\n\"\nmain :: IO ()\nmain = do\n  putStrLn \"Writing Swagger file ...\"\n  BL8.writeFile \"swagger-api.json\" (encodePretty apiSwagger)\n  putStrLn \"parsing Config ...\"\n  coreCfgPath <- parseArgs\n  coreCfg <- coreConfigIO coreCfgPath  -- Parsing our core configuration.\n  putStrLn \"Loading Providers ...\"\n  withCfgProviders coreCfg \"api-server\"  $ \\providers -> do\n    let port = 8081\n        ctx = Ctx coreCfg providers\n    putStrLn $ \"Starting server at \\n \" <> \"http://localhost:\" <> show port\n    run port $ app ctx\napp :: Ctx -> Application\napp ctx = cors (const $ Just simpleCorsResourcePolicy { corsRequestHeaders = [HttpTypes.hContentType] }) $ serve appApi $ hoistServer appApi (Handler . ExceptT . try)  $ apiServer ctx\nFocussing on the highlighted lines, you can see that it first reads the path to the configuration file (you would for instance run this file like so cabal run betref-server -- config.json) in line coreCfgPath <- parseArgs{:haskell}, then it parses this file coreCfg <- coreConfigIO coreCfgPath{:haskell}.We then see the use of an interesting function withCfgProviders. It's type is withCfgProviders :: GYCoreConfig  -> GYLogNamespace -> (GYProviders -> IO a) -> IO a{:haskell}, thus, this function first takes our parsed configuration file, then a namespace, finally followed by a continuation GYProviders -> IO a. Idea here is that this function will setup a GYProviders from the parsed configuration file and send it to this continuation to obtain its result.","defining-endpoints#Defining Endpoints":"","shared-context#Shared Context":"Entire code for it is available here\nOur endpoints would need an information for our provider, thus we have created the type for it, called Ctx. It's usage is made clear by function defined next, runQuery which in essence correspond to ctxRunC we saw in section on Integration Tests. Reasoning for runTxI & runTxF follows similarly.Note about our handling of collateral: Browser wallets usually have the option to set for collateral, in such a case wallets would create an UTxO specifically to be used as collateral and such an UTxO will be reserved, i.e., wallet won't be spending it. CIP 40 changed the properties related to collateral and therefore we can safely take even that UTxO as collateral which has large amounts of ada and it could also contain multiple assets. Therefore if there is no collateral set by browser wallet, framework is capable of choosing suitable UTxO as collateral (and also sets for return collateral & total collateral fields appropriately) and in that case it is also free to spend it, if required by transaction builder. But if however there is a 5-ada collateral set by wallet, then framework would use it as collateral and would also reserve it, i.e., it won't pick to spend it unless explicitly mentioned by transaction skeleton. Also note that, we'll use browser wallet's getCollateral() method to get for collateral. This method usually returns a list of ada-only UTxOs in wallet within a specific range (like in case of Nami, it is those with ada less than or equal to 50). We would send first element of this list (if exists) to backend and framework would check if the value contained in this UTxO is exactly 5 ada or not (like Nami's getCollateral method returns only a singleton list if collateral is set in wallet), if not, framework would ignore this (i.e., would not reserve for it) and would itself pick suitable UTxO as collateral. If however you want this to be reserved (& of course used as collateral) regardless of it's value, see the comment in call to runGYTxMonadNodeF in runTxF function.\n-- | Our Context.\ndata Ctx = Ctx\n  { ctxCoreCfg   :: !GYCoreConfig\n  , ctxProviders :: !GYProviders\n  }\n-- | To run for simple queries, the one which don't requiring building for transaction skeleton.\nrunQuery :: Ctx -> GYTxQueryMonadNode a -> IO a\nrunQuery ctx q = do\n  let nid       = cfgNetworkId $ ctxCoreCfg ctx\n      providers = ctxProviders ctx\n  runGYTxQueryMonadNode nid providers q\n-- | Wraps our skeleton under `Identity` and calls `runTxF`.\nrunTxI :: Ctx\n       -> [GYAddress]           -- ^ User's used addresses.\n       -> GYAddress             -- ^ User's change address.\n       -> Maybe GYTxOutRefCbor  -- ^ Browser wallet's reserved collateral (if set).\n       -> GYTxMonadNode (GYTxSkeleton v)\n       -> IO GYTxBody\nrunTxI = coerce (runTxF @Identity)\n-- | Tries to build for given skeletons wrapped under traversable structure.\nrunTxF :: Traversable t\n       => Ctx\n       -> [GYAddress]           -- ^ User's used addresses.\n       -> GYAddress             -- ^ User's change address.\n       -> Maybe GYTxOutRefCbor  -- ^ Browser wallet's reserved collateral (if set).\n       -> GYTxMonadNode (t (GYTxSkeleton v))\n       -> IO (t GYTxBody)\nrunTxF ctx addrs addr collateral skeleton  = do\n  let nid       = cfgNetworkId $ ctxCoreCfg ctx\n      providers = ctxProviders ctx\n  runGYTxMonadNodeF GYRandomImproveMultiAsset nid providers addrs addr\n    (collateral >>=\n      (\\c -> Just (getTxOutRefHex c,\n                   True  -- Make this as `False` to not do 5-ada-only check for value in this given UTxO to be used as collateral.\n                  )\n      )\n    ) skeleton","submit-endpoint#Submit Endpoint":"Entire code for it is available here\nWe'll soon see endpoints which will return for unsigned transaction to the browser but assuming that we already have a unsigned transaction CBOR & the missing signature, let's see how we can define an endpoint which will add this missing key witness to the transaction body and would then submit it using our provider.Input to this endpoint is a type AddWitAndSubmitParams encapsulating our unsigned transaction body & missing key witness.Then we have our function handleAddWitAndSubmitTx which adds the witness to the transaction making it complete and then it submits it. The response generated here is of type SubmitTxResponse and you can modify the same to include other fields if required.\n-- | Return type of API when submitting a transaction.\ndata SubmitTxResponse = SubmitTxResponse\n                          { submitTxFee :: !Integer\n                          , submitTxId  :: !GYTxId\n                          } deriving (Show, Generic, ToJSON, Swagger.ToSchema)\n-- | Input parameters to add for reference script.\ndata AddWitAndSubmitParams = AddWitAndSubmitParams\n  { awasTxUnsigned :: !GYTx\n  , awasTxWit      :: !GYTxWitness\n  } deriving (Generic, FromJSON, Swagger.ToSchema)\n-- | Construct `SubmitTxResponse` return type from the given signed transaction body.\ntxBodySubmitTxResponse :: GYTxBody -> SubmitTxResponse\ntxBodySubmitTxResponse txBody = SubmitTxResponse\n                                  { submitTxFee = txBodyFee txBody\n                                  , submitTxId  = txBodyTxId txBody\n                                  }\n-- | Type for our Servant API.\ntype TxAPI =\n      \"add-wit-and-submit\"\n    :> ReqBody '[JSON] AddWitAndSubmitParams\n    :> Post '[JSON] SubmitTxResponse\n-- | Serving our API.\nhandleTx :: Ctx -> ServerT TxAPI IO\nhandleTx = handleAddWitAndSubmitTx\n-- | Handle for adding key witness to the unsigned transaction & then submit it.\nhandleAddWitAndSubmitTx :: Ctx -> AddWitAndSubmitParams -> IO SubmitTxResponse\nhandleAddWitAndSubmitTx ctx AddWitAndSubmitParams{..} = do\n  let txBody = getTxBody awasTxUnsigned\n  void $ gySubmitTx (ctxProviders ctx) $ makeSignedTransaction awasTxWit txBody\n  return $ txBodySubmitTxResponse txBody","transaction-building-endpoints#Transaction Building Endpoints":"Entire code for it is available here\nAt this point, it should be easy to follow the code here. We first define the input type for our endpoint, we also derive its FromJSON instance so that we can parse it from JSON that our front-end will send for it and we also derive its Swagger.ToSchema instance so as to document our endpoint. Then our endpoint calls the relevant operation which we defined before to get transactoin skeleton, using which we obtain the transaction body with the help of functions such as runTxI and return the result (wrapped in our UnsignedTxResponse type).\nYou can see that all of our endpoints here ask for a list of used addresses, this makes them compatible with wallets that are not in single address mode (by default) such as Eternl.\n-- | Input wrapper around corresponding Plutus type.\ndata BetRefParams = BetRefParams\n  { brpOracleAddress :: !GYAddress\n  , brpBetUntil      :: !GYTime\n  , brpBetReveal     :: !GYTime\n  , brpBetStep       :: !GYValue\n  } deriving (Show, Generic, FromJSON, Swagger.ToSchema)\n-- | Convert the above `BetRefParams` with corresponding representation defined in our Plutus validator script.\nbetParamsToScript :: BetRefParams -> Script.BetRefParams\nbetParamsToScript brp = Script.BetRefParams\n  { Script.brpOraclePkh = pubKeyHashToPlutus $ fromJust $ addressToPubKeyHash $ brpOracleAddress brp\n  , Script.brpBetUntil = timeToPlutus $  brpBetUntil brp\n  , Script.brpBetReveal = timeToPlutus $ brpBetReveal brp\n  , Script.brpBetStep = valueToPlutus $  brpBetStep brp\n  }\n-- | Input parameters for place bet operation.\ndata PlaceBetRefParams = PlaceBetRefParams\n  { pbrUsedAddrs  :: ![GYAddress]\n  , pbrChangeAddr :: !GYAddress\n  , pbrCollateral :: !(Maybe GYTxOutRefCbor)\n  , pbrBetParams  :: !BetRefParams\n  , pbrBetGuess   :: !Integer\n  , pbrBetAmt     :: !GYValue\n  , pbrRefScript  :: !GYTxOutRef\n  , pbrPrevBetRef :: !(Maybe GYTxOutRef)\n  } deriving (Show, Generic, FromJSON, Swagger.ToSchema)\n-- | Input parameters for take bets operation.\ndata TakeBetRefParams = TakeBetRefParams\n  { tbrUsedAddrs         :: ![GYAddress]\n  , tbrChangeAddr        :: !GYAddress\n  , tbrCollateral        :: !(Maybe GYTxOutRefCbor)\n  , tbrBetParams         :: !BetRefParams\n  , tbrRefScript         :: !GYTxOutRef\n  , tbrPrevBetRef        :: !GYTxOutRef\n  , tbrOracleRefInputRef :: !GYTxOutRef\n  } deriving (Show, Generic, FromJSON, Swagger.ToSchema)\n-- | Input parameters to add for reference script.\ndata AddRefScriptParams = AddRefScriptParams\n  { arsUsedAddrs  :: ![GYAddress]\n  , arsChangeAddr :: !GYAddress\n  , arsCollateral :: !(Maybe GYTxOutRefCbor)\n  , arsPutAddress :: !GYAddress\n  , arsBetParams  :: !BetRefParams\n  } deriving (Show, Generic, FromJSON, Swagger.ToSchema)\n-- | Input parameters to add for reference input.\ndata AddRefInputParams = AddRefInputParams\n  { ariUsedAddrs  :: ![GYAddress]\n  , ariChangeAddr :: !GYAddress\n  , ariCollateral :: !(Maybe GYTxOutRefCbor)\n  , ariPutAddress :: !GYAddress\n  , ariBetAnswer  :: !Integer\n  } deriving (Show, Generic, FromJSON, Swagger.ToSchema)\n-- | Return type for our API endpoints defined here.\ndata UnsignedTxResponse = UnsignedTxResponse\n  { urspTxBodyHex :: !T.Text              -- ^ Unsigned transaction cbor.\n  , urspTxFee     :: !(Maybe Integer)     -- ^ Tx fees.\n  , urspUtxoRef   :: !(Maybe GYTxOutRef)  -- ^ Some operations might need to show for relevant UTxO generated.\n  } deriving (Show, Generic, FromJSON, ToJSON, Swagger.ToSchema)\n-- | Construct `UnsignedTxResponse` return type for our endpoint given the transaction body & relevant index for UTxO (if such exists).\nunSignedTxWithFee :: GYTxBody -> Maybe GYTxOutRef -> UnsignedTxResponse\nunSignedTxWithFee txBody mUtxoRef = UnsignedTxResponse\n  { urspTxBodyHex  = T.pack $ txToHex $ unsignedTx txBody\n  , urspTxFee      = Just $ txBodyFee txBody\n  , urspUtxoRef    = mUtxoRef\n  }\n-- | Type for our Servant API.\ntype BetRefApi =\n       \"place\"\n    :> ReqBody '[JSON] PlaceBetRefParams\n    :> Post    '[JSON] UnsignedTxResponse\n  :<|> \"take\"\n    :> ReqBody '[JSON] TakeBetRefParams\n    :> Post    '[JSON] UnsignedTxResponse\n  :<|> \"add-ref-script\"\n    :> ReqBody  '[JSON] AddRefScriptParams\n    :> Post     '[JSON] UnsignedTxResponse\n  :<|> \"add-ref-input\"\n    :> ReqBody  '[JSON] AddRefInputParams\n    :> Post     '[JSON] UnsignedTxResponse\n-- | Serving our API.\nhandleBetRefApi :: Ctx -> ServerT BetRefApi IO\nhandleBetRefApi ctx =   handlePlaceBet ctx\n                   :<|> handleTakeBet ctx\n                   :<|> handleAddRefScript ctx\n                   :<|> handleOracleRefInput ctx\n-- | Handle for place bet operation.\nhandlePlaceBet :: Ctx -> PlaceBetRefParams -> IO UnsignedTxResponse\nhandlePlaceBet ctx PlaceBetRefParams{..} = do\n  let brp = betParamsToScript pbrBetParams\n  validatorAddress <- runQuery ctx (betRefAddress brp)\n  txBody <- runTxI ctx pbrUsedAddrs pbrChangeAddr pbrCollateral\n              $ placeBet pbrRefScript (betParamsToScript pbrBetParams) (Script.OracleAnswerDatum pbrBetGuess) pbrBetAmt (head pbrUsedAddrs) pbrPrevBetRef\n  placeUtxoRef <- case find (\\utxo -> utxoAddress utxo == validatorAddress) $ utxosToList $ txBodyUTxOs txBody of\n        Nothing -> fail \"Shouldn't happen: No reference for placed bet in body\"\n        Just utxo -> pure $ utxoRef utxo\n  pure $ unSignedTxWithFee txBody $ Just placeUtxoRef\n-- | Handle for take bets operation.\nhandleTakeBet :: Ctx -> TakeBetRefParams -> IO UnsignedTxResponse\nhandleTakeBet ctx TakeBetRefParams{..} = do\n  txBody <- runTxI ctx tbrUsedAddrs tbrChangeAddr tbrCollateral\n              $ takeBets tbrRefScript (betParamsToScript tbrBetParams) tbrPrevBetRef (head tbrUsedAddrs) tbrOracleRefInputRef\n  pure $ unSignedTxWithFee txBody Nothing\n-- | Handle for adding reference script.\nhandleAddRefScript :: Ctx -> AddRefScriptParams  -> IO UnsignedTxResponse\nhandleAddRefScript  ctx AddRefScriptParams{..} = do\n  let validator = betRefValidator' (betParamsToScript arsBetParams)\n  txBody <- runTxI ctx arsUsedAddrs arsChangeAddr arsCollateral\n              $ pure $ addRefScript' arsPutAddress validator\n  let refs   = Limbo.findRefScriptsInBody txBody\n  outRef <- case Map.lookup (Some (validatorToScript validator)) refs of\n                 Nothing  -> fail \"Shouldn't happen: No reference for added Script in body\"\n                 Just ref -> return ref\n  pure $ unSignedTxWithFee txBody $ Just outRef\n-- | Handle for adding reference input.\nhandleOracleRefInput :: Ctx -> AddRefInputParams  -> IO UnsignedTxResponse\nhandleOracleRefInput  ctx AddRefInputParams{..} = do\n  let ourDatumPlutus = Script.OracleAnswerDatum ariBetAnswer\n      ourDatumGY = datumFromPlutusData ourDatumPlutus\n  txBody <- runTxI ctx ariUsedAddrs ariChangeAddr ariCollateral\n              $ pure $ addRefInput' ariPutAddress ourDatumPlutus\n  let utxos = utxosToList $ txBodyUTxOs txBody\n      ourDatumHash = hashDatum ourDatumGY\n      mRefInputUtxo = find (\\utxo ->\n        case utxoOutDatum utxo of\n          GYOutDatumHash dh  -> ourDatumHash == dh\n          GYOutDatumInline d -> ourDatumGY == d\n          GYOutDatumNone     -> False\n        ) utxos\n  case mRefInputUtxo of\n    Nothing               -> fail \"Shouldn't happen: Couldn't find the desired UTxO in Tx outputs\"\n    Just GYUTxO {utxoRef} -> pure $ unSignedTxWithFee txBody $ Just utxoRef","wrap-up#Wrap-Up":"Our both the endpoints file (transaction submition & transaction building) our wrapped up in our Api.hs following the usual servant boilerplate.\n-- | Type for our Servant API.\ntype Api =\n        \"tx\"  :> TxAPI\n  :<|>  \"betref\" :>  BetRefApi\nappApi :: Proxy Api\nappApi = Proxy\napiSwagger  :: Swagger\napiSwagger  = toSwagger appApi\napiServer :: Ctx -> ServerT Api IO\napiServer ctx =\n       handleTx ctx\n  :<|> handleBetRefApi ctx\nNow coming back to our server-main.hs file, we can now understand the highlighted code sections which relates to obtaining the Swagger file (generated from apiSwagger function above) and running up our servant server.\nWe follow simpleCorsResourcePolicy (also allowing Content-Type request header) so that calls by our front-end (which runs on different origin) don't get blocked.\n-- | Getting path for our core configuration.\nparseArgs :: IO FilePath\nparseArgs = do\n  args <- getArgs\n  case args of\n    coreCfg: _ -> return coreCfg\n    _invalidArgument -> fail \"Error: wrong arguments, needed a path to the CoreConfig JSON configuration file\\n\"\nmain :: IO ()\nmain = do\n  putStrLn \"Writing Swagger file ...\"\n  BL8.writeFile \"swagger-api.json\" (encodePretty apiSwagger)\n  putStrLn \"parsing Config ...\"\n  coreCfgPath <- parseArgs\n  coreCfg <- coreConfigIO coreCfgPath  -- Parsing our core configuration.\n  putStrLn \"Loading Providers ...\"\n  withCfgProviders coreCfg \"api-server\"  $ \\providers -> do\n    let port = 8081\n        ctx = Ctx coreCfg providers\n    putStrLn $ \"Starting server at \\n \" <> \"http://localhost:\" <> show port\n    run port $ app ctx\napp :: Ctx -> Application\napp ctx = cors (const $ Just simpleCorsResourcePolicy { corsRequestHeaders = [HttpTypes.hContentType] }) $ serve appApi $ hoistServer appApi (Handler . ExceptT . try)  $ apiServer ctx\nNext we'll see how to call these endpoints in our front-end!"}},"/getting-started/how-to-build":{"title":"How to build?","data":{"":"We currently support GHC version 9.2.8 and compilation is tested with cabal version 3.10.2.0.Besides basic Haskell tooling (GHC and cabal), since we depend upon libraries used in cardano-node, one would need to have additional dependencies as described in this guide related to building node from source. When referring to that guide, for our purposes, section on \"Installing the Haskell environment\" and sections following (& including) \"Downloading the source code for cardano-node\" are irrelevant.Additionally one would need libpq-dev or postgresql installed in their environment otherwise an error suggesting missing pg_config can occur.We build Atlas in our Github CI using environment described here which one can also refer if they encounter a build failure.To verify if environment is configured properly, one can clone Atlas repository from here and run cabal build all to see if build is successful.","building-with-nix#Building with Nix":"Alternatively, we provide a nix shell with all dependencies baked in. Please refer to this guide on how to configure nix and later one can enter development shell via nix develop."}},"/getting-started/integration-tests":{"title":"Integration Tests","data":{"":"We already saw how we can conveniently write tests for our smart contract using our wrapper upon Plutus simple model. But these tests were running against a mock ledger, i.e., we really were just simulating it by having some mock data-structures (say set of UTxOs) which were getting updated on submission of successful transaction. We could however write tests to test against the real node and have it slightly more convenient to program against by spinning up our own private network (privnet for short). Here is the table which outlines the differences between the two approaches:\nTests using PSM Wrapper\tTests using Private Network\tRuns against mock ledger\tRuns against real node\tEach unit test gets fresh set of wallets (having original balance)\tEach subsequent unit test continues upon the effects caused by previous ones\tFast, purer (no IO) & convenient\tSlow as each slot is configured to be 0.1 second\t\nThus these tests are suitable for integration testing.","spinning-up-private-network#Spinning up private network":"To access our private network in Atlas, we'll be using \"Local node with Kupo\" provider and so, cardano-node & Kupo version is expected to be 8.1.2 & 2.7.2 respectively.\nOur private network is adapted from WoofPool's cardano-private-testnet-setup repository.To spin up it up:\nClone this repository. Make sure to not clone it in some deep nested path as then the path length towards the generated socket file (node.sock) may exceed 108 characters.\nEnter it & checkout geniusyield branch.\nEnter the following in terminal: ./scripts/automate.sh (you would need to have cardano-node & cardano-cli available in your PATH).\nOnce it says, \"Congrats! Your network is ready for use!\" we are ready to move forward and setup Kupo.Assuming TESTNET environment variable points to the directory of clone private testnet repository, we can start Kupo with following command:\nkupo \\\n  --node-socket $TESTNET/private-testnet/node-spo1/node.sock \\\n  --node-config $TESTNET/private-testnet/configuration.yaml \\\n  --since origin \\\n  --match \"*\" \\\n  --prune-utxo \\\n  --in-memory\nWe are now complete with our setup. To run tests, execute KUPO_URL=http://localhost:1442 GENIUSYIELD_PRIVNET_DIR=$TESTNET/private-testnet cabal run betref-privnet-tests -- -j1 inside our example project folder.The -j1 is needed so that the tests run sequentially.\nRemember to stop (CTRL-C, and killall cardano-node) the private testnet, or it will eventually eat all of your disk space.\nThe way we have it setup for our test boilerplate is that we have nine users where users second to nine start with the following balances:\n5 UTxOs each containing thousand ada\n1 million each of gold & iron tokens\nFirst user is called \"funder\" as it has far more ada (couple of 100 thousands) and the number of gold & iron tokens is 2 millions.We'll also see how to create a new user soon, if required.\nUnless you kill & restart the private network, running your privnet tests again, would have them run in the modified network state.","understanding-our-first-test#Understanding our first test":"The tests are written in this file and are being called here.\nHere is the code (& explanation follows after it):\n  testCaseSteps \"Balance checks & taking pot by closest guesser should pass\" $ \\info -> withSetup setup info $ \\ctx -> do\n    -- First step: Construct the parameters and obtain validator from it.\n    --\n    -- Let's define a new User to represent Oracle (not necessary though)\n    oracleUser <- newTempUserCtx ctx (ctxUserF ctx) (valueFromLovelace 20_000_000) def\n    (currentSlot, slotConfig) <- getSlotAndConfig ctx\n    let betUntilSlotDelta = 100\n        betRevealSlotDelta = 200\n        betUntilTime = slotToBeginTimePure slotConfig (unsafeAdvanceSlot currentSlot betUntilSlotDelta)\n        betRevealTime = slotToBeginTimePure slotConfig (unsafeAdvanceSlot currentSlot betRevealSlotDelta)\n        brp = BetRefParams (pubKeyHashToPlutus $ userPkh oracleUser) (timeToPlutus betUntilTime) (timeToPlutus betRevealTime) (valueToPlutus $ valueFromLovelace 10_000_000)\n        validator = betRefValidator' brp\n    validatorAddress <- ctxRunC ctx (ctxUserF ctx) $ betRefAddress brp\n    -- Second step: Putting reference script for validator.\n    refScript <- addRefScriptCtx ctx (ctxUserF ctx) (validatorToScript validator)\n    -- Third step: Put some bets.\n    --\n    -- 1st bet.\n    txBodyLock <- ctxRunI ctx (ctxUser3 ctx) $ placeBet refScript brp (OracleAnswerDatum 1) (valueFromLovelace 10_000_000) (userAddr (ctxUser3 ctx)) Nothing\n    lockedORef <- findOutput validatorAddress txBodyLock\n    void $ submitTx ctx (ctxUser3 ctx) txBodyLock\n    -- Balance of `(ctxUser2 ctx)` before placing the bet\n    balance <- ctxQueryBalance ctx (ctxUser2 ctx)\n    --\n    -- 2nd bet.\n    txBodyLockUser2 <- ctxRunI ctx (ctxUser2 ctx) $ placeBet refScript brp (OracleAnswerDatum 2) (valueFromLovelace 20_000_000) (userAddr (ctxUser2 ctx)) (Just lockedORef)\n    lockedORef <- findOutput validatorAddress txBodyLockUser2\n    void $ submitTx ctx (ctxUser2 ctx) txBodyLockUser2\n    --\n    -- 3rd bet.\n    txBodyLock <- ctxRunI ctx (ctxUser3 ctx) $ placeBet refScript brp (OracleAnswerDatum 3) (valueFromLovelace 35_000_000) (userAddr (ctxUser3 ctx)) (Just lockedORef)\n    lockedORef <- findOutput validatorAddress txBodyLock\n    void $ submitTx ctx (ctxUser3 ctx) txBodyLock\n    -- Fourth step, get the bets pot.\n    --\n    -- Let's first wait for the required amount\n    ctxWaitUntilSlot ctx (unsafeAdvanceSlot currentSlot betRevealSlotDelta)  -- here this `currentSlot` is what we obtained sometime ago, the actual current slot has certainly increased a lot by now.\n    --\n    -- Let's then add for the reference input\n    refInputORef <- addRefInputCtx ctx (ctxUserF ctx) True (userAddr oracleUser) (datumFromPlutusData (OracleAnswerDatum 2))\n    --\n    -- Unlock operation\n    txBodyUnlock <- ctxRunI ctx (ctxUser2 ctx) $ takeBets refScript brp lockedORef (userAddr (ctxUser2 ctx)) refInputORef\n    void $ submitTx ctx (ctxUser2 ctx) txBodyUnlock\n    --\n    -- Balance of `(ctxUser2 ctx)` after unlocking\n    let adaExpectedIncrease = valueFromLovelace 45_000_000\n    assertUserFunds (txBodyFee txBodyUnlock + txBodyFee txBodyLockUser2) ctx (ctxUser2 ctx) $ balance <> adaExpectedIncrease\nThe first line testCaseSteps \"test description\" $ \\info -> withSetup setup info $ \\ctx -> do can be seen as a boilerplate for all of your tests.ctx denotes the so called context (of type Ctx) and contains information about our users, additional tokens, etc. It is defined in GeniusYield.Test.Privnet.Ctx module and it is essential to go over that module if you intend to write these tests.Variable info is used to log messages and you can use it in your test's do block like info $ printf \"Hello from %s\" \"Atlas\"We next see the use of newTempUserCtx utility function. As mentioned before, we already have nine users in our context, where they have the type User:\ndata User = User\n    { userPaymentSKey :: !GYPaymentSigningKey\n    , userStakeSKey   :: !(Maybe GYStakeSigningKey)\n    , userAddr        :: !GYAddress\n    }\nBut at rare times, we might need to create a new user. Such a user would not be part of the context and thus would be local to the test creating it.We can do that with the help of newTempUserCtx function. It accepts the context parameter, the user which will fund this new user, the value to be given to this new user and a value of type CreateUserConfig.Next we see the use of getSlotAndConfig function. Earlier when we wrote for PSM tests, we could work in absolute slots as we were always running each test from the beginning of ledger but this is not the case here. Thus, we would need to work with relative slots, i.e., we find the current slot and then add offset with respect to it. Function getSlotAndConfig has the following definition:\ngetSlotAndConfig :: Ctx -> IO (GYSlot, GYSlotConfig)\ngetSlotAndConfig ctx = do\n  slot <- ctxCurrentSlot ctx\n  sc   <- ctxSlotConfig ctx\n  return (slot, sc)\nNext we compute for our contract parameters and since we already obtained the slot config, we can use slotToBeginTimePure instead of slotToBeginTime.We next see the use of ctxRunC. To understand it, we need to first look at signature of ctxRunF.\nctxRunF :: forall t v. Traversable t => Ctx -> User -> GYTxMonadNode (t (GYTxSkeleton v)) -> IO (t GYTxBody)\nWe see that it has a type variable t which should have an instance of Traversable. The other two functions, namely ctxRunC & ctxRunI call this ctxRunF function with suitable instantiation of type variable t.Here is the table which explains about these three (ctxRunF, ctxRunC & ctxRunI) related functions:\nFunction\tWhen to use?\tWhat does it do?\tctxRunI\tWhen you want to build for single GYTxSkeleton\tIt wraps our skeleton under Identity, that is what suffix I stands for\tctxRunF\tWhen you have say multiple skeletons, like [GYTxSkeleton], or Maybe GYTxSkeleton\t-\tctxRunC\tWhen you don't want to build skeletons. This is in particular useful for operations like utxosAtAddress\tThe type constructor Const is defined as newtype Const a b = Const { getConst :: a } and therefore type parameter b is phantom and thus this function helps us ignore for GYTxSkeleton\t\nWe next add for reference script using helper utility function addRefScriptCtx.We then start placing our bets, once we have the transaction body, we use findOutput function which gives us the reference to the UTxO (the first one it finds) that is being locked at the script address.After placing our bets, we use ctxWaitUntilSlot to wait till the unlock slot.Note that we queried the balance of unlocker so that we can compare with it later.We next add for our reference input using addRefInputCtx helper utility function.Next we perform the unlock operation (calling our takeBets operation).Lastly, we verify that the unlocker was able to take all the bets by comparing the balance using assertUserFunds method. Here is it's definition:\n-- | Asserts if the user funds change as expected. This function subtracts fees from the given expected value.\nassertUserFunds :: Integer -> Ctx -> User -> GYValue -> IO ()\nassertUserFunds fees ctx u expectedValue = do\n    currentValue <- ctxQueryBalance ctx u\n    let expectedValue' = expectedValue `valueMinus` valueFromLovelace fees\n    assertBool (unwords [\"The value didn't change as expected\",\n                         \"\\nExpected: \", show expectedValue',\n                         \"\\nCurrent: \", show currentValue])\n               (currentValue == expectedValue')","writing-a-failing-test#Writing a failing test":"Now let's see another test where we slightly modify the last step (all the rest is same) and this time we instead try to take funds by not the closest guesser.\n  -- Fourth step, get the bets pot.\n  --\n  -- Let's first wait for the required amount\n  ctxWaitUntilSlot ctx (unsafeAdvanceSlot currentSlot betRevealSlotDelta)  -- here this `currentSlot` is what we obtained sometime ago, the actual current slot has certainly increased a lot by now.\n  --\n  -- Let's then add for the reference input\n  refInputORef <- addRefInputCtx ctx (ctxUserF ctx) True (userAddr oracleUser) (datumFromPlutusData (OracleAnswerDatum 2))\n  --\n  -- Unlock operation\n  -- But this time by wrong guesser\n  assertThrown isTxBodyErrorAutoBalance $ ctxRunI ctx (ctxUser3 ctx) $ takeBets refScript brp lockedORef (userAddr (ctxUser3 ctx)) refInputORef\nNotice that we try catching the error using assertThrown function. Here isTxBodyErrorAutoBalance is defined as (both this & assertThrown have their definitions in GeniusYield.Test.Privnet.Asserts module):\nisTxBodyErrorAutoBalance :: BuildTxException -> Bool\nisTxBodyErrorAutoBalance (BuildTxBodyErrorAutoBalance _) = True\nisTxBodyErrorAutoBalance _                               = False\nThus our assertThrown function checks for two things:\nWhether our action indeed raises an exception.\nIf an exception is raised, does it satisfy our predicate? For instance, here our predicate was isTxBodyErrorAutoBalance.\nYou can also catch for IO error like:\n  errored <- catchIOError (submitTx ctx (ctxUserF ctx) txBody >> pure False) (\\_ -> pure True)\n  unless errored $ assertFailure \"Expecting an IOError exception\"\nWith this we conclude upon writing integration tests.For convenience, you can write a bash script which combines setup, running tests & closing the privnet all into one simple script.Even though this user is local to the test which created it, it would still persist in our private network.Technically, it's not wrapper that is happening place here but rather we coerce with Identity newtype.Therefore this function is intended to be used when we create only a single output for an external address.https://unix.stackexchange.com/q/367008."}},"/getting-started/operations":{"title":"Operations over Contract","data":{"":"Having understood the contract. Now is the time we actually start using our framework to build the transactions for it.The main principle to understand here is that - we only need to give the essentials, i.e. we only specify what we want and it is the job of the framework to do the rest.For instance, we may tell that we want to consume a specific input belonging to the script's address and generate a specific output. Given that, it becomes framework's job to do the rest, say:\nSelect available UTxO's in user's wallet and generate suitable change output to balance the transaction, considering fees.\nMake sure all generated UTxO's satisfy minimum ada requirement.\nHandle collateral.\netc, etc.\nThus, we only specify at high-level what we want. This would become clear as we actually start writing operations for our contract.Entire code for these operations is available here.\nWhen working with Atlas inside your project, since Atlas isn't on Hackage, you'll need to specify it as a remote package inside your cabal.project. Moreover, since Atlas itself relies on dependencies which are outside Hackage, those would need to be specified too. To streamline this, it's best to use the cabal.project mentioned in atlas-examples repository where you would just need to modify packages: stanza depending upon your project.","operation-1-generating-address-for-our-smart-contract#Operation 1: Generating address for our Smart Contract":"","generating-validator-for-our-smart-contract#Generating Validator for our Smart Contract":"Following the usual drill, we generate the Validator given contract parameters (following is written in file Compiled.hs):\n-- | Generates validator given params.\nbetRefValidator :: BetRefParams -> PlutusTx.CompiledCode (PlutusTx.BuiltinData -> PlutusTx.BuiltinData -> PlutusTx.BuiltinData -> ())\nbetRefValidator betRefParams =\n    $$(PlutusTx.compile [|| mkBetRefValidator||]) `PlutusTx.unsafeApplyCode` PlutusTx.liftCode plcVersion100 betRefParams\nNote that since spending validator takes in a datum, redeemer and a script context and thus it's type signature, PlutusTx.CompiledCode (PlutusTx.BuiltinData -> PlutusTx.BuiltinData -> ()) takes three PlutusTx.BuiltinData. We encapsulate it with GYValidator inside framework.Likewise minting policies and stake validators take in only redeemer and script context, thus having type PlutusTx.CompiledCode (PlutusTx.BuiltinData -> PlutusTx.BuiltinData -> PlutusTx.BuiltinData -> ()) which is represented in Atlas as GYMintingPolicy and GYStakeValidator respectively.GYValidator, GYMintingPolicy and GYStakeValidator are nothing but newtype wrapper around GYScript where GYScript holds information of raw serialized Plutus script, version of Plutus ledger language and script's hash.Thus encapsulating GYScript under say GYValidator gives us additional context regarding script's purpose.\nCheckout GeniusYield.Types.Script module for definitions of these types and corresponding helper utilities.\nThe mentioned GeniusYield.Types.Script module contains a lot of helper utilities such as validatorFromPlutus which takes in Plutus's PlutusTx.CompiledCode (PlutusTx.BuiltinData -> PlutusTx.BuiltinData -> PlutusTx.BuiltinData -> ()) type to give out GYValidator. Though there has been slight abuse in mentioning type here as what is actually given out is GYValidator v where type variable v is of kind PlutusVersion which is defined in GeniusYield.Types.PlutusVersion module and is used to tag plutus ledger version of our validator script.If we look at the type signature of validatorFromPlutus, we see: validatorFromPlutus :: forall v. SingPlutusVersionI v => PlutusTx.CompiledCode (PlutusTx.BuiltinData -> PlutusTx.BuiltinData -> PlutusTx.BuiltinData -> ()) -> GYValidator v where for the time being we can ignore the description of the typeclass SingPlutusVersionI besides noting the fact that only types (currently 'PlutusV1 & 'PlutusV2) of kind PlutusVersion have an instance for it. So here, our function validatorFromPlutus works for all type variable v which have an instance of SingPlutusVersionI but there is no way to learn what this v is based solely on the input PlutusTx.CompiledCode (PlutusTx.BuiltinData -> PlutusTx.BuiltinData -> PlutusTx.BuiltinData -> ()) and therefore, caller must specify it, either by providing type signature (of callee or caller due to type inference) or by using visible type application. Our first operation does make use of it but before looking at it, we need to understand about GYTxQueryMonad.","interlude---gytxquerymonad#Interlude - GYTxQueryMonad":"When we want to obtain the address of the script from its hash, besides the hash, we also need to know the network we are currently operating at. Is it some testnet or mainnet?Similarly, transaction building involves querying the ledger for various information like say querying UTxO's present at one's address, similarly it might need help of some chain indexer to query datum in case output contains only the datum's hash.All of this is captured by typeclass GYTxQueryMonad documented here. It is strongly advised to see methods made available by it.So, if we are working inside a monad which happens to also provide an instance for it, we would happily be able to query such an information.","generating-address#Generating address":"In this operation, we only need to obtain network details with the help of this monad. Here is the code to obtain address (notice that we have provided multiple versions of the same code here):\nType of scriptAddress used below is scriptAddress :: forall (m :: * -> *) (v :: PlutusVersion). GYTxQueryMonad m => GYValidator v -> m GYAddress. Thus with respect to type application, the first parameter is for monad and second one is PlutusVersion kinded.Internally this function queries for network details.\n-- A. Type is given by `scriptAddress`.\n-- | Validator in question, obtained after giving required parameters.\nbetRefValidator' ::  SingPlutusVersionI v => BetRefParams -> GYValidator v\nbetRefValidator' brp = validatorFromPlutus $ betRefValidator brp\n-- | Address of the validator, given params.\nbetRefAddress :: (HasCallStack, GYTxQueryMonad m) => BetRefParams -> m GYAddress\nbetRefAddress brp = scriptAddress @_ @'PlutusV2 $ betRefValidator' brp\n-- B. Type is given by `validatorFromPlutus` using type application.\n-- | Validator in question, obtained after giving required parameters.\nbetRefValidator' brp = validatorFromPlutus @'PlutusV2 $ betRefValidator brp\n-- | Address of the validator, given params.\nbetRefAddress :: (HasCallStack, GYTxQueryMonad m) => BetRefParams -> m GYAddress\nbetRefAddress brp = scriptAddress $ betRefValidator' brp\n-- C. Type is specified using signature.\n-- | Validator in question, obtained after giving required parameters.\nbetRefValidator' :: BetRefParams -> GYValidator 'PlutusV2\nbetRefValidator' brp = validatorFromPlutus $ betRefValidator brp\n-- | Address of the validator, given params.\nbetRefAddress :: (HasCallStack, GYTxQueryMonad m) => BetRefParams -> m GYAddress\nbetRefAddress brp = scriptAddress $ betRefValidator' brp\nWell what is this monad m being used here? Well any! As long as it has an instance for GYTxQueryMonad. When we will start writing tests, then we'll use all of these operations and most likely how to use them would become clear then.","operation-2-adding-input-to-refer-later-reference-input#Operation 2: Adding Input to refer later (Reference Input)":"","interlude---gytxskeleton#Interlude - GYTxSkeleton":"As mentioned before, we just mention at high level what we want in a transaction. This is captured by GYTxSkeleton datatype and its description is mentioned below.\nFields\tRepresented by\tAdditional details\tInputs\tgytxIns\tIt is a list of inputs where for each input, we have its UTxO reference (the \"TxIn\" as the cardano ledger specification calls it) and a witness. In case this UTxO doesn't belong to a script, we just need spending key witness, otherwise we need the associated script, its datum and input redeemer where the associated script could be provided as part of this transaction body or could be obtained from reference input. See GeniusYield.Types.TxIn.\tOutputs\tgytxOuts\tList of outputs produced by this transaction where for each output we can mention whether the datum is to be inlined or not and whether this output stores any script. See GeniusYield.Types.TxOut.\tReference Inputs\tgytxRefIns\tSet of reference to UTxOs corresponding to reference inputs.\tMints\tgytxMint\tMap of minting policy to pair of redeemer and another map for token name to mint amount for that token.\tWithdrawals\tgytxWdrls\tIt is a list of withdrawals. Each withdrawal is specified by the concerned stake address with it's associated available rewards and witness. Witness could either be a key witness or a script witness.\tSignatories\tgytxSigs\tSet of Public Key Hash of Signatories.\tCertificates\tgytxCerts\tList of transaction certificates.\tValid after\tgytxInvalidBefore\tJust the corresponding node slot.\tValid before\tgytxInvalidAfter\tSame as above.\tMetadata\tgytxMetadata\tTransaction metadata.\t\nWhen constructing the transaction, we just need to specify what we want in this skeleton.This skeleton naturally has a monoid instance where two skeletons are combined by running mappend over each of their fields. We have utility functions defined in the same (GeniusYield.TxBuilder.Class) module like:\nmustHaveOutput :: GYTxOut v -> GYTxSkeleton v\nmustHaveOutput o = emptyGYTxSkeleton {gytxOuts = [o]}\nmustHaveInput :: GYTxIn v -> GYTxSkeleton v\nmustHaveInput i = emptyGYTxSkeleton {gytxIns = [i]}\nmustHaveRefInput :: VersionIsGreaterOrEqual v PlutusV2 => GYTxOutRef -> GYTxSkeleton v\nmustHaveRefInput i = emptyGYTxSkeleton { gytxRefIns = GYTxSkeletonRefIns (Set.singleton i) }\nmustMint :: GYMintingPolicy u -> GYRedeemer -> GYTokenName -> Integer -> GYTxSkeleton v\nmustMint p r tn n = emptyGYTxSkeleton {gytxMint = Map.singleton (Some p) (Map.singleton tn n, r)}\nmustBeSignedBy :: GYPubKeyHash -> GYTxSkeleton v\nmustBeSignedBy pkh = emptyGYTxSkeleton {gytxSigs = Set.singleton pkh}\nisInvalidBefore :: GYSlot -> GYTxSkeleton v\nisInvalidBefore s = emptyGYTxSkeleton {gytxInvalidBefore = Just s}\nisInvalidAfter :: GYSlot -> GYTxSkeleton v\nisInvalidAfter s = emptyGYTxSkeleton {gytxInvalidAfter = Just s}\nmustHaveTxMetadata :: Maybe GYTxMetadata -> GYTxSkeleton v\nmustHaveTxMetadata m = emptyGYTxSkeleton {gytxMetadata = m}\nmustHaveWithdrawal :: GYTxWdrl v -> GYTxSkeleton v\nmustHaveWithdrawal w = mempty {gytxWdrls = [w]}\nmustHaveCertificate :: GYTxCert v -> GYTxSkeleton v\nmustHaveCertificate c = mempty {gytxCerts = [c]}\nThus we can specify that our transaction must have this output (using mustHaveOutput) and that output and must have this input (using mustHaveInput) and so on... and combine them all into a single skeleton using mappend.","skeleton-for-adding-reference-input#Skeleton for adding reference input":"Here we want to create an output at a given address (Oracle's address) with the given datum. This UTxO is to be later used as a reference input by script where the script would refer to its datum. Here we have decided to keep this datum inline.\n-- | Add UTxO to be used as reference input at a given address with given datum.\naddRefInput :: GYAddress -> OracleAnswerDatum -> GYTxSkeleton 'PlutusV2\naddRefInput addr dat =\n  mustHaveOutput $ GYTxOut addr mempty (Just (datumFromPlutusData dat, GYTxOutUseInlineDatum)) Nothing\n  -- Note that the value can be empty as tx building logic would add the needed minimum UTxO ada.\nNote that we have mentioned the value as empty for this UTxO and this is one of the beauties of our framework that it will itself manage adding lovelaces to satisfy minimum ada requirement.","q-can-you-create-a-skeleton-for-adding-reference-script#Q: Can you create a skeleton for adding reference script?":"Toggle Answer \nGiven the output address addr :: GYAddress{:haskell} and the Plutus V2 validator script :: GYValidator 'PlutusV2{:haskell}, we can write mustHaveOutput $ GYTxOut addr mempty (Just (datumFromPlutusData (), GYTxOutDontUseInlineDatum)) (Just $ validatorToScript script){:haskell}","operation-3-placing-a-bet#Operation 3: Placing a bet":"","placing-the-first-bet#Placing the first bet":"In case this is a first bet (a program handling the bets can decide whether the bet being placed by the user is first or not by querying the UTxOs at the script address), then we just need to produce an output at the script address with the bet value and our guess.\n-- | Operation to place bet.\nplaceBet :: (HasCallStack, GYTxMonad m)\n              => GYTxOutRef         -- ^ Reference Script.\n              -> BetRefParams       -- ^ Validator Params.\n              -> OracleAnswerDatum  -- ^ Guess.\n              -> GYValue            -- ^ Bet amount to place.\n              -> GYAddress          -- ^ Own address.\n              -> Maybe GYTxOutRef   -- ^ Reference to previous bets UTxO (if any).\n              -> m (GYTxSkeleton PlutusV2)\nplaceBet refScript brp guess bet ownAddr mPreviousBetsUtxoRef = do\n  pkh <- addressToPubKeyHash' ownAddr\n  betAddr <- betRefAddress brp\n  case mPreviousBetsUtxoRef of\n    -- This is the first bet.\n    Nothing -> do\n      return $ mustHaveOutput $ GYTxOut\n        { gyTxOutAddress = betAddr\n        , gyTxOutValue = bet\n        , gyTxOutDatum = Just (datumFromPlutusData $ BetRefDatum [(pubKeyHashToPlutus pkh, guess)] (valueToPlutus bet), GYTxOutDontUseInlineDatum)\n        , gyTxOutRefS    = Nothing\n        }\nAt this point, it should be clear what is happening in the above code block. This function is somewhat overloaded and is handling both the cases whether the bet is first or not and it determines this using the presence of reference to a UTxO (representing previous bets) at validator script. In case there isn't one, i.e., Nothing for our Maybe value, we are placing the first bet. Notice that we mention that our datum shouldn't be inlined to output using GYTxOutDontUseInlineDatum.","placing-subsequent-bets#Placing subsequent bets":"Here we would be exercising script's logic for the first time. We would be consuming the UTxO present at script address. We have defined a function, viz. input which would take in the following parameters:\nBetRefParams: to generate the validator script or else we can read the script from the UTxO pertaining to reference script.\nReference to reference script UTxO.\nReference of script input to consume.\nThe datum present at this input. Recall that our datum was not inlined for this particular output, we therefore would need lookup the datum using lookupDatum to pass the actual datum to this function.\nRedeemer action.\nThus, we have its definition as:\n-- | Utility function to consume script UTxO.\ninput :: BetRefParams -> GYTxOutRef -> GYTxOutRef -> BetRefDatum -> BetRefAction -> GYTxSkeleton 'PlutusV2\ninput brp refScript inputRef dat red =\n  mustHaveInput GYTxIn\n    { gyTxInTxOutRef = inputRef\n    , gyTxInWitness  = GYTxInWitnessScript\n        (GYInReference refScript $ validatorToScript $ betRefValidator' brp)\n        (datumFromPlutusData dat)\n        (redeemerFromPlutusData red)\n    }\nIn case we didn't want to use reference script, we would write gyTxInWitness as:\ngyTxInWitness  = GYTxInWitnessScript\n        (GYInScript (validatorToScript $ betRefValidator' brp))\n        (datumFromPlutusData dat)\n        (redeemerFromPlutusData red)\nFollowing is the complete code for handling this case. Few comments to facilitate its understanding:\nWe first query the UTxO corresponding to previous bets at script address and we then query for its datum using utxoDatum' which tries its best to retrieve the datum and raises an exception in case it fails. This is its signature: utxoDatum' :: (GYTxQueryMonad m, Plutus.FromData a) => GYUTxO -> m (GYAddress, GYValue, a).\nNote: utxoAtTxOutRef' is a wrapper around utxoAtTxOutRef which raises an exception in case the result was Nothing.\nWe then see the use of gyLogDebug' which as you would expect is for logging purposes. The first argument that it takes correspond to namespace as used by Katip. This is where integration of off-chain and on-chain code really begins to shine âœ¨, having the Show instance defined for some of our on-chain types allows us to log them.\ntimeFromPlutus is as you'll expect - gives us the framework's representation of time from that of plutus. And enclosingSlotFromTime' uses ledger's information to determine the corresponding slot for the given time. We need this as cardano's node work in slots. We mention that our transaction is to be invalid after this slot using isInvalidAfter.\nWe mention that our transaction must have our public key hash as signatories when plutus smart contract asks for it using mustBeSignedBy.\nLastly, this transaction must generate an output to the script's address with the updated datum and added value.\nvalueToPlutus gives the corresponding value type used by plutus from what we have in our framework (viz., GYValue).\nAll these skeletons are combined together using mappend defined for GYTxSkeleton.\n    -- Need to append to previous.\n    Just previousBetsUtxoRef -> do\n      previousUtxo <- utxoAtTxOutRef' previousBetsUtxoRef\n      (_addr, previousValue, dat@(BetRefDatum previousGuesses _previousBet)) <- utxoDatum' previousUtxo\n      gyLogDebug' \"\" $ printf \"previous guesses %s\" (show previousGuesses)\n      betUntilSlot <- enclosingSlotFromTime' (timeFromPlutus $ brpBetUntil brp)\n      gyLogDebug' \"\" $ printf \"bet until slot %s\" (show betUntilSlot)\n      return $\n           input brp refScript previousBetsUtxoRef dat (Bet guess)\n        <> mustHaveOutput GYTxOut\n              { gyTxOutAddress = betAddr\n              , gyTxOutValue = bet <> previousValue\n              , gyTxOutDatum = Just (datumFromPlutusData $ BetRefDatum ((pubKeyHashToPlutus pkh, guess) : previousGuesses) (valueToPlutus bet), GYTxOutDontUseInlineDatum)\n              , gyTxOutRefS    = Nothing\n              }\n        <> isInvalidAfter betUntilSlot\n        <> mustBeSignedBy pkh","operation-4-taking-the-bet-pot#Operation 4: Taking the bet pot":"At this point, reading following code snippet should make sense as it is similar to what we have done before. Here note that we are using mustHaveRefInput to tell that the transaction must have the following UTxO reference as a reference input.\nObserve that we don't need to specify that the value we successfully consume from the script's UTxO must reach us because transaction balancer would add the change output to us.\n-- | Operation to take UTxO corresponding to previous bets.\ntakeBets :: (HasCallStack, GYTxMonad m)\n              => GYTxOutRef    -- ^ Reference Script.\n              -> BetRefParams  -- ^ Validator params.\n              -> GYTxOutRef    -- ^ Script UTxO to consume.\n              -> GYAddress     -- ^ Own address.\n              -> GYTxOutRef    -- ^ Oracle reference input.\n              -> m (GYTxSkeleton PlutusV2)\ntakeBets refScript brp previousBetsUtxoRef ownAddr oracleRefInput = do\n  pkh <- addressToPubKeyHash' ownAddr\n  previousUtxo <- utxoAtTxOutRef' previousBetsUtxoRef\n  (_addr, _previousValue, dat) <- utxoDatum' previousUtxo\n  betRevealSlot <- enclosingSlotFromTime' (timeFromPlutus $ brpBetReveal brp)\n  return $\n       input brp refScript previousBetsUtxoRef dat Take\n    <> isInvalidBefore betRevealSlot\n    <> mustHaveRefInput oracleRefInput\n    <> mustBeSignedBy pkh","additional-useful-features#Additional Useful Features":"","utxosdatums#utxosDatums":"Sometimes we want to see all valid UTxOs at our script address. In Cardano, anyone can form UTxO at any address and such a UTxO need not have valid datum as required by our script. utxosDatums can be used wither out invalid ones. See it's usage in Vesting example.","mustmint#mustMint":"We weren't minting any tokens in our example here and thus didn't make use of mustMint skeleton function. It's sample usage is given in this example. Which also illustrates how one can mint NFT and shows usage of someUTxO function which essentially gives some random UTxO belonging to wallet.","withdrawals-stake-validator--stake-certificates#Withdrawals, Stake Validator & Stake Certificates":"We haven't made use of withdrawals, stake certificates and stake validators in our example. A sample illustration is provided in this privnet test.This is making use of \"singletons\" and one can read about it from the \"Dependent Types\" chapter (the last one) in Thinking with Types book."}},"/getting-started/smart-contract-intro":{"title":"Smart Contract","data":{"":"Let's now start by writing a smart contract that we will use to convey framework's important features.\nThis contract is for illustrative purposes only. We do not recommend using it in a production environment.\nHere we'll be writing our smart contract in Haskell but do note that we are not limited to it. You for instance could write your smart contract in any language of your choice and read the compiled CBOR using scriptFromCBOR function defined here (Operations over Contract chapter explains about types such as GYScript, PlutusVersion which are used in this function). Similarly, there is readScript defined in the same file to read from the compiled text envelope file.","contract-description#Contract Description":"A setting here is that we have a sport match happening and a group of friends want to bet on the number of goals scored by their favorite team in it.Winner is the one whose guess is closest (and in case of tie - the one who takes it fastest!).The smart contract code is available here. This example was inspired by MLabs.\nSince the underlying version of plutus library we are using defaults to version 1.1.0 of plutus core, we need to explicitly set target-version to 1.0.0, and that is why there is ghc-options: -fplugin-opt PlutusTx.Plugin:target-version=1.0.0 in our cabal file.","contract-parameters#Contract Parameters":"brpOraclePkh :: PubKeyHash: We'll be using a reference input, and its datum will give us the actual result (the number of goals). Since the reference input UTxO must belong to Oracle, we check it using Oracle's payment public key hash.\nbrpBetUntil :: POSIXTime: Time until which bets can be placed.\nbrpBetReveal :: POSIXTime: Time that the Oracle will reveal the match results.\nbrpBetStep :: Value: Minimum value that bets must increase by.\nThus, the parameters of our contract are given by:\n-- | Our contract is parameterized with this.\ndata BetRefParams = BetRefParams\n  { brpOraclePkh :: PubKeyHash  -- ^ Oracle's payment public key hash. This is needed to assert that UTxO being looked at indeed belongs to the Oracle.\n  , brpBetUntil  :: POSIXTime   -- ^ Time until which bets can be placed.\n  , brpBetReveal :: POSIXTime   -- ^ Time at which Oracle will reveal the correct match result.\n  , brpBetStep   :: Value       -- ^ Each newly placed bet must be more than previous bet by `brpBetStep` amount.\n  }\nPlutusTx.makeLift ''BetRefParams","reference-input-datum#Reference Input Datum":"The Oracle tells us the number of goals scored by the concerned team:\n-- | Goals made my the concerned team.\ntype TeamGoals = Integer\n-- | Match result given by the Oracle.\nnewtype OracleAnswerDatum = OracleAnswerDatum TeamGoals deriving newtype (Eq, Show)\nPlutusTx.unstableMakeIsData ''OracleAnswerDatum","contract-datum#Contract Datum":"It consists of two fields:\nList containing each person's guess along with their payment public key hash. Key hash is used to tie guess with the guesser. Every time a new guess is made, we prepend it to this list.\nThis key hash is obtained from transaction signatories - we insist on key hash being present in signatories as otherwise anyone may override bet of someone else.\nAmount denoting the previously placed bet. Note that the total value in the UTxO belonging to contract is the culmination of all the previously placed bets and thus it isn't in general equal to last placed bet. We use this to assert that the newly placed bet is more than the previous one by brpBetStep amount.\n-- | List of guesses by users along with the maximum bet placed yet. A new guess gets /prepended/ to this list. Note that since we are always meant to increment previously placed bet with `brpBetStep`, the newly placed bet would necessarily be maximum (it would be foolish to initialize `brpBetStep` with some negative amounts).\ndata BetRefDatum = BetRefDatum\n  { brdBets        :: [(PubKeyHash, OracleAnswerDatum)]\n  , brdPreviousBet :: Value\n  }\nPlutusTx.unstableMakeIsData ''BetRefDatum","contract-redeemer#Contract Redeemer":"There are two actions available to user:\nTo place a bet - in which case they give their guess.\nTo take the bets in the pot after the result is out.\nThis is therefore codified as:\n-- | Redeemer representing choices available to the user.\ndata BetRefAction = Bet !OracleAnswerDatum  -- ^ User makes a guess.\n                  | Take                    -- ^ User takes the pot.\nPlutusTx.unstableMakeIsData ''BetRefAction","contract-logic#Contract Logic":"","placing-a-bet#Placing a bet":"Initial bet gets placed as it is (in Cardano, spending validator script is executed only when spending an UTxO belonging to it but not for creating at it).For subsequent bets, we require three conditions:\nThe bet must be before (inclusive) the brpBetUntil time.\nThere must be exactly one continuing output at the script address whose datum shall have the current guess prepended to it along with the current bet amount.\nThe current bet must be more than the previous bet by at least brpBetStep amount.\nThis is coded as:\n{-# INLINABLE mkBetRefValidator' #-}\n-- | Core smart contract logic. Read its description from Atlas guide.\nmkBetRefValidator' :: BetRefParams -> BetRefDatum -> BetRefAction -> ScriptContext -> Bool\nmkBetRefValidator' (BetRefParams oraclePkh betUntil betReveal betStep) (BetRefDatum previousGuesses previousBet) brAction ctx =\n  case brAction of\n    Bet guess  ->\n      let\n        sOut = case getContinuingOutputs ctx of\n          [sOut']        -> sOut'\n          _anyOtherMatch -> traceError \"Expected only one continuing output.\"\n        outValue = txOutValue sOut\n        sIn = maybe (traceError \"Could not find own input\") txInInfoResolved (findOwnInput ctx)\n        inValue = txOutValue sIn\n        (guessesOut, betOut) = case outputToDatum sOut of\n          Nothing                                -> traceError \"Could not resolve for script output datum\"\n          Just (BetRefDatum guessesOut' betOut') -> (guessesOut', betOut')\n      in\n        traceIfFalse\n          \"Must be before `BetUntil` time\"\n            (to betUntil `contains` validRange) &&\n        traceIfFalse\n          \"Guesses update is wrong\"\n            ((signerPkh, guess) : previousGuesses == guessesOut) &&\n        traceIfFalse\n          \"The current bet must be more than the previous bet by atleast `brpBetStep` amount\"\n            (outValue `geq` (inValue <> previousBet <> betStep)) &&\n        traceIfFalse\n          \"Out bet is wrong\"\n            (betOut == outValue - inValue)\nWhere we have the following common helpers for both the redemeer actions:\n  where\n    info :: TxInfo\n    info = scriptContextTxInfo ctx\n    validRange :: POSIXTimeRange\n    validRange = txInfoValidRange info\n    signerPkh :: PubKeyHash\n    signerPkh = case txInfoSignatories info of\n      [signerPkh']   -> signerPkh'\n      []             -> traceError \"No signatory\"\n      _anyOtherMatch -> traceError \"Expected only one signatory\"\n    outputToDatum :: FromData b => TxOut -> Maybe b\n    outputToDatum o = case txOutDatum o of\n      NoOutputDatum      -> Nothing\n      OutputDatum d      -> processDatum d\n      OutputDatumHash dh -> processDatum =<< findDatum dh info\n      where processDatum = fromBuiltinData . getDatum","taking-the-bet-pot#Taking the bet pot":"In this case we require the following four conditions:\nThis operation must occur after (inclusive) brpBetReveal time.\nThe script must get fully spend, i.e., there shouldn't be any continuing outputs to this script address.\nThe reference input whose datum is used to see actual answer should belong to concerned Oracle.\nGuess should be closest among all.\nThis is therefore coded as:\n    Take ->\n      let\n        Just guess = find ((== signerPkh) . fst) previousGuesses  -- Note that `find` returns the first match. Since we were always prepending, this is valid.\n        oracleIn = case filter (isNothing . txOutReferenceScript) (txInInfoResolved <$> txInfoReferenceInputs info) of\n          [oracleIn']    -> oracleIn'\n          []             -> traceError \"No reference input provided\"\n          _anyOtherMatch -> traceError \"Expected only one reference input\"\n        oracleAnswer = case outputToDatum oracleIn of\n          Nothing                                  -> traceError \"Could not resolve for datum\"\n          (Just (OracleAnswerDatum oracleAnswer')) -> oracleAnswer'\n        guessDiff = getGuessDiff $ snd guess\n        getGuessDiff (OracleAnswerDatum g) = abs (oracleAnswer - g)\n        oracleInPkh = case toPubKeyHash (txOutAddress oracleIn) of\n          Nothing  -> traceError \"Not PKH for oracle address\"\n          Just pkh -> pkh\n      in\n        traceIfFalse\n          \"Must be after `RevealTime`\"\n            (from betReveal `contains` validRange) &&\n        traceIfFalse\n          \"Must fully spend Script\"\n            (null (getContinuingOutputs ctx)) &&\n        traceIfFalse\n          \"Reference input must be from Oracle address (wrt Payment part)\"\n            (oracleInPkh == oraclePkh) &&\n        traceIfFalse\n          \"Guess is not closest\"\n            (all (\\pg -> getGuessDiff (snd pg) >= guessDiff) previousGuesses)\nAnd lo behold! This is our contract.For instance, here we assert that UTxO being used as reference input must belong to Oracle's address but do note that anyone can create an UTxO at Oracle's address."}},"/getting-started/unit-tests":{"title":"Unit Tests","data":{"":"Writing smart contracts & writing tests go hand in hand. Tests are also an excellent way to conveniently check working of our smart contract instead of building transactions using cardano-cli and submitting them to local node.Now that we have written our smart contract and defined the required operations over it, let's see whether its working as expected.Our test suite is a wrapper around Plutus simple model which is created by MLabs.\nMLabs is working on an evolution of PSM, namely CLB which is intended to work exclusively with Atlas. Thus, we have deprecated support of PSM and would soon document overhaul of this test suite. If you would like to avoid using PSM and wait till CLB is ready, you can skip to next section, namely, Integration Tests.Currently our PSM wrapper does not support operations related to staking, namely, stake key registration, delegation, de-registration and rewards withdrawal.","why-not-just-use-plutus-simple-model-instead-of-the-wrapper#Why not just use \"Plutus simple model\" instead of the wrapper?":"Reusability: Well firstly to maintain compatibility with our toolchain. For instance, our operations were making use of GYTxQueryMonad monad and thus to be able to reuse those same operations we would need to define an instance for it.\nAdditional checks: But secondly and more importantly, plutus simple model lacks some basic checks, for instance:\nWhether a UTxO satisfies minimum ada requirement.\nTransaction fees requirement.\nTransaction signatures requirement, etc.\nWe already handle these cases using our transaction building machinery and thus tests written here reflect the actual environment more.\nFor this guide there should be no need to go over the plutus simple model documentation but this doesn't mean that one shouldn't. It's very lucid and takes few minutes to cover and can be accessed by cloning their repository, entering the docs folder and running mdbook serve --open.","unit-tests-for-placing-a-bet-operation#Unit tests for placing a bet operation":"Entire code file for tests pertaining to this operation is available here. Note that we are using tasty to write our tests and a file calling these individual unit tests is here.\nOur objective here would be to write tests for each of our operation, hence the name \"unit tests\". Though one may write other sort of tests as well, including property based ones.","defining-run-for-placing-a-bet-operation#Defining Run for placing a bet operation":"Before any jibber-jabber, let's see the code so that we know it isn't as complex as it might seem:\nplaceBetRun :: GYTxOutRef -> BetRefParams -> OracleAnswerDatum -> GYValue -> Maybe GYTxOutRef -> GYTxMonadRun GYTxId\nplaceBetRun refScript brp guess bet mPreviousBetsUtxoRef = do\n  addr <- ownAddress\n  skeleton <- placeBet refScript brp guess bet addr mPreviousBetsUtxoRef\n  sendSkeleton skeleton\nWhy do we call it \"run\"? Well if you have gone over the documentation of plutus simple model, you'll know that they have this \"Run\" monad where actually most of the test code gets executed and we have wrapper around this type, which we call GYTxMonadRun. But as an end developer, there is no need to understand about it.Also our GYTxMonadRun has an instance of GYTxQueryMonad.\nThe idea here is that any tests we do related to performing the bet operation would need to call the placeBet function which we have defined before. Therefore we have defined a run to call this function. Our placeBetRun function takes all those parameters which are required by placeBet function, except the address as that we are able to get using ownAddress function. ownAddress function is defined in GeniusYield.TxBuilder.Run module where actually most of the code related to our wrapper lives and it gives the address of the wallet running this run as we'll shortly see.Lastly sendSkeleton can be understood as submitting the transaction. It will update the mock ledger state and return the transaction id for the submitted transaction. Note that it does raise an exception in case it fails to submit the transaction.","understanding-testrun#Understanding testRun":"Before we see a trace calling the run we just defined, notice that in our testGroup, we have the first test written as:\ntestRun \"Balance checks after placing first bet\" $ firstBetTrace (OracleAnswerDatum 3) (valueFromLovelace 20_000_000) 0_182_793\nNow what is this testRun?This function takes a string to represent the name of the test and a continuation function (of type Wallets -> Run a) and then internally generates wallets to give to our continuation function.The type Wallets is defined as:\ndata Wallets = Wallets\n    { w1 :: !Wallet\n    , w2 :: !Wallet\n    , w3 :: !Wallet\n    , w4 :: !Wallet\n    , w5 :: !Wallet\n    , w6 :: !Wallet\n    , w7 :: !Wallet\n    , w8 :: !Wallet\n    , w9 :: !Wallet\n    } deriving (Show, Eq, Ord)\nwhere Wallet is:\ndata Wallet = Wallet\n    { walletPaymentSigningKey :: !GYPaymentSigningKey\n    , walletNetworkId         :: !GYNetworkId\n    , walletName              :: !String\n    }\n    deriving (Show, Eq, Ord)\nThus our testRun function, generates these 9 wallets where each wallet is having the following three assets:\nMillion ada.\nMillion fakeGold.\nMillion fakeIron.\nwhere fakeGold and fakeIron are our two non-native assets.Each call to testRun (as you can see - we have multiple tests, all beginning with testRun) runs the given test with a fresh (new) blockchain ledger state having given the above balances to those 9 wallets.In our case, \"Balance checks after placing first bet\" is the name of the test and firstBetTrace (OracleAnswerDatum 3) (valueFromLovelace 20_000_000) 0_182_793 is our continuation function.","defining-a-trace-to-call-placebetrun#Defining a trace to call placeBetRun":"Now let's see the definition firstBetTrace we briefly encountered above:\n-- | Trace for placing the first bet.\nfirstBetTrace :: OracleAnswerDatum  -- ^ Guess\n              -> GYValue            -- ^ Bet\n              -> Wallets -> Run ()  -- Our continuation function\nfirstBetTrace dat bet ws@Wallets{..} = do\n  -- First step: Get the required parameters for initializing our parameterized script and add the corresponding reference script\n  (brp, refScript) <- computeParamsAndAddRefScript 40 100 (valueFromLovelace 200_000_000) ws\n  void $ runWallet w1 $ do  -- following operations are ran by first wallet, `w1`\n  -- Second step: Perform the actual run.\n    withWalletBalancesCheckSimple [w1 := valueNegate bet] $ do\n      placeBetRun refScript brp dat bet Nothing\nHere the last argument is of type Wallets as we noted.Note that this function starts by calling computeParamsAndAddRefScript, therefore let's see about it:\n-- | Function to compute the parameters for the contract and add the corresponding refernce script.\ncomputeParamsAndAddRefScript\n  :: Integer                                    -- ^ Bet Until slot\n  -> Integer                                    -- ^ Bet Reveal slot\n  -> GYValue                                    -- ^ Bet step value\n  -> Wallets -> Run (BetRefParams, GYTxOutRef)  -- Our continuation\ncomputeParamsAndAddRefScript betUntil' betReveal' betStep Wallets{..} = do\n  let betUntil = slotFromApi (fromInteger betUntil')\n      betReveal = slotFromApi (fromInteger betReveal')\n  fmap fromJust $ runWallet w1 $ do\n    betUntilTime <- slotToBeginTime betUntil\n    betRevealTime <- slotToBeginTime betReveal\n    let brp = BetRefParams (pubKeyHashToPlutus $ walletPubKeyHash w8) (timeToPlutus betUntilTime) (timeToPlutus betRevealTime) (valueToPlutus betStep)  -- let oracle be wallet `w8`.\n    mORef <- addRefScript (walletAddress w9) (betRefValidator' brp)\n    case mORef of\n      Nothing        -> fail \"Couldn't find index of the Reference Script in outputs\"\n      Just refScript -> return (brp, refScript)\nOur first step is to construct the parameter (BetRefParams) for our parameterized contract. Recall its type is:\ndata BetRefParams = BetRefParams\n  {\n    brpOraclePkh :: PubKeyHash  -- ^ Oracle's payment public key hash. This is needed to assert that UTxO being looked at indeed belongs to the Oracle.\n  , brpBetUntil  :: POSIXTime   -- ^ Time until which bets can be placed.\n  , brpBetReveal :: POSIXTime   -- ^ Time at which Oracle will reveal the correct match result.\n  , brpBetStep   :: Value       -- ^ Each newly placed bet must be more than previous bet by `brpBetStep` amount.\n  }\nFor brpBetUntil, we choose slot 40 but since plutus works in posix time, we need to enter a monad having an instance of GYTxQueryMonad to get posix time from slot and therefore that calculation happens inside runWallet w1. Similarly for brpBetReveal we chose slot 100.\nrunWallet is a utility function which enables us to give the environment. Hm.. what environment you ask? Well in general when constructing the transaction from skeleton we need some context, like who is actually submitting this transaction? As we'll need their address to give them the change output. runWallet takes as first argument, the wallet to generate context from and then the actual run to run against this context.\nNow coming back to our parameters, for brpOraclePkh parameter, we chose that for wallet 8. And we take our step amount to be 200 ada.Though it is not required for this operation (where we place the first bet) but since our placeBet function is overloaded to accept the subsequent bet case too - we need to give reference to the UTxO containing reference script. For that we have a helper function called addRefScript which adds the given script at a given address (we chose that for wallet 9) and returns the reference to it (in Maybe).Now we are almost done to call our run with just one more line to understand.withWalletBalancesCheckSimple takes a list of tuple where the first element of the tuple is the wallet and second element denotes the difference in the wallet's value which we expect after the execution of the operation defined inside its do block excluding ada required for transaction fees and to satisfy minimum ada requirements of the generated output. Here we want the balance of wallet 1 (which is the one actually calling this operation) to decrease by the bet amount and also the fees.\nHow do we know the fees?\nWell by running the test without it and then noting the transaction fees from the log messages.\nAnd this covers our first test ðŸ¥³.","multiple-bets-trace#Multiple bets trace":"Now let's write a slightly more involved trace. This time we'll make our trace parameteric over the required contract parameters.Here is the signature of our trace:\n-- | Trace which allows for multiple bets.\nmultipleBetsTraceWrapper\n  :: Integer                                            -- ^ slot for betUntil\n  -> Integer                                            -- ^ slot for betReveal\n  -> GYValue                                            -- ^ bet step\n  -> [(Wallets -> Wallet, OracleAnswerDatum, GYValue)]  -- ^ List denoting the bets\n  -> Wallets -> Run ()                                  -- Our continuation function\nmultipleBetsTraceWrapper betUntil' betReveal' betStep walletBets ws = do\n  -- First step: Get the required parameters for initializing our parameterized script and add the corresponding reference script\n  (brp, refScript) <- computeParamsAndAddRefScript betUntil' betReveal' betStep ws\n  -- Second step: Perform the actual bet operations\n  multipleBetsTraceCore brp refScript walletBets ws\nThe first three parameters correspond to the parameters of contract.The fourth parameter denotes the different bets.We may for instance call this function like so:\ntestRun \"Balance checks with multiple bets\" $ multipleBetsTraceWrapper 400 1000 (valueFromLovelace 10_000_000) \n  [ (w1, OracleAnswerDatum 1, valueFromLovelace 10_000_000)\n  , (w2, OracleAnswerDatum 2, valueFromLovelace 20_000_000)\n  , (w3, OracleAnswerDatum 3, valueFromLovelace 30_000_000)\n  , (w2, OracleAnswerDatum 4, valueFromLovelace 50_000_000)\n  , (w4, OracleAnswerDatum 5, valueFromLovelace 65_000_000 <> fakeGold 1000)\n  ]\nNext we want to add our reference script and compute the actual contract parameters (converting slot to posix) - which is again handled like before.We would then like to perform the actual bet operations. But this time we won't concern ourselves much with actual fees but rather take a threshold of 1 ada. Our approach here is to compare the balances before performaing any operation and after performing all the operations and then see that each wallet has lost the bet amount they placed considering threshold fees.Note: We use balance function to get the balance for the given wallet.\n-- | Trace which allows for multiple bets.\nmultipleBetsTraceCore\n  :: BetRefParams\n  -> GYTxOutRef                                         -- ^ Reference script\n  -> [(Wallets -> Wallet, OracleAnswerDatum, GYValue)]  -- ^ List denoting the bets\n  -> Wallets -> Run ()                                  -- Our continuation function\nmultipleBetsTraceCore brp refScript walletBets ws@Wallets{..} = do\n  let\n      -- | Perform the actual bet operation by the corresponding wallet.\n      performBetOperations [] _ = return ()\n      performBetOperations ((getWallet, dat, bet) : remWalletBets) isFirst = do\n        if isFirst then do\n          void $ runWallet (getWallet ws) $ do\n            void $ placeBetRun refScript brp dat bet Nothing\n          performBetOperations remWalletBets False\n        else do\n          -- need to get previous bet utxo\n          void $ runWallet (getWallet ws) $ do\n            betRefAddr <- betRefAddress brp\n            [_scriptUtxo@GYUTxO {utxoRef}] <- utxosToList <$> utxosAtAddress betRefAddr\n            void $ placeBetRun refScript brp dat bet (Just utxoRef)\n          performBetOperations remWalletBets False\n      -- | To sum the bet amount for the corresponding wallet.\n      sumWalletBets _wallet [] acc = acc\n      sumWalletBets wallet ((getWallet, _dat, bet) : remWalletBets) acc = sumWalletBets wallet remWalletBets (if getWallet ws == wallet then acc <> valueNegate bet else acc)\n      -- | Idea here is that for each wallet, we want to know how much has been bet. If we encounter a new wallet, i.e., wallet for whose we haven't yet computed value lost, we call `sumWalletBets` on it.\n      getBalanceDiff [] _set acc = acc\n      getBalanceDiff wlBets@((getWallet, _dat, _bet) : remWalletBets) set acc =\n        let wallet = getWallet ws\n            wallet'sName = walletName wallet\n        in\n          if Set.member wallet'sName set then getBalanceDiff remWalletBets set acc\n          else\n           getBalanceDiff remWalletBets (Set.insert wallet'sName set) ((wallet := sumWalletBets wallet wlBets mempty) : acc)\n      balanceDiffWithoutFees = getBalanceDiff walletBets Set.empty []\n  balanceBeforeAllTheseOps <- fmap fromJust $ runWallet w1 $ traverse (\\(wallet, _value) -> balance wallet) balanceDiffWithoutFees\n  performBetOperations walletBets True\n  balanceAfterAllTheseOps <- fmap fromJust $ runWallet w1 $ traverse (\\(wallet, _value) -> balance wallet) balanceDiffWithoutFees\n  void $ runWallet w1 $ verify (zip3 balanceDiffWithoutFees balanceBeforeAllTheseOps balanceAfterAllTheseOps)\n  where\n    -- | Function to verify that the wallet indeed lost by /roughly/ the bet amount. We say /roughly/ as fees is assumed to be within (0, 1 ada].\n    verify [] = return ()\n    verify (((wallet, diff), vBefore, vAfter) : xs) =\n      let vAfterWithoutFees = vBefore <> diff\n          (expectedAdaWithoutFees, expectedOtherAssets) = valueSplitAda vAfterWithoutFees\n          (actualAda, actualOtherAssets) = valueSplitAda vAfter\n          -- threshold = valueFromLovelace 1_000_000  -- 1 ada\n          threshold = 1_000_000  -- 1 ada\n      in if expectedOtherAssets == actualOtherAssets && actualAda < expectedAdaWithoutFees && expectedAdaWithoutFees - threshold <= actualAda then verify xs\n             -- valueGreater vAfterWithoutFees vAfter && valueGreaterOrEqual vAfter (valueMinus vAfterWithoutFees threshold) then verify xs\n         else fail (\"For wallet \" <> walletName wallet <> \" expected value (without fees) \" <> show vAfterWithoutFees <> \" but actual is \" <> show vAfter)\nAn eagle eye might notice two comments inside the verify function.Firstly, note that valueSplitAda splits our GYValue into lovelaces and that which remains besides it. Since fees don't affect non-ada tokens (not yet), we compare with respect to threshold using ada tokens.We could also compare GYValue's directly using valueGreater (there is also valueGreaterOrEqual) as done in comments but the current one is slightly more optimal as we need not compare on non-ada tokens again.","but-sometimes-we-want-a-test-to-fail#But sometimes we want a test to fail!":"What happens if the newly placed bet is not more than atleast brpBetStep amount? What happens if the transaction skeleton was somewhat wrong, say we didn't put mustBeSignedBy? What if someone tries to place a bet after brpBetUntil? What if...Well for all such cases, we can assert that a given trace must fail using mustFail like:\ntestRun \"Not adding atleast bet step amount should fail\" $ mustFail . multipleBetsTrace 400 1000 (valueFromLovelace 10_000_000) \n  [ (w1, OracleAnswerDatum 1, valueFromLovelace 10_000_000)\n  , (w2, OracleAnswerDatum 2, valueFromLovelace 20_000_000)\n  , (w3, OracleAnswerDatum 3, valueFromLovelace 30_000_000)\n  , (w2, OracleAnswerDatum 4, valueFromLovelace 50_000_000)\n  , (w4, OracleAnswerDatum 5, valueFromLovelace 55_000_000 <> fakeGold 1000)]\nHere wallet w4 didn't increase the bet by 10 ada and thus must fail.\nSometimes we want to assert specific failure among other possible failures. As mustFail above doesn't distinguish among them, one can simply use catchError like in this test.","unit-tests-for-taking-the-bet-pot#Unit tests for taking the bet pot":"Entire code file for tests pertaining to this operation is available here.\nOn similar lines as before, let's first define our run for takeBets operation:\n-- | Run to call the `takeBets` operation.\ntakeBetsRun :: GYTxOutRef -> BetRefParams -> GYTxOutRef -> GYTxOutRef -> GYTxMonadRun GYTxId\ntakeBetsRun refScript brp toConsume refInput = do\n  addr <- ownAddress\n  skeleton <- takeBets refScript brp toConsume addr refInput\n  sendSkeleton skeleton\nNext, we'll define our trace to call this run:\n-- | Trace for taking bet pot.\ntakeBetsTrace :: Integer                                            -- ^ slot for betUntil\n              -> Integer                                            -- ^ slot for betReveal\n              -> GYValue                                            -- ^ bet step\n              -> [(Wallets -> Wallet, OracleAnswerDatum, GYValue)]  -- ^ List denoting the bets\n              -> Integer                                            -- ^ Actual answer\n              -> (Wallets -> Wallet)                                -- ^ Taker\n              -> Bool                                               -- ^ To check balance\n              -> Wallets -> Run ()  -- Our continuation function\ntakeBetsTrace betUntil' betReveal' betStep walletBets answer getTaker toCheckBalance ws@Wallets{..} = do\n  (brp, refScript) <- computeParamsAndAddRefScript betUntil' betReveal' betStep ws\n  multipleBetsTraceCore brp refScript walletBets ws\n  -- Now lets take the bet\n  mMRef <- runWallet w1 $ addRefInput True (walletAddress w8) (datumFromPlutusData $ OracleAnswerDatum answer)\n  let taker = getTaker ws\n  case mMRef of\n    Just (Just refInput) -> do\n      void $ runWallet taker $ do\n        betRefAddr <- betRefAddress brp\n        [_scriptUtxo@GYUTxO {utxoRef, utxoValue}] <- utxosToList <$> utxosAtAddress betRefAddr Nothing\n        waitUntilSlot $ slotFromApi (fromInteger betReveal')\n        (if toCheckBalance then withWalletBalancesCheckSimple [taker := utxoValue] $ do\n            takeBetsRun refScript brp utxoRef refInput else takeBetsRun refScript brp utxoRef refInput)\n    _anyOtherMatch -> fail \"Couldn't place reference input successfully\"\nHere we first did the common step of computing the required script parameters and adding the reference script.Then we used addRefInput whose purpose here would become clear by seeing its haddock documentation below:\n-- | Adds an input (whose datum we'll refer later) and returns the reference to it.\naddRefInput:: Bool       -- ^ Whether to inline this datum?\n           -> GYAddress  -- ^ Where to place this output?\n           -> GYDatum    -- ^ Our datum.\n           -> GYTxMonadRun (Maybe GYTxOutRef)\nNext we simply wait until time for bet revealation and claim our pot!Now that we have our trace for taking bet pot, we can try testing for other conditions - examples for some are written in the TakeBetPot.hs file.We use a custom fork of Plutus simple model.To convey the message better, we have a defined (:=) pattern synonym:\npattern (:=) :: x -> y -> (x, y)\npattern (:=) x y = (x, y)\nSince we require the signature being present in the skeleton, we can't place bet on anyone else's behalf anyways.If you would like exact fine grained control over balance change, use withWalletBalancesCheck instead."}},"/":{"title":"Index","data":{}},"/introduction":{"title":"Introduction","data":{"":"Atlas is an all-in-one, Haskell-native application backend for writing off-chain code for on-chain Plutus smart contracts. Atlas has been designed by Genius Yield, in collaboration with MLabs, Well-Typed and Plank.","features#Features":"","easily-build-transactions#Easily build transactions":"Use an intuitive API to abstract away the complexity around building transactions, balancing UTxOs, and interfacing with Plutus smart contracts.","leverage-first-class-haskell#Leverage first-class Haskell":"Avoid code duplication between on-chain and off-chain code, interoperate with advanced functionalities offered by IOG's Cardano/Plutus libraries, and easily convert between Atlas and Cardano API/Plutus Ledger API types.","utilize-modular-data-providers#Utilize modular data providers":"Query ledger state information from remote provider such as Maestro, Blockfrost or from your own node with the help of Kupo. You can also build and contribute your own data provider!","test-extensively#Test extensively":"Use Atlas' test harness to write realistic tests\nthat can be run against an emulator or a private Cardano network.","stay-up-to-date#Stay up to date":"Benefit from Cardano's latest innovations such as Reference Inputs, Inline Datums and Reference Scripts. Conway we are looking at you ðŸ‘€.","where-to-next#Where to next?":"Work through an end-to-end example here: Getting Started.\nThis guide tracks the latest commit of Atlas. We bring changes into Atlas, only when corresponding updates have been made into the documentation as well."}},"/more-tutorials":{"title":"More Tutorials","data":{"vesting#Vesting":"See the introductory walkthrough of Atlas given by Dr. Lars using his with favourite example, Vesting, here. Associated code is available at atlas-examples repository."}},"/getting-started/testing":{"title":"Testing","data":{"":"Writing smart contracts and operations over them go hand in hand with testing them.Tests are also an excellent way to check your smart contracts\ninstead of building transactions using cardano-cli\nand submitting them to a local node.","levels-of-testing#Levels of testing":"Now that we have written our smart contracts and defined the required operations,\nlet's see whether they work as expected. When it comes to testing dApps there are\nplenty of techniques and approaches. Let's focus on levels at which we can\nperform testing:\nTesting of UPLC functions. You may want to verify that individual functions\nyour validators or minting policies consist of, indeed hold some properties. This is\nuseful if your on-chain logic is convoluted and involves complex computations.\nThis level is tightly coupled to the language you use to build your smart contracts\nso you should consult the documentation.\nTesting of individual contracts (script level).\nYou might want to verify that the on-chain contracts you developed behave as expected\nin isolation just by calling them with hand-constructed arguments for datum,\nredeemer, and script context (since they are just functions after all)\nand checking the results. Here again, you can use language-specific tools.\nBut in case your contracts are already compiled down to UPLC code,\nyou will need a special testing framework to do that.\nAtlas currently doesn't provide such a thing, but there exist some projects of help,\nnamely liqwid-context-builder\nfrom Liqwid's Libs mono repo. It allows one to easily construct various transaction contexts\nand verify a result that a particular script evaluates.\nTesting of individual contracts proved to be very fruitful for both simple\nand complex applications since it discovers bugs at very early stages\neven before operations are defined.\nTesting of operations (transactions).\nAt this level, one can execute whole operations (transactions)\nan application provides and verifies that they a) can run through and\nb) confirm that some conditions we are interested in are held.\nA nice thing to know about Atlas is that it allows you to reuse the code for operations\nyou created in the previous step Operations over Contract.\nThis is the level of testing we discuss in this section.\nYou can also make a distinction between testing individual transactions and\ntesting a flow of transactions, but in practice, it proves to be hard\nto prepare a hand-made environment for most intermediary transactions to be run in\nwithout running transactions that precede, so mostly it boils down\nto test the whole transaction flow.","overview-of-unified-testing-in-atlas#Overview of unified testing in Atlas":"Testing of whole operations (transactions) requires a Cardano ledger to evaluate them\nand keep the state.\nThere are two interchangeable options available in Atlas.\nWe will call them ledger backends throughout the rest of the section:\nCLB emulator\n(a modern replacement for deprecated PSM library)\nis the preferable way to test operations.\nIt's built around the pure Cardano ledger without the use of any network or consensus bits\nand offers incredibly high speed with a tiny memory footprint,\nbut with some functional limitations.\nYou can easily spin up a fresh emulator ledger for every test case,\nwhich makes running tests in isolation a trivial task.\nCardano private test network option (privnet for short) provides a more realistic environment.\nIt is a cluster of three cardano-node instances\nthat potentially could support all Cardano features,\nincluding staking and governance.\nThe main downside of a privnet is that testing time is significantly bigger\n(minutes not seconds even for simple tests).\nSo it's practically impossible to have a fresh network for every test case\nbut rather for the whole test suite run.\nBear in mind that the behavior of the CLB emulator and a Cardano private network differ.Not all features are supported in the emulator, and some notions, e.g. blocks and time\nis not represented enough in the emulator to carry out all tests.Fortunately, you can switch easily between two backends with unified testing.TODO: add more information on how CLB/privnet differ.\nNow that we know what the two backends available are,\nlet's spend some time understanding what unified testing in Atlas offers.\nIf we dissect a test case within a test suite\nwe can identify the following things involved:\nAn application under testing, including:\nSmart contracts\nOperations, which usually prepare transactions (or their skeletons)\nDefinition of a test case, including:\nA prelude sequence of actions that prepare the state for a particular\noperation to be ready to be executed\nA condition that wraps an operation we are testing  in the test case\nand expresses checks we want to verify\nTest suite runtime:\nA ledger backend\nSome code to run a test case against a backend\nThe idea of unified testing pursues the goal of making items under (1) and (2) reusable\nacross different (currently, the two mentioned above) ledger backends.Let's run through an example test suite to get the idea and figure out its details.","testing-placing-a-bet#Testing placing a bet":"You can find the entire code for this example here.\nMind you we are using tasty to write tests.\nOur objective here would be to write test cases for one of two main operations\nfrom the bet-ref example - namely for placing bet operation.","testing-environment#Testing environment":"Unified testing hides implementation details specific to ledger backends under\na layer of abstraction. Regardless of the backend we ultimately choose there is\nTestInfo datatype that provides access to user wallets among other things.\nA wallet is represented by User datatype that holds signing keys, address,\nand collateral to use:\ndata TestInfo = TestInfo\n  { testGoldAsset :: !GYAssetClass\n  , testIronAsset :: !GYAssetClass\n  , testWallets :: !Wallets }\ndata Wallets = Wallets\n    { w1 :: !User\n    ... more eighth wallets ...\n    }\ndata User = User\n    { userPaymentSKey     :: !GYPaymentSigningKey\n    , userStakeSKey       :: !(Maybe GYStakeSigningKey)\n    , userAddresses       :: !(NonEmpty GYAddress)\n    , userChangeAddress   :: !GYAddress\n    , userCollateral      :: Maybe UserCollateral\n    }\nEvery wallet in Wallets will be funded with an initial set of assets:\nMillion ADA.\nMillion fakeGold.\nMillion fakeIron.\nfakeGold and fakeIron are testing Cardano native assets that might be useful\n(though you can ignore them safely).In previous sections, we got acquainted with several monads available in Atlas\nnamely GYTxQueryMonad and GYTxMonad that allowed us to query the blockchain\nand to construct transactions. Now it's time to introduce another monad that\nfacilitates testing - GYTxGameMonad. Its most important action is called\nasUser and allows to run computations in GYTxMonad using a particular\nwallet (signature is slightly simplified):\nasUser :: User -> GYTxMonad a -> m a\nWe conventionally call actions in GYTxGameMonad \"runners\" since they run some\noperations by submitting them under a particular user. We will see examples soon.Then we have two functions that allow us to make a test case for a particular\nbackend out of a runner (the signature again is slightly modified here):\nmkTestFor :: TestName -> (TestInfo -> GYTxGameMonad a) -> TestTree\nmkPrivnetTestFor :: Setup -> TestName ->  (TestInfo -> GYTxGameMonad a) -> TestTree\nBoth functions take a name for a test case and a continuation function of type\nTestInfo -> GYTxGameMonad a. Then they internally generate the environment to\ndo the job. The difference is that mkPrivnetTestFor also takes a value of type\nSetup that contains information about an instance of a private network.\nThis highlights an important distinction between them:\nmkTestFor spawns a new instance of the emulator on every call - that way\nall test cases will be given with a fresh (new) blockchain ledger state having\nthe above balances to those 9 wallets.\nmkPrivnetTestFor is supposed to be run inside a helper function\nwithPrivnet which spins up a private testnet according to the configuration\nprovided and calls a series of test cases (i.e. the whole test suite) against it.\nLet's use these bits to build various test cases for operations\nwithin bet-ref example.","defining-runner-for-bet-placing-operation#Defining runner for bet placing operation":"Let's start with the runner to test placeBet operation. We won't see anything\nnew here. It just uses asUser action we just learned to run the operation.\nWe need values of all arguments that our operation takes. We cannot know them, so\nwe just take all of them as arguments to the runner itself, except the address as\nit can be obtained using ownAddresses function. This function  gives back all\nthe addresses of the wallet (User) that we provide to asUser.\nOnce we get the result of the operation, we can build, sign, and submit a transaction.\nHere, again, the wallet we specified to asUser action is used to sign it\n(though you can add additional signatures manually).\nLet's take a look at the code (you can find the full version in the sources,\nhere it's slightly redacted for simplicity).\n-- | Run to call the `placeBet` operation.\nrunPlaceBet\n  :: GYTxGameMonad m                   -- We write runners in `GYTxGameMonad` monad\n  => GYTxOutRef                        -- ^ Script output reference\n  -> BetRefParams                      -- ^ Parameters\n  -> OracleAnswerDatum                 -- ^ Bet guess\n  -> GYValue                           -- ^ Bet value\n  -> Maybe GYTxOutRef                  -- ^ Ref output with existing bets\n  -> User                              -- ^ User that plays bet\n  -> m GYTxId\nrunPlaceBet refScript brp guess bet mPrevBets user =\n  asUser user $ do\n    -- Get the address\n    addr <- maybeM (throwAppError $ someBackendError \"No own addresses\")\n      pure  $ listToMaybe <$> ownAddresses\n    -- Call the operation\n    skeleton <- placeBet refScript brp guess bet addr mPrevBets\n    -- Submit the transaction\n    buildTxBody skeleton >>= signAndSubmitConfirmed","additional-runners#Additional runners":"Let's take a look at the arguments our runner takes:\nrunPlaceBet\n  :: GYTxOutRef                        -- ^ Script output reference\n  -> BetRefParams                      -- ^ Parameters\n  -> OracleAnswerDatum                 -- ^ Bet guess\n  -> GYValue                           -- ^ Bet value\n  -> Maybe GYTxOutRef                  -- ^ Ref output with existing bets\n  -> User                              -- ^ User that plays bet\n  -> m GYTxId\nBet guess, value, existing bets, and the user that plays a bet pertain to the\ntest case, so we should somehow pick or generate values for them\n(we will just use some sensible values in this example).\nBut the first argument of type GYTxOutRef can't seem to be easy to know.\nIt's the transaction output reference (transaction hash and output index number)\nthat should contain a reference script on the ledger. To create it we need to build\nand submit another transaction.So we need another runner that applies the script to arguments, builds a transaction\nthat will deploy it, sign and submits it. Let's pretend we don't have such an operation\nto build a transaction to deploy within our application but what we have is\na function that makes the script. Notice the use GYTxQueryMonad here since all that function\nneeds is only to figure out the current slot in the ledger to make the calculations:\n-- | Queries the current slot, calculates the parameters, and builds\n-- a script that is ready to be deployed.\nmkScript\n  :: GYTxQueryMonad m\n  => Integer        -- ^ How many slots betting should be open\n  -> Integer        -- ^ How many slots should pass before oracle reveals answer\n  -> GYPubKeyHash   -- ^ Oracle PKH\n  -> GYValue        -- ^ Bet step value\n  -> m (BetRefParams, GYScript PlutusV2)\nmkScript betUntil betReveal oraclePkh betStep = do\n ... [the body is omitted] ...\nIt takes several parameters that define the process of betting,\ndoes some calculations, and gives us back all the parameters of type BetRefParams\nand also GYScript PlutusV2 which is the script we can deploy. So in this case\nwe have to build the transaction directly within the runner. Fortunately,\nwe can use addRefScript function that does exactly what we need:\n-- | Runner to build and submit a transaction that deploys the reference script.\nrunDeployScript\n  :: GYTxGameMonad m\n  => Integer                        -- ^ Bet Until slot\n  -> Integer                        -- ^ Bet Reveal slot\n  -> GYValue                        -- ^ Bet step value\n  -> Wallets\n  -> m (BetRefParams, GYTxOutRef)\nrunDeployScript betUntil betReveal betStep ws = do\n  (params, script) <- mkScript betUntil betReveal (userPkh $ oracle ws) betStep\n  asUser (admin ws) $ do\n    let sAddr = userAddr (holder ws)\n    refScript <- addRefScript sAddr script\n    pure (params, refScript)\nThis runner doesn't call any application operations, but now we can run it\nbefore our main runner runPlaceBet since it returns both BetRefParams\nand GYTxOutRef we need to call the main runner and ultimately placeBet\noperation.","place-first-bet-test#Place first bet test":"Now we are finally ready to write our first test.\nIt should first use runDeployScript to calculate and deploy the script\nand then run the main runner runPlaceBet\nchecking that a transaction goes through and the balance of the user\nthat submits it gets smaller accordingly\n(of course, we could imagine other checks as well).\n-- | Test for placing the first bet.\nfirstBetTest\n  :: GYTxGameMonad m\n  => Integer\n  -> Integer\n  -> GYValue\n  -> OracleAnswerDatum\n  -> GYValue\n  -> TestInfo\n  -> m ()\nfirstBetTest betUntil betReveal betStep dat bet (testWallets -> ws@Wallets{w1}) = do\n  (brp, refScript) <- runDeployScript betUntil betReveal betStep ws\n  withWalletBalancesCheckSimple [w1 := valueNegate bet] $ do\n    void $ runPlaceBet refScript brp dat bet Nothing w1\nThe code almost verbatim repeats what we just said using the function withWalletBalancesCheckSimple.\nIt allows checking the change of wallet's balance with no caring about transaction and storage fees\n(the latter is also known as minimal ADA - the number of coins that should accompany Cardano native tokens).\nThis convenience is possible because Atlas manages its own record of\nall fees that were spent over the course of tests, so they can be accounted\nautomatically. This way we just provide the expected delta in balance by negating\nbet's value. More precisely this function takes a list of tuples where the first element\nof the tuple is the wallet and the second element denotes the difference in\nthe wallet's value which we expect after the execution of the operation\ndefined inside its do block.\nHere we want the balance of wallet 1 (which is the one calling this operation)\nto decrease with the bet amount and also the fees.We specify all parameters when defining a test case:\nplaceBetTests :: TestTree\nplaceBetTests = testGroup \"Place Bet (Emulator)\"\n    [ mkTestFor \"Balance checks after placing first bet\" firstBetTest'\n    ]\nfirstBetTest' :: GYTxGameMonad m => TestInfo -> m ()\nfirstBetTest' = firstBetTest\n  40\n  100\n  (valueFromLovelace 200_000_000)\n  (OracleAnswerDatum 3)\n  (valueFromLovelace 20_000_000)\nUse the following command to observe test's results (being granted you are inside a Nix\nshell):\n$ cabal run atlas-unified-tests -- -p 'Emulator.Place bet.Placing first bet'","multiple-bets-test#Multiple bets test":"Now let's write a slightly more involved test. This time we want to make sure\nthat many bets placed in a raw using different wallets can be submitted and the\nbalances of the wallets change accordingly.Let's start with defining some additional type aliases to save up space:\n-- This is an alias for fields of `Wallet` datatype\ntype Wallet = Wallets -> User\n-- This type represent a bet made by a wallet\ntype Bet = (Wallet, OracleAnswerDatum, GYValue)\nNow we want to write a function mkMultipleBetsTest, we can pass a list\nof concrete bets to build a test case:\nmultipleBetsTest :: GYTxGameMonad m => TestInfo -> m ()\nmultipleBetsTest TestInfo{..} = mkMultipleBetsTest\n  400 1_000 (valueFromLovelace 10_000_000) -- game params\n  -- list of bets\n  [ (w1, OracleAnswerDatum 1, valueFromLovelace 10_000_000)\n  , (w2, OracleAnswerDatum 2, valueFromLovelace 20_000_000)\n  , (w3, OracleAnswerDatum 3, valueFromLovelace 30_000_000)\n  , (w2, OracleAnswerDatum 4, valueFromLovelace 50_000_000)\n  , (w4, OracleAnswerDatum 5, valueFromLovelace 65_000_000\n                                <> valueSingleton testGoldAsset 1_000)\n  ]\n  testWallets\nAs usual, let's commence with a runner. We already have a runner for placing a\nsingle bet so we can reuse it:\n-- | Runner for multiple bets.\nrunMultipleBets\n  :: GYTxGameMonad m\n  => BetRefParams\n  -> GYTxOutRef                 -- ^ Reference script\n  -> [Bet]\n  -> Wallets\n  -> m ()\nrunMultipleBets brp refScript bets ws = go bets True\n  where\n    go [] _ = return ()\n    go ((getWallet, dat, bet) : remBets) isFirst = do\n      if isFirst then do\n        gyLogInfo' \"\" \"placing the first bet\"\n        void $ runPlaceBet refScript brp dat bet Nothing (getWallet ws)\n        go remBets False\n      else do\n        gyLogInfo' \"\" \"placing a next bet\"\n        -- need to get previous bet utxo\n        betRefAddr <- betRefAddress brp\n        GYUTxO{utxoRef} <- head . utxosToList <$> utxosAtAddress betRefAddr Nothing\n        gyLogDebug' \"\" $ printf \"previous bet utxo: %s\" utxoRef\n        void $ runPlaceBet refScript brp dat bet (Just utxoRef) (getWallet ws)\n        go remBets False\nThe runner recursively traverses the list of bets, calling runPlaceBet on every\nelement, indicating whether it is the first element or not using the last\nparameter of go. Once we have the runner at hand we can write the test. We are\ngoing to skip some details to handle balances, you can find the full version in\nthe source code.\n-- | Makes a test case for placing multiple bets.\nmkMultipleBetsTest\n  :: GYTxGameMonad m\n  => Integer                 -- ^ Number of slots for betting\n  -> Integer                 -- ^ Number of slots for revealing\n  -> GYValue                 -- ^ Bet step\n  -> [Bet]                   -- ^ List denoting the bets\n  -> Wallets                 -- ^ Wallets available\n  -> m ()\nmkMultipleBetsTest betUntil betReveal betStep bets ws = do\n  -- Deploy script\n  (brp, refScript) <- runDeployScript betUntil betReveal betStep ws\n  -- Get the balance\n  balanceBefore <- getBalance\n  gyLogDebug' \"\" $ printf \"balanceBeforeAllTheseOps: %s\" (mconcat balanceBefore)\n  -- Run operations\n  runMultipleBets brp refScript bets ws\n  -- Get the balance again\n  balanceAfter <- getBalance\n  gyLogDebug' \"\" $ printf \"balanceAfterAllTheseOps: %s\" (mconcat balanceAfter)\n  -- Check the difference\n  verify $ zip3\n    walletsAndBets\n    balanceBefore\n    balanceAfter\n  where\n    ... some balance-related functions are omitted here ...\n    -- | Function to verify that the wallet indeed lost by /roughly/ the bet amount.\n    -- We say /roughly/ as fees is assumed to be within (0, 1 ada].\n    verify :: GYTxGameMonad m => [((User, GYValue), GYValue, GYValue)] -> m ()\n    verify [] = return ()\n    verify (((wallet, diff), vBefore, vAfter) : xs) =\n      let vAfterWithoutFees = vBefore <> diff\n          (expectedAdaWithoutFees, expectedOtherAssets) = valueSplitAda vAfterWithoutFees\n          (actualAda, actualOtherAssets) = valueSplitAda vAfter\n          threshold = 1_000_000  -- 1 ada\n      in\n        if expectedOtherAssets == actualOtherAssets\n            && actualAda < expectedAdaWithoutFees\n            && expectedAdaWithoutFees - threshold <= actualAda\n        then verify xs\n        else\n          throwAppError . someBackendError . T.pack $\n            printf \"For wallet %s expected value (without fees) %s but actual is %s\"\n              (show $ userAddr wallet)\n              (show vAfterWithoutFees)\n              (show vAfter)\nUse the following command to observe the test's results (being granted you are inside a Nix\nshell):\n$ cabal run atlas-unified-tests -- -p 'Emulator.Place bet.Multiple bets'","writing-negative-tests#Writing negative tests":"But sometimes we want a test to fail! What happens if the newly placed bet is\nnot more than at least brpBetStep amount? What happens if the transaction\nskeleton is somewhat wrong, say we didn't put mustBeSignedBy? What if someone\ntries to place a bet after brpBetUntil? What if...Let's add another test:\nfailingMultipleBetsTest :: GYTxGameMonad m => TestInfo -> m ()\nfailingMultipleBetsTest TestInfo{..} = mkMultipleBetsTest\n  400 1_000 (valueFromLovelace 10_000_000)\n  [ (w1, OracleAnswerDatum 1, valueFromLovelace 10_000_000)\n  , (w2, OracleAnswerDatum 2, valueFromLovelace 20_000_000)\n  , (w3, OracleAnswerDatum 3, valueFromLovelace 30_000_000)\n  , (w2, OracleAnswerDatum 4, valueFromLovelace 50_000_000)\n  , (w4, OracleAnswerDatum 5, valueFromLovelace 55_000_000\n                                <> valueSingleton testGoldAsset 1_000)\n  ]\n  testWallets\nIf we run it we will get an error, since the last bet doesn't respect the minimal\nbet step which is 10_000_000 lovelaces. Well for all such cases, we can assert\nthat a given trace must fail. It's done slightly differently for the emulator and\na private test network. For the emulator we just use mustFail:\nplaceBetTestsClb :: TestTree\nplaceBetTestsClb = testGroup \"Place bet\"\n    [ mkTestFor \"Multiple bets - to small step\" $ mustFail . failingMultipleBetsTest\n    ]\nFor a private testnet it's more wordy:\nplaceBetTests :: Setup -> TestTree\nplaceBetTests setup = testGroup \"Place bet\"\n    [ mkPrivnetTestFor' \"Multiple bets - too small step\" GYDebug setup $\n        handleError\n          (\\case\n              GYBuildTxException GYBuildTxBodyErrorAutoBalance {} -> pure ()\n              e -> throwError e\n          )\n        . failingMultipleBetsTest\n    ]\nThis section concludes our journey to testing dApps with Atlas.If you were to have fine-grained control over balance change, use withWalletBalancesCheck instead.To convey the message better, we have a defined (:=) pattern synonym:\npattern (:=) :: x -> y -> (x, y)\npattern (:=) x y = (x, y)"}}}